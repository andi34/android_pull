From b2c421d6d5dc0b7599713e4095948df245af3e6d Mon Sep 17 00:00:00 2001
From: Tate Hornbeck <tate.hornbeck@ti.com>
Date: Wed, 18 Feb 2015 09:33:30 -0800
Subject: [PATCH 078/102] gpu: ion: omap: Interface to export ion_handles from
 PVR fd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The following API allow to export PVR ION handles from PVR fd.
This PVR fd are usually received from userspace.
The retrieved PVR handles are then imported to passed ION client
and new allocated handles can be used by caller to access ION buffers.

Change-Id: Ic5d12bbcbc1686d8446784cefee1e012598f1866
Signed-off-by: Rodrigo Obregon <robregon@ti.com>
[ruslan.ruslichenko@globallogic.com: Added importation of PVR handles to passed ION client]
Signed-off-by: Ruslan Ruslichenko <ruslan.ruslichenko@globallogic.com>
Signed-off-by: Vasyl Yushchyshen <vasyl.yushchyshen@globallogic.com>
Signed-off-by: D. Andrei Măceș <dmaces@nd.edu>
---
 drivers/gpu/ion/omap/omap_ion.c      | 86 ++++++++++++++++++++++++++++++++++++
 drivers/rpmsg/omaprpc/omap_rpc_ion.c | 17 +++----
 drivers/rpmsg/rpmsg_omx.c            | 31 ++++---------
 include/linux/omap_ion.h             |  2 +
 4 files changed, 104 insertions(+), 32 deletions(-)

diff --git a/drivers/gpu/ion/omap/omap_ion.c b/drivers/gpu/ion/omap/omap_ion.c
index 8d08ece..70fba95 100644
--- a/drivers/gpu/ion/omap/omap_ion.c
+++ b/drivers/gpu/ion/omap/omap_ion.c
@@ -22,6 +22,7 @@
 #include <linux/uaccess.h>
 #include "../ion_priv.h"
 #include "omap_ion_priv.h"
+#include <linux/syscalls.h>
 
 struct ion_device *omap_ion_device;
 EXPORT_SYMBOL(omap_ion_device);
@@ -149,6 +150,91 @@ int omap_ion_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int (*export_fd_to_ion_handles)(int fd,
+		struct ion_client **client,
+		struct ion_handle **handles,
+		int *num_handles);
+
+void omap_ion_register_pvr_export(void *pvr_export_fd)
+{
+	export_fd_to_ion_handles = pvr_export_fd;
+}
+EXPORT_SYMBOL(omap_ion_register_pvr_export);
+
+int omap_ion_share_fd_to_handles(int fd, struct ion_client *client,
+				 struct ion_handle **handles, int *num_handles)
+{
+	struct ion_handle **export_handles;
+	struct ion_client *export_client;
+	int i = 0, ret = 0, shared_fd = 0;
+
+	export_handles = kzalloc(*num_handles * sizeof(struct ion_handle *),
+			  GFP_KERNEL);
+	if (!export_handles)
+		return -ENOMEM;
+
+	if (export_fd_to_ion_handles) {
+		ret = export_fd_to_ion_handles(fd,
+				&export_client,
+				export_handles,
+				num_handles);
+		if (ret) {
+			pr_err("%s: export_fd_to_ion_handles failed\n",
+			       __func__);
+			goto exit;
+		}
+	} else {
+		pr_err("%s: export_fd_to_ion_handles not initialized\n",
+				__func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	for (i = 0; i < *num_handles; i++) {
+		handles[i] = NULL;
+		if (export_handles[i]) {
+			shared_fd = ion_share_dma_buf_fd(export_client,
+							 export_handles[i]);
+			if (shared_fd < 0) {
+				pr_err("%s: Failed to get buf fd, err = %d\n",
+				       __func__, shared_fd);
+				ret = shared_fd;
+				goto err;
+			}
+
+			handles[i] = ion_import_dma_buf(client, shared_fd);
+			if (IS_ERR(handles[i])) {
+				ret = PTR_ERR(handles[i]);
+				pr_err("%s: Failed to import buf, err = %d\n",
+				       __func__, ret);
+				sys_close(shared_fd);
+				handles[i] = NULL;
+				goto err;
+			}
+			sys_close(shared_fd);
+		}
+	}
+
+exit:
+	kfree(export_handles);
+	return ret;
+
+err:
+	/* Clear allocated handles on error */
+	while (i) {
+		if (handles[--i]) {
+			ion_free(client, handles[i]);
+			handles[i] = NULL;
+		}
+	}
+
+	kfree(export_handles);
+	return ret;
+
+}
+EXPORT_SYMBOL(omap_ion_share_fd_to_handles);
+
+
 static struct platform_driver ion_driver = {
 	.probe = omap_ion_probe,
 	.remove = omap_ion_remove,
diff --git a/drivers/rpmsg/omaprpc/omap_rpc_ion.c b/drivers/rpmsg/omaprpc/omap_rpc_ion.c
index d2f5ed0..d358f4b 100644
--- a/drivers/rpmsg/omaprpc/omap_rpc_ion.c
+++ b/drivers/rpmsg/omaprpc/omap_rpc_ion.c
@@ -115,19 +115,16 @@ phys_addr_t omaprpc_buffer_lookup(struct omaprpc_instance_t *rpc,
 			 * TODO: need to support 2 ion handles
 			 * per 1 pvr handle (NV12 case)
 			 */
-			struct ion_buffer *ion_buffer = NULL;
+			struct ion_handle *ion_handle = NULL;
 			int num_handles = 1;
-			handle = NULL;
-			if (omap_ion_share_fd_to_buffers((int)reserved,
-							 &ion_buffer,
+			if (omap_ion_share_fd_to_handles((int)reserved,
+							 rpc->ion_client,
+							 &ion_handle,
 							 &num_handles) < 0) {
 				goto to_va;
 			}
-			if (ion_buffer) {
-				handle = ion_import(rpc->ion_client,
-						    ion_buffer);
-			}
-			if (handle && !ion_phys(rpc->ion_client, handle,
+
+			if (ion_handle && !ion_phys(rpc->ion_client, ion_handle,
 						&paddr, &len)) {
 				lpa = (phys_addr_t) paddr;
 				OMAPRPC_PRINT(OMAPRPC_ZONE_INFO,
@@ -155,7 +152,7 @@ phys_addr_t omaprpc_buffer_lookup(struct omaprpc_instance_t *rpc,
 			 * will make sure the buffer is not freed while
 			 * we are still using it
 			 */
-			if (handle)
+			if (ion_handle)
 				ion_free(rpc->ion_client, handle);
 		}
 	}
diff --git a/drivers/rpmsg/rpmsg_omx.c b/drivers/rpmsg/rpmsg_omx.c
index 0d53007..dbbbf7a 100644
--- a/drivers/rpmsg/rpmsg_omx.c
+++ b/drivers/rpmsg/rpmsg_omx.c
@@ -561,7 +561,7 @@ long rpmsg_omx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 	case OMX_IOCPVRREGISTER:
 	{
 		struct omx_pvr_data data;
-		struct ion_buffer *ion_bufs[2] = { NULL, NULL };
+		struct ion_handle *ion_handles[2] = { NULL, NULL };
 		int num_handles = 2, i = 0;
 
 		if (copy_from_user(&data, (char __user *)arg, sizeof(data))) {
@@ -579,36 +579,23 @@ long rpmsg_omx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		}
 
 		data.handles[0] = data.handles[1] = NULL;
-		if (!omap_ion_share_fd_to_buffers(data.fd, ion_bufs,
-						  &num_handles)) {
+		if (!omap_ion_share_fd_to_handles(data.fd, omx->ion_client,
+						  ion_handles, &num_handles)) {
 			unsigned int size = ARRAY_SIZE(data.handles);
 			for (i = 0; (i < num_handles) && (i < size); i++) {
-				struct ion_handle *handle = NULL;
-
-				if (!IS_ERR_OR_NULL(ion_bufs[i]))
-					handle = ion_import(omx->ion_client,
-							   ion_bufs[i]);
-
 #ifdef CONFIG_MACH_TUNA
-				if (!IS_ERR_OR_NULL(handle))
+				if (!IS_ERR_OR_NULL(ion_handles[i]))
 #else
-				/* num_handles returned from
-				 * omap_ion_share_fd_to_buffers isn't reliable
-				 * in conveying the actual number of valid
-				 * handles returned. 'break' here if handle is
-				 * NULL. We are assuming there are no valid
-				 * handles in ion_bufs after the first NULL
-				 * handle we hit.
-				 */
-				if (IS_ERR_OR_NULL(handle))
+				if (IS_ERR_OR_NULL(ion_handles[i]))
 					break;
 
-				if (_is_page_list(omx, handle))
+				if (_is_page_list(omx, ion_handles[i]))
 					data.handles[i] = (void *)
-						_rpmsg_buffer_new(omx, handle);
+						_rpmsg_buffer_new(omx,
+								ion_handles[i]);
 				else
 #endif
-					data.handles[i] = handle;
+					data.handles[i] = ion_handles[i];
 			}
 		}
 		data.num_handles = i;
diff --git a/include/linux/omap_ion.h b/include/linux/omap_ion.h
index 75b51fe..d1c72d9 100644
--- a/include/linux/omap_ion.h
+++ b/include/linux/omap_ion.h
@@ -51,6 +51,8 @@ int omap_ion_nonsecure_tiler_alloc(struct ion_client *client,
 /* given a handle in the tiler, return a list of tiler pages that back it */
 int omap_tiler_pages(struct ion_client *client, struct ion_handle *handle,
 		     int *n, u32 ** tiler_pages);
+int omap_ion_share_fd_to_handles(int fd, struct ion_client *client,
+				struct ion_handle **handles, int *num_handles);
 int omap_tiler_vinfo(struct ion_client *client,
 			struct ion_handle *handle, unsigned int *vstride,
 			unsigned int *vsize);
-- 
2.7.4

