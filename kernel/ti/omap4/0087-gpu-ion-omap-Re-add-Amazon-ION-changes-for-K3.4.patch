From 3d4f801a6e7bd17b2c4e34ffe7a9149ab4801e00 Mon Sep 17 00:00:00 2001
From: Hashcode <hashcode0f@gmail.com>
Date: Wed, 18 Feb 2015 12:48:03 -0800
Subject: [PATCH 087/111] gpu: ion: omap: Re-add Amazon ION changes for K3.4
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: Ifb198ba421d0ed090b6dd44e9b75d78b17b1327d
Signed-off-by: D. Andrei Măceș <dmaces@nd.edu>
---
 drivers/gpu/ion/ion.c           | 17 +++++++++++++++++
 drivers/gpu/ion/omap/omap_ion.c | 32 +++++++++++++++++++++++++++++++-
 include/linux/ion.h             | 21 +++++++++++++++++++++
 include/linux/omap_ion.h        | 18 ++++++++++++++++++
 4 files changed, 87 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/ion/ion.c b/drivers/gpu/ion/ion.c
index 0d1652f..e91201c 100644
--- a/drivers/gpu/ion/ion.c
+++ b/drivers/gpu/ion/ion.c
@@ -512,6 +512,23 @@ int ion_phys(struct ion_client *client, struct ion_handle *handle,
 }
 EXPORT_SYMBOL(ion_phys);
 
+int ion_phys_frm_dev(struct ion_device *dev, struct ion_handle *handle,
+	     ion_phys_addr_t *addr, size_t *len)
+{
+	struct ion_buffer *buffer;
+	int ret;
+
+	buffer = handle->buffer;
+
+	if (!buffer->heap->ops->phys) {
+		pr_err("%s: ion_phys is not implemented by this heap.\n", __func__);
+		return -ENODEV;
+	}
+	ret = buffer->heap->ops->phys(buffer->heap, buffer, addr, len);
+	return ret;
+}
+EXPORT_SYMBOL(ion_phys_frm_dev);
+
 static void *ion_buffer_kmap_get(struct ion_buffer *buffer)
 {
 	void *vaddr;
diff --git a/drivers/gpu/ion/omap/omap_ion.c b/drivers/gpu/ion/omap/omap_ion.c
index 785d27e..727dc7c 100644
--- a/drivers/gpu/ion/omap/omap_ion.c
+++ b/drivers/gpu/ion/omap/omap_ion.c
@@ -29,6 +29,7 @@ int num_heaps;
 struct ion_heap **heaps;
 struct ion_heap *tiler_heap;
 static struct ion_heap *nonsecure_tiler_heap;
+static struct ion_platform_data *pdata;
 
 int omap_ion_tiler_alloc(struct ion_client *client,
 			 struct omap_ion_tiler_alloc_data *data)
@@ -68,6 +69,20 @@ long omap_ion_ioctl(struct ion_client *client, unsigned int cmd,
 			return -EFAULT;
 		break;
 	}
+	case OMAP_ION_PHYS_ADDR:
+	{
+		struct omap_ion_phys_addr_data data;
+		int ret;
+		if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+			return -EFAULT;
+		ret = ion_phys(client, data.handle, &data.phys_addr, &data.size);
+		if (ret)
+			return ret;
+		if (copy_to_user((void __user *)arg, &data,
+				 sizeof(data)))
+			return -EFAULT;
+		break;
+	}
 	default:
 		pr_err("%s: Unknown custom ioctl\n", __func__);
 		return -ENOTTY;
@@ -77,10 +92,11 @@ long omap_ion_ioctl(struct ion_client *client, unsigned int cmd,
 
 int omap_ion_probe(struct platform_device *pdev)
 {
-	struct ion_platform_data *pdata = pdev->dev.platform_data;
 	int err;
 	int i;
 
+	pdata = pdev->dev.platform_data;
+
 	num_heaps = pdata->nr;
 
 	heaps = kzalloc(sizeof(struct ion_heap *) * pdata->nr, GFP_KERNEL);
@@ -232,6 +248,20 @@ err:
 }
 EXPORT_SYMBOL(omap_ion_share_fd_to_handles);
 
+struct ion_platform_heap *omap_ion_get2d_heap(void)
+{
+	int i;
+	if (!pdata)
+		return NULL;
+	for (i = 0; i < num_heaps; i++) {
+		struct ion_platform_heap *heap_data = &pdata->heaps[i];
+		if (!strcmp(heap_data->name,"tiler")) {
+				return heap_data;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(omap_ion_get2d_heap);
 
 static struct platform_driver ion_driver = {
 	.probe = omap_ion_probe,
diff --git a/include/linux/ion.h b/include/linux/ion.h
index 8414a6d..6a829b7 100644
--- a/include/linux/ion.h
+++ b/include/linux/ion.h
@@ -185,6 +185,27 @@ void ion_free(struct ion_client *client, struct ion_handle *handle);
 int ion_phys(struct ion_client *client, struct ion_handle *handle,
 	     ion_phys_addr_t *addr, size_t *len);
 
+
+/**
+ * ion_phys_frm_dev - returns the physical address and len of a handle
+ * @dev:	ion_dev
+ * @handle:	the handle
+ * @addr:	a pointer to put the address in
+ * @len:	a pointer to put the length in
+ *
+ * This function queries the heap for a particular handle to get the
+ * handle's physical address.  It't output is only correct if
+ * a heap returns physically contiguous memory -- in other cases
+ * this api should not be implemented -- ion_map_dma should be used
+ * instead.  Returns -EINVAL if the handle is invalid.  This has
+ * no implications on the reference counting of the handle --
+ * the returned value may not be valid if the caller is not
+ * holding a reference.
+ */
+int ion_phys_frm_dev(struct ion_device *dev, struct ion_handle *handle,
+			ion_phys_addr_t *addr, size_t *len);
+
+
 /**
  * ion_map_dma - return an sg_table describing a handle
  * @client:	the client
diff --git a/include/linux/omap_ion.h b/include/linux/omap_ion.h
index d1c72d9..e2ef046 100644
--- a/include/linux/omap_ion.h
+++ b/include/linux/omap_ion.h
@@ -43,6 +43,22 @@ struct omap_ion_tiler_alloc_data {
 	u32 token;
 };
 
+/**
+ * struct omap_ion_phys_data - metadata passed from userspace to
+ * get physical address
+ *
+ * @handle:	the handle
+ * @phys_addr:	physical address of the buffer refered in handle
+ * @size:	size of the buffer
+ *
+ * Provided by userspace as an argument to the ioctl
+ */
+struct omap_ion_phys_addr_data {
+	struct ion_handle *handle;
+	unsigned long phys_addr;
+	size_t size;
+};
+
 #ifdef __KERNEL__
 int omap_ion_tiler_alloc(struct ion_client *client,
 			 struct omap_ion_tiler_alloc_data *data);
@@ -53,6 +69,7 @@ int omap_tiler_pages(struct ion_client *client, struct ion_handle *handle,
 		     int *n, u32 ** tiler_pages);
 int omap_ion_share_fd_to_handles(int fd, struct ion_client *client,
 				struct ion_handle **handles, int *num_handles);
+struct ion_platform_heap * omap_ion_get2d_heap(void);
 int omap_tiler_vinfo(struct ion_client *client,
 			struct ion_handle *handle, unsigned int *vstride,
 			unsigned int *vsize);
@@ -83,6 +100,7 @@ enum {
 
 enum {
 	OMAP_ION_TILER_ALLOC,
+	OMAP_ION_PHYS_ADDR,
 };
 
 /**
-- 
2.7.4

