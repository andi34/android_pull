From ec3aa2a8d18a8fc32ab9a58aac12c685a259f946 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?D=2E=20Andrei=20M=C4=83ce=C8=99?= <dmaces@nd.edu>
Date: Mon, 30 Nov 2015 13:09:31 -0500
Subject: [PATCH 092/111] Revert "Revert "ion: export functions to enable usage
 by kernel modules""
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit b37744453a060bbe0f3853cc99e2e4a0b44731f0.

Change-Id: Iccc90f5e7f1eb5e91be6a4409b85efc9bb7838f9
Signed-off-by: D. Andrei Măceș <dmaces@nd.edu>
---
 drivers/gpu/ion/omap/omap_ion.c        |  2 +
 drivers/gpu/ion/omap/omap_tiler_heap.c | 71 ++++++++++++++++++++++++++++++++--
 2 files changed, 70 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/ion/omap/omap_ion.c b/drivers/gpu/ion/omap/omap_ion.c
index 69f2ee2..1761c87 100644
--- a/drivers/gpu/ion/omap/omap_ion.c
+++ b/drivers/gpu/ion/omap/omap_ion.c
@@ -26,6 +26,8 @@
 #include <linux/module.h>
 
 struct ion_device *omap_ion_device;
+EXPORT_SYMBOL(omap_ion_device);
+
 int num_heaps;
 struct ion_heap **heaps;
 struct ion_heap *tiler_heap;
diff --git a/drivers/gpu/ion/omap/omap_tiler_heap.c b/drivers/gpu/ion/omap/omap_tiler_heap.c
index dba97db..23ecc87 100644
--- a/drivers/gpu/ion/omap/omap_tiler_heap.c
+++ b/drivers/gpu/ion/omap/omap_tiler_heap.c
@@ -25,11 +25,14 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <mach/tiler.h>
+#include <asm/cacheflush.h>
 #include <asm/mach/map.h>
 #include <asm/page.h>
+#include <plat/common.h>
 
 #include "../ion_priv.h"
 
+bool use_dynamic_pages;
 #define TILER_ENABLE_NON_PAGE_ALIGNED_ALLOCATIONS  1
 
 struct omap_ion_heap {
@@ -117,6 +120,48 @@ static void omap_tiler_free_carveout(struct ion_heap *heap,
 		gen_pool_free(omap_heap->pool, info->phys_addrs[i], PAGE_SIZE);
 }
 
+static int omap_tiler_alloc_dynamicpages(struct omap_tiler_info *info)
+{
+	int i;
+	int ret;
+	struct page *pg;
+
+	for (i = 0; i < info->n_phys_pages; i++) {
+		pg = alloc_page(GFP_KERNEL | GFP_DMA | GFP_HIGHUSER);
+		if (!pg) {
+			ret = -ENOMEM;
+			pr_err("%s: alloc_page failed\n",
+				__func__);
+			goto err_page_alloc;
+		}
+		info->phys_addrs[i] = page_to_phys(pg);
+		dmac_flush_range((void *)page_address(pg),
+			(void *)page_address(pg) + PAGE_SIZE);
+		outer_flush_range(info->phys_addrs[i],
+			info->phys_addrs[i] + PAGE_SIZE);
+	}
+	return 0;
+
+err_page_alloc:
+	for (i -= 1; i >= 0; i--) {
+		pg = phys_to_page(info->phys_addrs[i]);
+		__free_page(pg);
+	}
+	return ret;
+}
+
+static void omap_tiler_free_dynamicpages(struct omap_tiler_info *info)
+{
+	int i;
+	struct page *pg;
+
+	for (i = 0; i < info->n_phys_pages; i++) {
+		pg = phys_to_page(info->phys_addrs[i]);
+		__free_page(pg);
+	}
+	return;
+}
+
 static struct sg_table *omap_tiler_map_dma(struct omap_tiler_info *info,
 						struct ion_buffer *buffer)
 {
@@ -238,7 +283,11 @@ int omap_tiler_alloc(struct ion_heap *heap,
 
 	if ((heap->id == OMAP_ION_HEAP_TILER) ||
 	    (heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		ret = omap_tiler_alloc_carveout(heap, info);
+		if (use_dynamic_pages)
+			ret = omap_tiler_alloc_dynamicpages(info);
+		else
+			ret = omap_tiler_alloc_carveout(heap, info);
+
 		if (ret)
 			goto err_alloc;
 
@@ -289,7 +338,10 @@ err:
 err_pin:
 	if ((heap->id == OMAP_ION_HEAP_TILER) ||
 	    (heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		omap_tiler_free_carveout(heap, info);
+		if (use_dynamic_pages)
+			omap_tiler_free_dynamicpages(info);
+		else
+			omap_tiler_free_carveout(heap, info);
 	}
 err_alloc:
 	tiler_free_block_area(tiler_handle);
@@ -308,7 +360,10 @@ void omap_tiler_heap_free(struct ion_buffer *buffer)
 
 	if ((buffer->heap->id == OMAP_ION_HEAP_TILER) ||
 	    (buffer->heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		omap_tiler_free_carveout(buffer->heap, info);
+		if (use_dynamic_pages)
+			omap_tiler_free_dynamicpages(info);
+		else
+			omap_tiler_free_carveout(buffer->heap, info);
 	}
 
 	kfree(info);
@@ -450,6 +505,16 @@ struct ion_heap *omap_tiler_heap_create(struct ion_platform_heap *data)
 	heap->heap.type = OMAP_ION_HEAP_TYPE_TILER;
 	heap->heap.name = data->name;
 	heap->heap.id = data->id;
+
+#ifdef CONFIG_ION_OMAP_TILER_DYNAMIC_ALLOC
+	use_dynamic_pages = true;
+#else
+	if (omap_total_ram_size() <= SZ_512M)
+		use_dynamic_pages = true;
+	else
+		use_dynamic_pages = false;
+#endif
+
 	return &heap->heap;
 }
 
-- 
2.7.4

