From e0be24d763683ba66f8e96e9b376207177812f0d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?D=2E=20Andrei=20M=C4=83ce=C8=99?= <dmaces@nd.edu>
Date: Tue, 24 Nov 2015 13:06:47 -0500
Subject: [PATCH 003/111] Revert "ion: add support for tiler reservation heap"
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit cacfb33b6c0173a059309732c9664b286b37daad.

Signed-off-by: D. Andrei Măceș <dmaces@nd.edu>
---
 drivers/gpu/ion/omap/omap_ion.c        |   3 -
 drivers/gpu/ion/omap/omap_tiler_heap.c | 175 ++++++++++++---------------------
 include/linux/omap_ion.h               |   2 -
 3 files changed, 62 insertions(+), 118 deletions(-)

diff --git a/drivers/gpu/ion/omap/omap_ion.c b/drivers/gpu/ion/omap/omap_ion.c
index 5d65205..24c91b2 100644
--- a/drivers/gpu/ion/omap/omap_ion.c
+++ b/drivers/gpu/ion/omap/omap_ion.c
@@ -107,9 +107,6 @@ int omap_ion_probe(struct platform_device *pdev)
 				nonsecure_tiler_heap = heaps[i];
 			else
 				tiler_heap = heaps[i];
-		} else if (heap_data->type ==
-				OMAP_ION_HEAP_TYPE_TILER_RESERVATION) {
-			heaps[i] = omap_tiler_heap_create(heap_data);
 		} else {
 			heaps[i] = ion_heap_create(heap_data);
 		}
diff --git a/drivers/gpu/ion/omap/omap_tiler_heap.c b/drivers/gpu/ion/omap/omap_tiler_heap.c
index 5abd9d5..47c1e64 100644
--- a/drivers/gpu/ion/omap/omap_tiler_heap.c
+++ b/drivers/gpu/ion/omap/omap_tiler_heap.c
@@ -33,25 +33,6 @@
 
 #define TILER_ENABLE_NON_PAGE_ALIGNED_ALLOCATIONS  1
 
-struct omap_ion_heap {
-	struct ion_heap heap;
-	struct gen_pool *pool;
-	ion_phys_addr_t base;
-};
-
-struct omap_tiler_info {
-	tiler_blk_handle tiler_handle;  /* handle of the allocation intiler */
-	bool lump;                      /* true for a single lump allocation */
-	u32 n_phys_pages;               /* number of physical pages */
-	u32 *phys_addrs;                /* array addrs of pages */
-	u32 n_tiler_pages;              /* number of tiler pages */
-	u32 *tiler_addrs;               /* array of addrs of tiler pages */
-	int fmt;                        /* tiler buffer format */
-	u32 tiler_start;                /* start addr in tiler -- if not page
-					   aligned this may not equal the
-					   first entry onf tiler_addrs */
-};
-
 static int omap_tiler_heap_allocate(struct ion_heap *heap,
 				    struct ion_buffer *buffer,
 				    unsigned long size, unsigned long align,
@@ -66,57 +47,18 @@ static int omap_tiler_heap_allocate(struct ion_heap *heap,
 	return -EINVAL;
 }
 
-static int omap_tiler_alloc_carveout(struct ion_heap *heap,
-				     struct omap_tiler_info *info)
-{
-	struct omap_ion_heap *omap_heap = (struct omap_ion_heap *)heap;
-	int i;
-	int ret;
-	ion_phys_addr_t addr;
-
-	addr = gen_pool_alloc(omap_heap->pool, info->n_phys_pages * PAGE_SIZE);
-	if (addr) {
-		info->lump = true;
-		for (i = 0; i < info->n_phys_pages; i++)
-			info->phys_addrs[i] = addr + i * PAGE_SIZE;
-		return 0;
-	}
-
-	for (i = 0; i < info->n_phys_pages; i++) {
-		addr = gen_pool_alloc(omap_heap->pool, PAGE_SIZE);
-
-		if (addr == 0) {
-			ret = -ENOMEM;
-			pr_err("%s: failed to allocate pages to back "
-			       "tiler address space\n", __func__);
-			goto err;
-		}
-		info->phys_addrs[i] = addr;
-	}
-	return 0;
-
-err:
-	for (i -= 1; i >= 0; i--)
-		gen_pool_free(omap_heap->pool, info->phys_addrs[i], PAGE_SIZE);
-	return ret;
-}
-
-static void omap_tiler_free_carveout(struct ion_heap *heap,
-				     struct omap_tiler_info *info)
-{
-	struct omap_ion_heap *omap_heap = (struct omap_ion_heap *)heap;
-	int i;
-
-	if (info->lump) {
-		gen_pool_free(omap_heap->pool,
-				info->phys_addrs[0],
-				info->n_phys_pages * PAGE_SIZE);
-		return;
-	}
-
-	for (i = 0; i < info->n_phys_pages; i++)
-		gen_pool_free(omap_heap->pool, info->phys_addrs[i], PAGE_SIZE);
-}
+struct omap_tiler_info {
+	tiler_blk_handle tiler_handle;	/* handle of the allocation intiler */
+	bool lump;			/* true for a single lump allocation */
+	u32 n_phys_pages;		/* number of physical pages */
+	u32 *phys_addrs;		/* array addrs of pages */
+	u32 n_tiler_pages;		/* number of tiler pages */
+	u32 *tiler_addrs;		/* array of addrs of tiler pages */
+	int fmt;			/* tiler buffer format */
+	u32 tiler_start;		/* start addr in tiler -- if not page
+					   aligned this may not equal the
+					   first entry onf tiler_addrs */
+};
 
 int omap_tiler_alloc(struct ion_heap *heap,
 		     struct ion_client *client,
@@ -130,7 +72,8 @@ int omap_tiler_alloc(struct ion_heap *heap,
 	u32 tiler_start = 0;
 	u32 v_size;
 	tiler_blk_handle tiler_handle;
-	int ret;
+	ion_phys_addr_t addr = 0;
+	int i = 0, ret;
 
 	if (data->fmt == TILER_PIXEL_FMT_PAGE && data->h != 1) {
 		pr_err("%s: Page mode (1D) allocations must have a height "
@@ -192,20 +135,32 @@ int omap_tiler_alloc(struct ion_heap *heap,
 	info->tiler_addrs = info->phys_addrs + n_phys_pages;
 	info->fmt = data->fmt;
 
-	if ((heap->id == OMAP_ION_HEAP_TILER) ||
-	    (heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		ret = omap_tiler_alloc_carveout(heap, info);
-		if (ret)
-			goto err_alloc;
-
-		ret = tiler_pin_block(info->tiler_handle, info->phys_addrs,
-				      info->n_phys_pages);
-		if (ret) {
-			pr_err("%s: failure to pin pages to tiler\n",
-				__func__);
-			goto err_pin;
+	addr = ion_carveout_allocate(heap, n_phys_pages*PAGE_SIZE, 0);
+	if (addr == ION_CARVEOUT_ALLOCATE_FAIL) {
+		for (i = 0; i < n_phys_pages; i++) {
+			addr = ion_carveout_allocate(heap, PAGE_SIZE, 0);
+
+			if (addr == ION_CARVEOUT_ALLOCATE_FAIL) {
+				ret = -ENOMEM;
+				pr_err("%s: failed to allocate pages to back "
+					"tiler address space\n", __func__);
+				goto err_alloc;
+			}
+			info->phys_addrs[i] = addr;
 		}
+	} else {
+		info->lump = true;
+		for (i = 0; i < n_phys_pages; i++)
+			info->phys_addrs[i] = addr + i*PAGE_SIZE;
+	}
+
+	ret = tiler_pin_block(info->tiler_handle, info->phys_addrs,
+			      info->n_phys_pages);
+	if (ret) {
+		pr_err("%s: failure to pin pages to tiler\n", __func__);
+		goto err_alloc;
 	}
+
 	data->stride = tiler_block_vstride(info->tiler_handle);
 
 	/* create an ion handle  for the allocation */
@@ -234,13 +189,16 @@ int omap_tiler_alloc(struct ion_heap *heap,
 
 err:
 	tiler_unpin_block(info->tiler_handle);
-err_pin:
-	if ((heap->id == OMAP_ION_HEAP_TILER) ||
-	    (heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		omap_tiler_free_carveout(heap, info);
-	}
 err_alloc:
-	tiler_free_block_area(tiler_handle);
+	tiler_free_block_area(info->tiler_handle);
+	if(info)
+	{
+		if (info->lump)
+			ion_carveout_free(heap, addr, n_phys_pages * PAGE_SIZE);
+		else
+			for (i -= 1; i >= 0; i--)
+				ion_carveout_free(heap, info->phys_addrs[i], PAGE_SIZE);
+	}
 err_nomem:
 	kfree(info);
 	return ret;
@@ -253,9 +211,14 @@ void omap_tiler_heap_free(struct ion_buffer *buffer)
 	tiler_unpin_block(info->tiler_handle);
 	tiler_free_block_area(info->tiler_handle);
 
-	if ((buffer->heap->id == OMAP_ION_HEAP_TILER) ||
-	    (buffer->heap->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		omap_tiler_free_carveout(buffer->heap, info);
+	if (info->lump) {
+		ion_carveout_free(buffer->heap, info->phys_addrs[0],
+				  info->n_phys_pages*PAGE_SIZE);
+	} else {
+		int i;
+		for (i = 0; i < info->n_phys_pages; i++)
+			ion_carveout_free(buffer->heap,
+					  info->phys_addrs[i], PAGE_SIZE);
 	}
 
 	kfree(info);
@@ -411,33 +374,19 @@ static struct ion_heap_ops omap_tiler_ops = {
 
 struct ion_heap *omap_tiler_heap_create(struct ion_platform_heap *data)
 {
-	struct omap_ion_heap *heap;
+	struct ion_heap *heap;
 
-	heap = kzalloc(sizeof(struct omap_ion_heap), GFP_KERNEL);
+	heap = ion_carveout_heap_create(data);
 	if (!heap)
 		return ERR_PTR(-ENOMEM);
-
-	if ((data->id == OMAP_ION_HEAP_TILER) ||
-	    (data->id == OMAP_ION_HEAP_NONSECURE_TILER)) {
-		heap->pool = gen_pool_create(12, -1);
-		if (!heap->pool) {
-			kfree(heap);
-			return ERR_PTR(-ENOMEM);
-		}
-		heap->base = data->base;
-		gen_pool_add(heap->pool, heap->base, data->size, -1);
-	}
-	heap->heap.ops = &omap_tiler_ops;
-	heap->heap.type = OMAP_ION_HEAP_TYPE_TILER;
-	heap->heap.name = data->name;
-	heap->heap.id = data->id;
-	return &heap->heap;
+	heap->ops = &omap_tiler_ops;
+	heap->type = OMAP_ION_HEAP_TYPE_TILER;
+	heap->name = data->name;
+	heap->id = data->id;
+	return heap;
 }
 
 void omap_tiler_heap_destroy(struct ion_heap *heap)
 {
-	struct omap_ion_heap *omap_ion_heap = (struct omap_ion_heap *)heap;
-	if (omap_ion_heap->pool)
-		gen_pool_destroy(omap_ion_heap->pool);
 	kfree(heap);
 }
diff --git a/include/linux/omap_ion.h b/include/linux/omap_ion.h
index a13a6e7..ee62820 100644
--- a/include/linux/omap_ion.h
+++ b/include/linux/omap_ion.h
@@ -68,7 +68,6 @@ bool omap_ion_rpmsg_free_memory(void);
 /* additional heaps used only on omap */
 enum {
 	OMAP_ION_HEAP_TYPE_TILER = ION_HEAP_TYPE_CUSTOM + 1,
-	OMAP_ION_HEAP_TYPE_TILER_RESERVATION,
 };
 
 #define OMAP_ION_HEAP_TILER_MASK (1 << OMAP_ION_HEAP_TYPE_TILER)
@@ -97,7 +96,6 @@ enum {
 	OMAP_ION_HEAP_TILER,
 	OMAP_ION_HEAP_SECURE_INPUT,
 	OMAP_ION_HEAP_NONSECURE_TILER,
-	OMAP_ION_HEAP_TILER_RESERVATION,
 };
 
 #endif /* _LINUX_ION_H */
-- 
2.7.4

