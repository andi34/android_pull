From 6d2ed7af6d472c8dd7a850fa229895573bbb8e4d Mon Sep 17 00:00:00 2001
From: Ketut Putu Kumajaya <ketut.kumajaya@gmail.com>
Date: Tue, 25 Mar 2014 22:27:42 +0700
Subject: [PATCH] Always enable reboot applet

Change-Id: I14311a4fbcf559a075fa46c2b6d2c1848b31c362
---
 Android.mk                                 |   2 +-
 android/android_reboot.c                   | 152 +++++++++++++++++++++++++++++
 android/libc/arch-arm/syscalls/__reboot.S  |  15 +++
 android/libc/arch-mips/syscalls/__reboot.S |  22 +++++
 android/libc/arch-x86/syscalls/__reboot.S  |  30 ++++++
 init/halt.c                                |  13 +--
 6 files changed, 227 insertions(+), 7 deletions(-)
 create mode 100644 android/android_reboot.c
 create mode 100644 android/libc/arch-arm/syscalls/__reboot.S
 create mode 100644 android/libc/arch-mips/syscalls/__reboot.S
 create mode 100644 android/libc/arch-x86/syscalls/__reboot.S

diff --git a/Android.mk b/Android.mk
index 17d72ce..a82292f 100644
--- a/Android.mk
+++ b/Android.mk
@@ -91,7 +91,7 @@ BUSYBOX_SRC_FILES = \
 
 BUSYBOX_ASM_FILES =
 ifneq ($(BIONIC_L),true)
-    BUSYBOX_ASM_FILES += swapon.S swapoff.S sysinfo.S
+    BUSYBOX_ASM_FILES += swapon.S swapoff.S sysinfo.S __reboot.S
 endif
 
 ifneq ($(filter arm x86 mips,$(TARGET_ARCH)),)
diff --git a/android/android_reboot.c b/android/android_reboot.c
new file mode 100644
index 0000000..326d402
--- /dev/null
+++ b/android/android_reboot.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2011, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <unistd.h>
+#include <sys/reboot.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <cutils/android_reboot.h>
+
+/* Check to see if /proc/mounts contains any writeable filesystems
+ * backed by a block device.
+ * Return true if none found, else return false.
+ */
+static int remount_ro_done(void)
+{
+    FILE *f;
+    char mount_dev[256];
+    char mount_dir[256];
+    char mount_type[256];
+    char mount_opts[256];
+    int mount_freq;
+    int mount_passno;
+    int match;
+    int found_rw_fs = 0;
+
+    f = fopen("/proc/mounts", "r");
+    if (! f) {
+        /* If we can't read /proc/mounts, just give up */
+        return 1;
+    }
+
+    do {
+        match = fscanf(f, "%255s %255s %255s %255s %d %d\n",
+                       mount_dev, mount_dir, mount_type,
+                       mount_opts, &mount_freq, &mount_passno);
+        mount_dev[255] = 0;
+        mount_dir[255] = 0;
+        mount_type[255] = 0;
+        mount_opts[255] = 0;
+        if ((match == 6) && !strncmp(mount_dev, "/dev/block", 10) && strstr(mount_opts, "rw")) {
+            found_rw_fs = 1;
+            break;
+        }
+    } while (match != EOF);
+
+    fclose(f);
+
+    return !found_rw_fs;
+}
+
+/* Remounting filesystems read-only is difficult when there are files
+ * opened for writing or pending deletes on the filesystem.  There is
+ * no way to force the remount with the mount(2) syscall.  The magic sysrq
+ * 'u' command does an emergency remount read-only on all writable filesystems
+ * that have a block device (i.e. not tmpfs filesystems) by calling
+ * emergency_remount(), which knows how to force the remount to read-only.
+ * Unfortunately, that is asynchronous, and just schedules the work and
+ * returns.  The best way to determine if it is done is to read /proc/mounts
+ * repeatedly until there are no more writable filesystems mounted on
+ * block devices.
+ */
+static void remount_ro(void)
+{
+    int fd, cnt = 0;
+
+    /* Trigger the remount of the filesystems as read-only,
+     * which also marks them clean.
+     */
+    fd = open("/proc/sysrq-trigger", O_WRONLY);
+    if (fd < 0) {
+        return;
+    }
+    write(fd, "u", 1);
+    close(fd);
+
+
+    /* Now poll /proc/mounts till it's done */
+    while (!remount_ro_done() && (cnt < 3600)) {
+        usleep(100000);
+        cnt++;
+    }
+
+    return;
+}
+
+
+int android_reboot(int cmd, int flags, char *arg)
+{
+    int ret = 0;
+    int reason = -1;
+
+#ifdef RECOVERY_PRE_COMMAND
+    if (cmd == (int) ANDROID_RB_RESTART2) {
+        if (arg && strlen(arg) > 0) {
+            char cmd[PATH_MAX];
+            sprintf(cmd, RECOVERY_PRE_COMMAND " %s", arg);
+            system(cmd);
+        }
+    }
+#endif
+
+    sync();
+    remount_ro();
+
+    switch (cmd) {
+        case ANDROID_RB_RESTART:
+            reason = RB_AUTOBOOT;
+            break;
+
+        case ANDROID_RB_POWEROFF:
+            ret = reboot(RB_POWER_OFF);
+            return ret;
+
+        case ANDROID_RB_RESTART2:
+            // REBOOT_MAGIC
+            break;
+
+        default:
+            return -1;
+    }
+
+#ifdef RECOVERY_PRE_COMMAND_CLEAR_REASON
+    reason = RB_AUTOBOOT;
+#endif
+
+    if (reason != -1)
+        ret = reboot(reason);
+    else
+        ret = __reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2,
+                           LINUX_REBOOT_CMD_RESTART2, arg);
+
+    return ret;
+}
+
diff --git a/android/libc/arch-arm/syscalls/__reboot.S b/android/libc/arch-arm/syscalls/__reboot.S
new file mode 100644
index 0000000..ad2bc8d
--- /dev/null
+++ b/android/libc/arch-arm/syscalls/__reboot.S
@@ -0,0 +1,15 @@
+/* autogenerated by gensyscalls.py */
+#include <asm/unistd.h>
+#include <linux/err.h>
+#include <machine/asm.h>
+
+ENTRY(__reboot)
+    mov     ip, r7
+    ldr     r7, =__NR_reboot
+    swi     #0
+    mov     r7, ip
+    cmn     r0, #(MAX_ERRNO + 1)
+    bxls    lr
+    neg     r0, r0
+    b       __set_errno
+END(__reboot)
diff --git a/android/libc/arch-mips/syscalls/__reboot.S b/android/libc/arch-mips/syscalls/__reboot.S
new file mode 100644
index 0000000..dcd68e4
--- /dev/null
+++ b/android/libc/arch-mips/syscalls/__reboot.S
@@ -0,0 +1,22 @@
+/* autogenerated by gensyscalls.py */
+#include <asm/unistd.h>
+    .text
+    .globl __reboot
+    .align 4
+    .ent __reboot
+
+__reboot:
+    .set noreorder
+    .cpload $t9
+    li $v0, __NR_reboot
+    syscall
+    bnez $a3, 1f
+    move $a0, $v0
+    j $ra
+    nop
+1:
+    la $t9,__set_errno
+    j $t9
+    nop
+    .set reorder
+    .end __reboot
diff --git a/android/libc/arch-x86/syscalls/__reboot.S b/android/libc/arch-x86/syscalls/__reboot.S
new file mode 100644
index 0000000..a32e8a8
--- /dev/null
+++ b/android/libc/arch-x86/syscalls/__reboot.S
@@ -0,0 +1,30 @@
+/* autogenerated by gensyscalls.py */
+#include <linux/err.h>
+#include <machine/asm.h>
+#include <asm/unistd.h>
+
+ENTRY(__reboot)
+    pushl   %ebx
+    pushl   %ecx
+    pushl   %edx
+    pushl   %esi
+    mov     20(%esp), %ebx
+    mov     24(%esp), %ecx
+    mov     28(%esp), %edx
+    mov     32(%esp), %esi
+    movl    $__NR_reboot, %eax
+    int     $0x80
+    cmpl    $-MAX_ERRNO, %eax
+    jb      1f
+    negl    %eax
+    pushl   %eax
+    call    __set_errno
+    addl    $4, %esp
+    orl     $-1, %eax
+1:
+    popl    %esi
+    popl    %edx
+    popl    %ecx
+    popl    %ebx
+    ret
+END(__reboot)
diff --git a/init/halt.c b/init/halt.c
index 7f1bebb..97535a2 100644
--- a/init/halt.c
+++ b/init/halt.c
@@ -69,9 +69,10 @@
 #include "libbb.h"
 #include "reboot.h"
 
-#ifdef __BIONIC__
+//#ifdef __BIONIC__
 # include "android/reboot.c"
-#endif
+//#endif
+#include "android/android_reboot.c"
 
 #if ENABLE_FEATURE_WTMP
 #include <sys/utsname.h>
@@ -134,7 +135,7 @@ int halt_main(int argc UNUSED_PARAM, char **argv)
 	if (!(flags & 2)) /* no -n */
 		sync();
 
-#ifdef __BIONIC__
+//#ifdef __BIONIC__
 	char *mode[4];
 	int c = 1;
 	mode[0] = strdup("reboot");
@@ -148,16 +149,16 @@ int halt_main(int argc UNUSED_PARAM, char **argv)
 		break;
 	case 2:
 		//reboot
-		#ifdef CYANOGEN_LIBREBOOT
+		//#ifdef CYANOGEN_LIBREBOOT
 		if (argc > 1) {
 			mode[1] = strdup(argv[1]);
 			c = 2;
 		}
-		#endif
+		//#endif
 		break;
 	}
 	return reboot_main(c, mode);
-#endif
+//#endif
 
 	/* Perform action. */
 	rc = 1;
