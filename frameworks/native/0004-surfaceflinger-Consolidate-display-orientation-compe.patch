From 0cdb9202c2f88c2422dc4616951a4094cab3bec1 Mon Sep 17 00:00:00 2001
From: Ricardo Cerqueira <cyanogenmod@cerqueira.org>
Date: Sat, 4 Jan 2014 04:44:47 +0000
Subject: [PATCH 4/4] surfaceflinger: Consolidate display orientation
 compensation hooks

Dedupe rotation calculation code and make rotation a statically
available property in the DisplayDevice

Conflicts:
	services/surfaceflinger/DisplayDevice.cpp
	services/surfaceflinger/SurfaceFlinger.cpp

Change-Id: Ic517ab0d2c05026cd6fa46d664aab7926be17b62
---
 services/surfaceflinger/DisplayDevice.cpp  | 20 ++++++++++++--------
 services/surfaceflinger/DisplayDevice.h    |  4 +++-
 services/surfaceflinger/SurfaceFlinger.cpp |  4 +---
 3 files changed, 16 insertions(+), 12 deletions(-)

diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index 73bc950..5285519 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -72,6 +72,7 @@ DisplayDevice::DisplayDevice(
       mIsSecure(isSecure),
       mSecureLayerVisible(false),
       mLayerStack(NO_LAYER_STACK),
+      mHardwareOrientation(0),
       mOrientation(),
       mPowerMode(HWC_POWER_MODE_OFF),
       mActiveConfig(0)
@@ -119,7 +120,12 @@ DisplayDevice::DisplayDevice(
     // was created with createDisplay().
     switch (mType) {
         case DISPLAY_PRIMARY:
+            char value[PROPERTY_VALUE_MAX];
             mDisplayName = "Built-in Screen";
+
+            /* hwrotation applies only to the primary display */
+            property_get("ro.sf.hwrotation", value, "0");
+            mHardwareOrientation = atoi(value);
             break;
         case DISPLAY_EXTERNAL:
             mDisplayName = "HDMI Screen";
@@ -380,9 +386,7 @@ status_t DisplayDevice::orientationToTransfrom(
         int orientation, int w, int h, Transform* tr)
 {
     uint32_t flags = 0;
-    char value[PROPERTY_VALUE_MAX];
-    property_get("ro.sf.hwrotation", value, "0");
-    int additionalRot = atoi(value);
+    int additionalRot = this->getHardwareOrientation();
 
     if (additionalRot) {
         additionalRot /= 90;
@@ -450,11 +454,7 @@ void DisplayDevice::setProjection(int orientation,
     if (!frame.isValid()) {
         // the destination frame can be invalid if it has never been set,
         // in that case we assume the whole display frame.
-        char value[PROPERTY_VALUE_MAX];
-        property_get("ro.sf.hwrotation", value, "0");
-        int additionalRot = atoi(value);
-
-        if (additionalRot == 90 || additionalRot == 270) {
+        if ((mHardwareOrientation/90) & DisplayState::eOrientationSwapMask) {
             frame = Rect(h, w);
         } else {
             frame = Rect(w, h);
@@ -513,6 +513,10 @@ void DisplayDevice::setProjection(int orientation,
     mFrame = frame;
 }
 
+int DisplayDevice::getHardwareOrientation() {
+    return mHardwareOrientation;
+}
+
 void DisplayDevice::dump(String8& result) const {
     const Transform& tr(mGlobalTransform);
     result.appendFormat(
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 8695a44..fec5991 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -169,6 +169,7 @@ public:
      */
     uint32_t getPageFlipCount() const;
     void dump(String8& result) const;
+    int getHardwareOrientation();
 
 private:
     /*
@@ -209,10 +210,11 @@ private:
     /*
      * Transaction state
      */
-    static status_t orientationToTransfrom(int orientation,
+    status_t orientationToTransfrom(int orientation,
             int w, int h, Transform* tr);
 
     uint32_t mLayerStack;
+    int mHardwareOrientation;
     int mOrientation;
     // user-provided visible area of the layer stack
     Rect mViewport;
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 5668797..2384d73 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -576,9 +576,7 @@ status_t SurfaceFlinger::getDisplayConfigs(const sp<IBinder>& display,
             info.orientation = 0;
         }
 
-        char value[PROPERTY_VALUE_MAX];
-        property_get("ro.sf.hwrotation", value, "0");
-        int additionalRot = atoi(value) / 90;
+        int additionalRot = mDisplays[0]->getHardwareOrientation() / 90;
         if ((type == DisplayDevice::DISPLAY_PRIMARY) && (additionalRot & DisplayState::eOrientationSwapMask)) {
             info.h = hwConfig.width;
             info.w = hwConfig.height;
-- 
2.7.4

