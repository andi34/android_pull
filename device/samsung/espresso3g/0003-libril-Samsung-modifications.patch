From b731e5b12be344e78ca3b2946f418cb0f6b856f1 Mon Sep 17 00:00:00 2001
From: Andreas Blaesius <skate4life@gmx.de>
Date: Sun, 12 Nov 2017 21:23:35 +0100
Subject: [PATCH 3/3] libril: Samsung modifications

- Based on LineageOS libril for Samsung from android_hardware_samsung
  (head c98cc605c67e950bf14aa9f0d14966382ec45a0c).
- Removed unneeded ifdefs and stuff we already handle in our ril shim

Change-Id: I166c479b5e143ac45ac49ad42ee83aae8d3edeb6
---
 rilsrc/include/telephony/ril.h                     | 84 +++++++++++++++++++++
 rilsrc/libril/Android.mk                           |  4 +-
 .../libril/include/telephony/ril_commands_vendor.h | 69 +++++++++++++++++
 .../include/telephony/ril_unsol_commands_vendor.h  | 55 ++++++++++++++
 rilsrc/libril/ril.cpp                              | 86 ++++++++++++++++++++--
 5 files changed, 289 insertions(+), 9 deletions(-)
 create mode 100644 rilsrc/libril/include/telephony/ril_commands_vendor.h
 create mode 100644 rilsrc/libril/include/telephony/ril_unsol_commands_vendor.h

diff --git a/rilsrc/include/telephony/ril.h b/rilsrc/include/telephony/ril.h
index 5fcd901..536c15e 100644
--- a/rilsrc/include/telephony/ril.h
+++ b/rilsrc/include/telephony/ril.h
@@ -5027,6 +5027,56 @@ typedef struct {
  */
 #define RIL_REQUEST_SHUTDOWN 129
 
+/* SAMSUNG REQUESTS */
+#define RIL_REQUEST_GET_CELL_BROADCAST_CONFIG 10002
+
+#define RIL_REQUEST_SEND_ENCODED_USSD 10005
+#define RIL_REQUEST_SET_PDA_MEMORY_STATUS 10006
+#define RIL_REQUEST_GET_PHONEBOOK_STORAGE_INFO 10007
+#define RIL_REQUEST_GET_PHONEBOOK_ENTRY 10008
+#define RIL_REQUEST_ACCESS_PHONEBOOK_ENTRY 10009
+#define RIL_REQUEST_DIAL_VIDEO_CALL 10010
+#define RIL_REQUEST_CALL_DEFLECTION 10011
+#define RIL_REQUEST_READ_SMS_FROM_SIM 10012
+#define RIL_REQUEST_USIM_PB_CAPA 10013
+#define RIL_REQUEST_LOCK_INFO 10014
+
+#define RIL_REQUEST_DIAL_EMERGENCY 10016
+#define RIL_REQUEST_GET_STOREAD_MSG_COUNT 10017
+#define RIL_REQUEST_STK_SIM_INIT_EVENT 10018
+#define RIL_REQUEST_GET_LINE_ID 10019
+#define RIL_REQUEST_SET_LINE_ID 10020
+#define RIL_REQUEST_GET_SERIAL_NUMBER 10021
+#define RIL_REQUEST_GET_MANUFACTURE_DATE_NUMBER 10022
+#define RIL_REQUEST_GET_BARCODE_NUMBER 10023
+#define RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP 10024
+#define RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF 10025
+#define RIL_REQUEST_SIM_TRANSMIT_BASIC 10026
+#define RIL_REQUEST_SIM_TRANSMIT_CHANNEL 10029
+#define RIL_REQUEST_SIM_AUTH 10030
+#define RIL_REQUEST_PS_ATTACH 10031
+#define RIL_REQUEST_PS_DETACH 10032
+#define RIL_REQUEST_ACTIVATE_DATA_CALL 10033
+#define RIL_REQUEST_CHANGE_SIM_PERSO 10034
+#define RIL_REQUEST_ENTER_SIM_PERSO 10035
+#define RIL_REQUEST_GET_TIME_INFO 10036
+#define RIL_REQUEST_OMADM_SETUP_SESSION 10037
+#define RIL_REQUEST_OMADM_SERVER_START_SESSION 10038
+#define RIL_REQUEST_OMADM_CLIENT_START_SESSION 10039
+#define RIL_REQUEST_OMADM_SEND_DATA 10040
+#define RIL_REQUEST_CDMA_GET_DATAPROFILE 10041
+#define RIL_REQUEST_CDMA_SET_DATAPROFILE 10042
+#define RIL_REQUEST_CDMA_GET_SYSTEMPROPERTIES 10043
+#define RIL_REQUEST_CDMA_SET_SYSTEMPROPERTIES 10044
+#define RIL_REQUEST_SEND_SMS_COUNT 10045
+#define RIL_REQUEST_SEND_SMS_MSG 10046
+#define RIL_REQUEST_SEND_SMS_MSG_READ_STATUS 10047
+#define RIL_REQUEST_MODEM_HANGUP 10048
+#define RIL_REQUEST_SET_SIM_POWER 10049
+#define RIL_REQUEST_SET_PREFERRED_NETWORK_LIST 10050
+#define RIL_REQUEST_GET_PREFERRED_NETWORK_LIST 10051
+#define RIL_REQUEST_HANGUP_VT 10052
+
 /**
  * RIL_REQUEST_GET_RADIO_CAPABILITY
  *
@@ -5863,6 +5913,40 @@ typedef RIL_RadioState (*RIL_RadioStateRequest)();
 
 #endif
 
+/* SAMSUNG RESPONSE */
+#define SAMSUNG_UNSOL_RESPONSE_BASE 11000
+
+#define RIL_UNSOL_RELEASE_COMPLETE_MESSAGE 11001
+#define RIL_UNSOL_STK_SEND_SMS_RESULT 11002
+#define RIL_UNSOL_STK_CALL_CONTROL_RESULT 11003
+#define RIL_UNSOL_DUN_CALL_STATUS 11004
+
+#define RIL_UNSOL_O2_HOME_ZONE_INFO 11007
+#define RIL_UNSOL_DEVICE_READY_NOTI 11008
+#define RIL_UNSOL_GPS_NOTI 11009
+#define RIL_UNSOL_AM 11010
+#define RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL 11011
+#define RIL_UNSOL_DATA_SUSPEND_RESUME 11012
+#define RIL_UNSOL_SAP 11013
+
+#define RIL_UNSOL_SIM_SMS_STORAGE_AVAILALE 11015
+#define RIL_UNSOL_HSDPA_STATE_CHANGED 11016
+#define RIL_UNSOL_WB_AMR_STATE 11017
+#define RIL_UNSOL_TWO_MIC_STATE 11018
+#define RIL_UNSOL_DHA_STATE 11019
+#define RIL_UNSOL_UART 11020
+#define RIL_UNSOL_RESPONSE_HANDOVER 11021
+#define RIL_UNSOL_IPV6_ADDR 11022
+#define RIL_UNSOL_NWK_INIT_DISC_REQUEST 11023
+#define RIL_UNSOL_RTS_INDICATION 11024
+#define RIL_UNSOL_OMADM_SEND_DATA 11025
+#define RIL_UNSOL_DUN 11026
+#define RIL_UNSOL_SYSTEM_REBOOT 11027
+#define RIL_UNSOL_VOICE_PRIVACY_CHANGED 11028
+#define RIL_UNSOL_UTS_GETSMSCOUNT 11029
+#define RIL_UNSOL_UTS_GETSMSMSG 11030
+#define RIL_UNSOL_UTS_GET_UNREAD_SMS_STATUS 11031
+#define RIL_UNSOL_MIP_CONNECT_STATUS 11032
 
 /**
  * This function returns "1" if the specified RIL_REQUEST code is
diff --git a/rilsrc/libril/Android.mk b/rilsrc/libril/Android.mk
index 5fe80dc..92efcfd 100644
--- a/rilsrc/libril/Android.mk
+++ b/rilsrc/libril/Android.mk
@@ -21,12 +21,14 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_STATIC_LIBRARIES := \
     libprotobuf-c-nano-enable_malloc \
 
-#LOCAL_CFLAGS := -DANDROID_MULTI_SIM -DDSDA_RILD1
+LOCAL_CFLAGS :=
 
 ifeq ($(SIM_COUNT), 2)
+    LOCAL_CFLAGS += -DANDROID_MULTI_SIM
     LOCAL_CFLAGS += -DANDROID_SIM_COUNT_2
 endif
 
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/include
 LOCAL_C_INCLUDES += external/nanopb-c
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
 LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/../include
diff --git a/rilsrc/libril/include/telephony/ril_commands_vendor.h b/rilsrc/libril/include/telephony/ril_commands_vendor.h
new file mode 100644
index 0000000..9121407
--- /dev/null
+++ b/rilsrc/libril/include/telephony/ril_commands_vendor.h
@@ -0,0 +1,69 @@
+/* //device/libs/telephony/ril_commands.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+    {10000, NULL, NULL},
+    {10001, NULL, NULL},
+    {RIL_REQUEST_GET_CELL_BROADCAST_CONFIG, dispatchVoid, responseVoid},
+    {10003, NULL, NULL},
+    {10004, NULL, NULL},
+    {RIL_REQUEST_SEND_ENCODED_USSD, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_PDA_MEMORY_STATUS, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_PHONEBOOK_STORAGE_INFO, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_PHONEBOOK_ENTRY, dispatchVoid, responseVoid},
+    {RIL_REQUEST_ACCESS_PHONEBOOK_ENTRY, dispatchVoid, responseVoid},
+    {RIL_REQUEST_DIAL_VIDEO_CALL, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CALL_DEFLECTION, dispatchVoid, responseVoid},
+    {RIL_REQUEST_READ_SMS_FROM_SIM, dispatchVoid, responseVoid},
+    {RIL_REQUEST_USIM_PB_CAPA, dispatchVoid, responseVoid},
+    {RIL_REQUEST_LOCK_INFO, dispatchVoid, responseVoid},
+    {10015, NULL, NULL},
+    {RIL_REQUEST_DIAL_EMERGENCY, dispatchDial, responseVoid},
+    {RIL_REQUEST_GET_STOREAD_MSG_COUNT, dispatchVoid, responseVoid},
+    {RIL_REQUEST_STK_SIM_INIT_EVENT, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_LINE_ID, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_LINE_ID, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_SERIAL_NUMBER, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_MANUFACTURE_DATE_NUMBER, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_BARCODE_NUMBER, dispatchVoid, responseVoid},
+    {RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP, dispatchVoid, responseVoid},
+    {RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SIM_TRANSMIT_BASIC, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SIM_OPEN_CHANNEL, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SIM_CLOSE_CHANNEL, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SIM_TRANSMIT_CHANNEL, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SIM_AUTH, dispatchVoid, responseVoid},
+    {RIL_REQUEST_PS_ATTACH, dispatchVoid, responseVoid},
+    {RIL_REQUEST_PS_DETACH, dispatchVoid, responseVoid},
+    {RIL_REQUEST_ACTIVATE_DATA_CALL, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CHANGE_SIM_PERSO, dispatchVoid, responseVoid},
+    {RIL_REQUEST_ENTER_SIM_PERSO, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_TIME_INFO, dispatchVoid, responseVoid},
+    {RIL_REQUEST_OMADM_SETUP_SESSION, dispatchVoid, responseVoid},
+    {RIL_REQUEST_OMADM_SERVER_START_SESSION, dispatchVoid, responseVoid},
+    {RIL_REQUEST_OMADM_CLIENT_START_SESSION, dispatchVoid, responseVoid},
+    {RIL_REQUEST_OMADM_SEND_DATA, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CDMA_GET_DATAPROFILE, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CDMA_SET_DATAPROFILE, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CDMA_GET_SYSTEMPROPERTIES, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CDMA_SET_SYSTEMPROPERTIES, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SEND_SMS_COUNT, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SEND_SMS_MSG, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SEND_SMS_MSG_READ_STATUS, dispatchVoid, responseVoid},
+    {RIL_REQUEST_MODEM_HANGUP, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_SIM_POWER, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_PREFERRED_NETWORK_LIST, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_PREFERRED_NETWORK_LIST, dispatchVoid, responseVoid},
+    {RIL_REQUEST_HANGUP_VT, dispatchVoid, responseVoid},
diff --git a/rilsrc/libril/include/telephony/ril_unsol_commands_vendor.h b/rilsrc/libril/include/telephony/ril_unsol_commands_vendor.h
new file mode 100644
index 0000000..0a9b657
--- /dev/null
+++ b/rilsrc/libril/include/telephony/ril_unsol_commands_vendor.h
@@ -0,0 +1,55 @@
+/* //device/libs/telephony/ril_unsol_commands.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+    {SAMSUNG_UNSOL_RESPONSE_BASE, NULL, WAKE_PARTIAL},
+    {RIL_UNSOL_RELEASE_COMPLETE_MESSAGE, responseVoid, WAKE_PARTIAL}, // 11001
+    {RIL_UNSOL_STK_SEND_SMS_RESULT, responseInts, WAKE_PARTIAL}, // 11002
+    {RIL_UNSOL_STK_CALL_CONTROL_RESULT, responseVoid, WAKE_PARTIAL}, // 11003
+    {RIL_UNSOL_DUN_CALL_STATUS, responseVoid, WAKE_PARTIAL}, // 11004
+    {11005, NULL, WAKE_PARTIAL},
+    {11006, NULL, WAKE_PARTIAL},
+    {RIL_UNSOL_O2_HOME_ZONE_INFO, responseVoid, WAKE_PARTIAL}, // 11007
+    {RIL_UNSOL_DEVICE_READY_NOTI, responseVoid, WAKE_PARTIAL}, // 11008
+    {RIL_UNSOL_GPS_NOTI, responseVoid, WAKE_PARTIAL}, // 11009
+    {RIL_UNSOL_AM, responseString, WAKE_PARTIAL}, // 11010
+    {RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL, responseVoid, WAKE_PARTIAL}, // 11011
+    {RIL_UNSOL_DATA_SUSPEND_RESUME, responseInts, WAKE_PARTIAL}, // 11012
+    {RIL_UNSOL_SAP, responseVoid, WAKE_PARTIAL}, // 11013
+    {11014, NULL, WAKE_PARTIAL},
+    {RIL_UNSOL_SIM_SMS_STORAGE_AVAILALE, responseVoid, WAKE_PARTIAL}, // 11015
+    {RIL_UNSOL_HSDPA_STATE_CHANGED, responseVoid, WAKE_PARTIAL}, // 11016
+    {RIL_UNSOL_WB_AMR_STATE, responseInts, WAKE_PARTIAL}, // 11017
+    {RIL_UNSOL_TWO_MIC_STATE, responseInts, WAKE_PARTIAL}, // 11018
+    {RIL_UNSOL_DHA_STATE, responseVoid, WAKE_PARTIAL}, // 11019
+    {RIL_UNSOL_UART, responseVoid, WAKE_PARTIAL}, // 11020
+    {RIL_UNSOL_RESPONSE_HANDOVER, responseVoid, WAKE_PARTIAL}, // 11021
+    {RIL_UNSOL_IPV6_ADDR, responseVoid, WAKE_PARTIAL}, // 11022
+    {RIL_UNSOL_NWK_INIT_DISC_REQUEST, responseVoid, WAKE_PARTIAL}, // 11023
+    {RIL_UNSOL_RTS_INDICATION, responseVoid, WAKE_PARTIAL}, // 11024
+    {RIL_UNSOL_OMADM_SEND_DATA, responseVoid, WAKE_PARTIAL}, // 11025
+    {RIL_UNSOL_DUN, responseVoid, WAKE_PARTIAL}, // 11026
+    {RIL_UNSOL_SYSTEM_REBOOT, responseVoid, WAKE_PARTIAL}, // 11027
+    {RIL_UNSOL_VOICE_PRIVACY_CHANGED, responseVoid, WAKE_PARTIAL}, // 11028
+    {RIL_UNSOL_UTS_GETSMSCOUNT, responseVoid, WAKE_PARTIAL}, // 11029
+    {RIL_UNSOL_UTS_GETSMSMSG, responseVoid, WAKE_PARTIAL}, // 11030
+    {RIL_UNSOL_UTS_GET_UNREAD_SMS_STATUS, responseVoid, WAKE_PARTIAL}, // 11031
+    {RIL_UNSOL_MIP_CONNECT_STATUS, responseVoid, WAKE_PARTIAL}, // 11032
+#ifdef RIL_UNSOL_SNDMGR_WB_AMR_REPORT
+    {RIL_UNSOL_SNDMGR_WB_AMR_REPORT, responseInts, WAKE_PARTIAL}, // 20017
+#endif
+#ifdef RIL_UNSOL_SNDMGR_CLOCK_CTRL
+    {RIL_UNSOL_SNDMGR_CLOCK_CTRL, responseInts, WAKE_PARTIAL}, // 20022
+#endif
diff --git a/rilsrc/libril/ril.cpp b/rilsrc/libril/ril.cpp
index d7744c0..87c26be 100644
--- a/rilsrc/libril/ril.cpp
+++ b/rilsrc/libril/ril.cpp
@@ -168,6 +168,9 @@ extern "C" const char * rilSocketIdToString(RIL_SOCKET_ID socket_id);
 
 extern "C"
 char rild[MAX_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL;
+
+#define RIL_VENDOR_COMMANDS_OFFSET 10000
+
 /*******************************************************************/
 
 RIL_RadioFunctions s_callbacks = {0, NULL, NULL, NULL, NULL, NULL};
@@ -362,6 +365,14 @@ static UnsolResponseInfo s_unsolResponses[] = {
 #include "ril_unsol_commands.h"
 };
 
+static CommandInfo s_commands_v[] = {
+#include <telephony/ril_commands_vendor.h>
+};
+
+static UnsolResponseInfo s_unsolResponses_v[] = {
+#include <telephony/ril_unsol_commands_vendor.h>
+};
+
 /* For older RILs that do not support new commands RIL_REQUEST_VOICE_RADIO_TECH and
    RIL_UNSOL_VOICE_RADIO_TECH_CHANGED messages, decode the voice radio tech from
    radio state message and store it. Every time there is a change in Radio State
@@ -476,6 +487,11 @@ issueLocalRequest(int request, void *data, int len, RIL_SOCKET_ID socket_id) {
     pRI->pCI = &(s_commands[request]);
     pRI->socket_id = socket_id;
 
+    /* Hack to include Samsung requests */
+    if (request > RIL_VENDOR_COMMANDS_OFFSET) {
+        pRI->pCI = &(s_commands_v[request - RIL_VENDOR_COMMANDS_OFFSET]);
+    }
+
     ret = pthread_mutex_lock(pendingRequestsMutexHook);
     assert (ret == 0);
 
@@ -536,6 +552,18 @@ processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) {
         return 0;
     }
 
+    CommandInfo *pCI = NULL;
+    if (request > RIL_VENDOR_COMMANDS_OFFSET) {
+        int index = request - RIL_VENDOR_COMMANDS_OFFSET;
+        RLOGD("processCommandBuffer: samsung request=%d, index=%d",
+                request, index);
+        if (index < (int32_t)NUM_ELEMS(s_commands_v))
+            pCI = &(s_commands_v[index]);
+    } else {
+        if (request < (int32_t)NUM_ELEMS(s_commands))
+            pCI = &(s_commands[request]);
+    }
+
     // Received an Ack for the previous result sent to RIL.java,
     // so release wakelock and exit
     if (request == RIL_RESPONSE_ACKNOWLEDGEMENT) {
@@ -543,7 +571,7 @@ processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) {
         return 0;
     }
 
-    if (request < 1 || request >= (int32_t)NUM_ELEMS(s_commands)) {
+    if (pCI == NULL) {
         Parcel pErr;
         RLOGE("unsupported request code %d token %d", request, token);
         // FIXME this should perhaps return a response
@@ -562,7 +590,7 @@ processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) {
     }
 
     pRI->token = token;
-    pRI->pCI = &(s_commands[request]);
+    pRI->pCI = pCI;
     pRI->socket_id = socket_id;
 
     ret = pthread_mutex_lock(pendingRequestsMutexHook);
@@ -4839,11 +4867,20 @@ RIL_register (const RIL_RadioFunctions *callbacks) {
         assert(i == s_commands[i].requestNumber);
     }
 
+    for (int i = 0; i < (int)NUM_ELEMS(s_commands_v); i++) {
+        assert(i + RIL_VENDOR_COMMANDS_OFFSET == s_commands[i].requestNumber);
+    }
+
     for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses); i++) {
         assert(i + RIL_UNSOL_RESPONSE_BASE
                 == s_unsolResponses[i].requestNumber);
     }
 
+    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses_v); i++) {
+        assert(i + RIL_UNSOL_RESPONSE_BASE + RIL_VENDOR_COMMANDS_OFFSET
+                == s_unsolResponses[i].requestNumber);
+    }
+
     // New rild impl calls RIL_startEventLoop() first
     // old standalone impl wants it here.
 
@@ -5332,6 +5369,8 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     bool shouldScheduleTimeout = false;
     RIL_RadioState newState;
     RIL_SOCKET_ID soc_id = RIL_SOCKET_1;
+    UnsolResponseInfo *pRI = NULL;
+    int32_t pRI_elements;
 
 #if defined(ANDROID_MULTI_SIM)
     soc_id = socket_id;
@@ -5345,9 +5384,40 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     }
 
     unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
+    pRI = s_unsolResponses;
+    pRI_elements = (int32_t)NUM_ELEMS(s_unsolResponses);
+
+    /* Hack to include Samsung responses */
+    if (unsolResponse > RIL_VENDOR_COMMANDS_OFFSET + RIL_UNSOL_RESPONSE_BASE) {
+        pRI = s_unsolResponses_v;
+        pRI_elements = (int32_t)NUM_ELEMS(s_unsolResponses_v);
+
+        /*
+         * Some of the vendor response codes cannot be found by calculating their index anymore,
+         * because they have an even higher offset and are not ordered in the array.
+         * Example: RIL_UNSOL_SNDMGR_WB_AMR_REPORT = 20017, but it's at index 33 in the vendor
+         * response array.
+         * Thus, look through all the vendor URIs (Unsol Response Info) and pick the correct index.
+         * This has a cost of O(N).
+         */
+        int pRI_index;
+        for (pRI_index = 0; pRI_index < pRI_elements; pRI_index++) {
+            if (pRI[pRI_index].requestNumber == unsolResponse) {
+                unsolResponseIndex = pRI_index;
+            }
+        }
 
-    if ((unsolResponseIndex < 0)
-        || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
+        RLOGD("SAMSUNG: unsolResponse=%d, unsolResponseIndex=%d", unsolResponse, unsolResponseIndex);
+    }
+
+    if (unsolResponseIndex >= 0 && unsolResponseIndex < pRI_elements) {
+        pRI = &pRI[unsolResponseIndex];
+    } else {
+        RLOGE("could not map unsolResponse=%d to %s response array (index=%d)", unsolResponse,
+                pRI == s_unsolResponses ? "AOSP" : "Samsung", unsolResponseIndex);
+    }
+
+    if (pRI == NULL || pRI->responseFunction == NULL) {
         RLOGE("unsupported unsolicited response code %d", unsolResponse);
         return;
     }
@@ -5355,7 +5425,7 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
     // Grab a wake lock if needed for this reponse,
     // as we exit we'll either release it immediately
     // or set a timer to release it later.
-    switch (s_unsolResponses[unsolResponseIndex].wakeType) {
+    switch (pRI->wakeType) {
         case WAKE_PARTIAL:
             grabPartialWakeLock();
             shouldScheduleTimeout = true;
@@ -5380,15 +5450,15 @@ void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
 
     Parcel p;
     if (s_callbacks.version >= 13
-                && s_unsolResponses[unsolResponseIndex].wakeType == WAKE_PARTIAL) {
+                && pRI->wakeType == WAKE_PARTIAL) {
         p.writeInt32 (RESPONSE_UNSOLICITED_ACK_EXP);
     } else {
         p.writeInt32 (RESPONSE_UNSOLICITED);
     }
     p.writeInt32 (unsolResponse);
 
-    ret = s_unsolResponses[unsolResponseIndex]
-                .responseFunction(p, const_cast<void*>(data), datalen);
+    ret = pRI->responseFunction(p, const_cast<void*>(data), datalen);
+
     if (ret != 0) {
         // Problem with the response. Don't continue;
         goto error_exit;
-- 
2.7.4

