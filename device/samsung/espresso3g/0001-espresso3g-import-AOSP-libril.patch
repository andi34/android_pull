From 347f7a91e636ea2857026cac47439e87ee6ae504 Mon Sep 17 00:00:00 2001
From: Andreas Blaesius <skate4life@gmx.de>
Date: Sun, 12 Nov 2017 21:15:34 +0100
Subject: [PATCH 1/3] espresso3g: import AOSP libril

- only compile if BOARD_PROVIDES_LIBRIL := true is defined

Change-Id: Id0639648dc2f7fac3664195bae52bc9b4746d031
---
 rilsrc/include/libril/ril_ex.h           |   48 +
 rilsrc/include/telephony/librilutils.h   |   38 +
 rilsrc/include/telephony/record_stream.h |   43 +
 rilsrc/include/telephony/ril.h           | 6105 ++++++++++++++++++++++++++++++
 rilsrc/include/telephony/ril_cdma_sms.h  |  806 ++++
 rilsrc/include/telephony/ril_msim.h      |   48 +
 rilsrc/include/telephony/ril_nv_items.h  |   88 +
 rilsrc/libril/Android.mk                 |   62 +
 rilsrc/libril/MODULE_LICENSE_APACHE2     |    0
 rilsrc/libril/NOTICE                     |  190 +
 rilsrc/libril/RilSapSocket.cpp           |  514 +++
 rilsrc/libril/RilSapSocket.h             |  256 ++
 rilsrc/libril/RilSocket.cpp              |  177 +
 rilsrc/libril/RilSocket.h                |  272 ++
 rilsrc/libril/ril.cpp                    | 5871 ++++++++++++++++++++++++++++
 rilsrc/libril/rilSocketQueue.h           |  167 +
 rilsrc/libril/ril_commands.h             |  154 +
 rilsrc/libril/ril_event.cpp              |  384 ++
 rilsrc/libril/ril_event.h                |   52 +
 rilsrc/libril/ril_unsol_commands.h       |   63 +
 20 files changed, 15338 insertions(+)
 create mode 100644 rilsrc/include/libril/ril_ex.h
 create mode 100644 rilsrc/include/telephony/librilutils.h
 create mode 100644 rilsrc/include/telephony/record_stream.h
 create mode 100644 rilsrc/include/telephony/ril.h
 create mode 100644 rilsrc/include/telephony/ril_cdma_sms.h
 create mode 100644 rilsrc/include/telephony/ril_msim.h
 create mode 100644 rilsrc/include/telephony/ril_nv_items.h
 create mode 100644 rilsrc/libril/Android.mk
 create mode 100644 rilsrc/libril/MODULE_LICENSE_APACHE2
 create mode 100644 rilsrc/libril/NOTICE
 create mode 100644 rilsrc/libril/RilSapSocket.cpp
 create mode 100644 rilsrc/libril/RilSapSocket.h
 create mode 100644 rilsrc/libril/RilSocket.cpp
 create mode 100644 rilsrc/libril/RilSocket.h
 create mode 100644 rilsrc/libril/ril.cpp
 create mode 100644 rilsrc/libril/rilSocketQueue.h
 create mode 100644 rilsrc/libril/ril_commands.h
 create mode 100644 rilsrc/libril/ril_event.cpp
 create mode 100644 rilsrc/libril/ril_event.h
 create mode 100755 rilsrc/libril/ril_unsol_commands.h

diff --git a/rilsrc/include/libril/ril_ex.h b/rilsrc/include/libril/ril_ex.h
new file mode 100644
index 0000000..692e4df
--- /dev/null
+++ b/rilsrc/include/libril/ril_ex.h
@@ -0,0 +1,48 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef RIL_EX_H_INCLUDED
+#define RIL_EX_H_INCLUDED
+
+#include <telephony/ril.h>
+#include <telephony/record_stream.h>
+
+#define NUM_ELEMS_SOCKET(a)     (sizeof (a) / sizeof (a)[0])
+
+void rilEventAddWakeup_helper(struct ril_event *ev);
+void listenCallback_helper(int fd, short flags, void *param);
+int blockingWrite_helper(int fd, void* data, size_t len);
+
+enum SocketWakeType {DONT_WAKE, WAKE_PARTIAL};
+
+typedef enum {
+    RIL_TELEPHONY_SOCKET,
+    RIL_SAP_SOCKET
+} RIL_SOCKET_TYPE;
+
+typedef struct SocketListenParam {
+    RIL_SOCKET_ID socket_id;
+    int fdListen;
+    int fdCommand;
+    const char* processName;
+    struct ril_event* commands_event;
+    struct ril_event* listen_event;
+    void (*processCommandsCallback)(int fd, short flags, void *param);
+    RecordStream *p_rs;
+    RIL_SOCKET_TYPE type;
+} SocketListenParam;
+
+#endif
diff --git a/rilsrc/include/telephony/librilutils.h b/rilsrc/include/telephony/librilutils.h
new file mode 100644
index 0000000..d06b3e9
--- /dev/null
+++ b/rilsrc/include/telephony/librilutils.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LIBRILUTILS_H
+#define LIBRILUTILS_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Return system time in nanos.
+ *
+ * This is a monotonicly increasing clock and
+ * return the same value as System.nanoTime in java.
+ */
+uint64_t ril_nano_time();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // LIBRILUTILS_H
diff --git a/rilsrc/include/telephony/record_stream.h b/rilsrc/include/telephony/record_stream.h
new file mode 100644
index 0000000..7a89ae4
--- /dev/null
+++ b/rilsrc/include/telephony/record_stream.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * A simple utility for reading fixed records out of a stream fd
+ */
+
+#ifndef _LIBRIL_RECORD_STREAM_H
+#define _LIBRIL_RECORD_STREAM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct RecordStream RecordStream;
+
+extern RecordStream *record_stream_new(int fd, size_t maxRecordLen);
+extern void record_stream_free(RecordStream *p_rs);
+
+extern int record_stream_get_next (RecordStream *p_rs, void ** p_outRecord,
+                                    size_t *p_outRecordLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /*_LIBRIL_RECORD_STREAM_H*/
+
diff --git a/rilsrc/include/telephony/ril.h b/rilsrc/include/telephony/ril.h
new file mode 100644
index 0000000..5fcd901
--- /dev/null
+++ b/rilsrc/include/telephony/ril.h
@@ -0,0 +1,6105 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_RIL_H
+#define ANDROID_RIL_H 1
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <telephony/ril_cdma_sms.h>
+#include <telephony/ril_nv_items.h>
+#include <telephony/ril_msim.h>
+
+#ifndef FEATURE_UNIT_TEST
+#include <sys/time.h>
+#endif /* !FEATURE_UNIT_TEST */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if defined(ANDROID_SIM_COUNT_2)
+#define SIM_COUNT 2
+#elif defined(ANDROID_SIM_COUNT_3)
+#define SIM_COUNT 3
+#elif defined(ANDROID_SIM_COUNT_4)
+#define SIM_COUNT 4
+#else
+#define SIM_COUNT 1
+#endif
+
+#ifndef ANDROID_MULTI_SIM
+#define SIM_COUNT 1
+#endif
+
+/*
+ * RIL version.
+ * Value of RIL_VERSION should not be changed in future. Here onwards,
+ * when a new change is supposed to be introduced  which could involve new
+ * schemes added like Wakelocks, data structures added/updated, etc, we would
+ * just document RIL version associated with that change below. When OEM updates its
+ * RIL with those changes, they would return that new RIL version during RIL_REGISTER.
+ * We should make use of the returned version by vendor to identify appropriate scheme
+ * or data structure version to use.
+ *
+ * Documentation of RIL version and associated changes
+ * RIL_VERSION = 12 : This version corresponds to updated data structures namely
+ *                    RIL_Data_Call_Response_v11, RIL_SIM_IO_v6, RIL_CardStatus_v6,
+ *                    RIL_SimRefreshResponse_v7, RIL_CDMA_CallWaiting_v6,
+ *                    RIL_LTE_SignalStrength_v8, RIL_SignalStrength_v10, RIL_CellIdentityGsm_v12
+ *                    RIL_CellIdentityWcdma_v12, RIL_CellIdentityLte_v12,RIL_CellInfoGsm_v12,
+ *                    RIL_CellInfoWcdma_v12, RIL_CellInfoLte_v12, RIL_CellInfo_v12.
+ *
+ * RIL_VERSION = 13 : This version includes new wakelock semantics and as the first
+ *                    strongly versioned version it enforces structure use.
+ * RIL_VERSION = 14 : New data structures are added, namely RIL_CarrierMatchType,
+ *                    RIL_Carrier, RIL_CarrierRestrictions and RIL_PCO_Data.
+ *                    New commands added: RIL_REQUEST_SET_CARRIER_RESTRICTIONS,
+ *                    RIL_REQUEST_SET_CARRIER_RESTRICTIONS and
+ *                    RIL_UNSOL_PCO_DATA
+ */
+#define RIL_VERSION 12
+#define LAST_IMPRECISE_RIL_VERSION 12 // Better self-documented name
+#define RIL_VERSION_MIN 6 /* Minimum RIL_VERSION supported */
+
+#define CDMA_ALPHA_INFO_BUFFER_LENGTH 64
+#define CDMA_NUMBER_INFO_BUFFER_LENGTH 81
+
+#define MAX_RILDS 3
+#define MAX_SOCKET_NAME_LENGTH 6
+#define MAX_CLIENT_ID_LENGTH 2
+#define MAX_DEBUG_SOCKET_NAME_LENGTH 12
+#define MAX_QEMU_PIPE_NAME_LENGTH  11
+#define MAX_UUID_LENGTH 64
+
+
+typedef void * RIL_Token;
+
+typedef enum {
+    RIL_SOCKET_1,
+#if (SIM_COUNT >= 2)
+    RIL_SOCKET_2,
+#if (SIM_COUNT >= 3)
+    RIL_SOCKET_3,
+#endif
+#if (SIM_COUNT >= 4)
+    RIL_SOCKET_4,
+#endif
+#endif
+    RIL_SOCKET_NUM
+} RIL_SOCKET_ID;
+
+
+typedef enum {
+    RIL_E_SUCCESS = 0,
+    RIL_E_RADIO_NOT_AVAILABLE = 1,     /* If radio did not start or is resetting */
+    RIL_E_GENERIC_FAILURE = 2,
+    RIL_E_PASSWORD_INCORRECT = 3,      /* for PIN/PIN2 methods only! */
+    RIL_E_SIM_PIN2 = 4,                /* Operation requires SIM PIN2 to be entered */
+    RIL_E_SIM_PUK2 = 5,                /* Operation requires SIM PIN2 to be entered */
+    RIL_E_REQUEST_NOT_SUPPORTED = 6,
+    RIL_E_CANCELLED = 7,
+    RIL_E_OP_NOT_ALLOWED_DURING_VOICE_CALL = 8, /* data ops are not allowed during voice
+                                                   call on a Class C GPRS device */
+    RIL_E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW = 9,  /* data ops are not allowed before device
+                                                   registers in network */
+    RIL_E_SMS_SEND_FAIL_RETRY = 10,             /* fail to send sms and need retry */
+    RIL_E_SIM_ABSENT = 11,                      /* fail to set the location where CDMA subscription
+                                                   shall be retrieved because of SIM or RUIM
+                                                   card absent */
+    RIL_E_SUBSCRIPTION_NOT_AVAILABLE = 12,      /* fail to find CDMA subscription from specified
+                                                   location */
+    RIL_E_MODE_NOT_SUPPORTED = 13,              /* HW does not support preferred network type */
+    RIL_E_FDN_CHECK_FAILURE = 14,               /* command failed because recipient is not on FDN list */
+    RIL_E_ILLEGAL_SIM_OR_ME = 15,               /* network selection failed due to
+                                                   illegal SIM or ME */
+    RIL_E_MISSING_RESOURCE = 16,                /* no logical channel available */
+    RIL_E_NO_SUCH_ELEMENT = 17,                  /* application not found on SIM */
+    RIL_E_DIAL_MODIFIED_TO_USSD = 18,           /* DIAL request modified to USSD */
+    RIL_E_DIAL_MODIFIED_TO_SS = 19,             /* DIAL request modified to SS */
+    RIL_E_DIAL_MODIFIED_TO_DIAL = 20,           /* DIAL request modified to DIAL with different
+                                                   data */
+    RIL_E_USSD_MODIFIED_TO_DIAL = 21,           /* USSD request modified to DIAL */
+    RIL_E_USSD_MODIFIED_TO_SS = 22,             /* USSD request modified to SS */
+    RIL_E_USSD_MODIFIED_TO_USSD = 23,           /* USSD request modified to different USSD
+                                                   request */
+    RIL_E_SS_MODIFIED_TO_DIAL = 24,             /* SS request modified to DIAL */
+    RIL_E_SS_MODIFIED_TO_USSD = 25,             /* SS request modified to USSD */
+    RIL_E_SUBSCRIPTION_NOT_SUPPORTED = 26,      /* Subscription not supported by RIL */
+    RIL_E_SS_MODIFIED_TO_SS = 27,               /* SS request modified to different SS request */
+    RIL_E_LCE_NOT_SUPPORTED = 36,               /* LCE service not supported(36 in RILConstants.java) */
+    RIL_E_NO_MEMORY = 37,                       /* Not sufficient memory to process the request */
+    RIL_E_INTERNAL_ERR = 38,                    /* Hit unexpected vendor internal error scenario */
+    RIL_E_SYSTEM_ERR = 39,                      /* Hit platform or system error */
+    RIL_E_MODEM_ERR = 40,                       /* Hit unexpected modem error */
+    RIL_E_INVALID_STATE = 41,                   /* Unexpected request for the current state */
+    RIL_E_NO_RESOURCES = 42,                    /* Not sufficient resource to process the request */
+    RIL_E_SIM_ERR = 43,                         /* Received error from SIM card */
+    RIL_E_INVALID_ARGUMENTS = 44,               /* Received invalid arguments in request */
+    RIL_E_INVALID_SIM_STATE = 45,               /* Can not process the request in current SIM state */
+    RIL_E_INVALID_MODEM_STATE = 46,             /* Can not process the request in current Modem state */
+    RIL_E_INVALID_CALL_ID = 47,                 /* Received invalid call id in request */
+    RIL_E_NO_SMS_TO_ACK = 48,                   /* ACK received when there is no SMS to ack */
+    RIL_E_NETWORK_ERR = 49,                     /* Received error from network */
+    RIL_E_REQUEST_RATE_LIMITED = 50,            /* Operation denied due to overly-frequent requests */
+    RIL_E_SIM_BUSY = 51,                        /* SIM is busy */
+    RIL_E_SIM_FULL = 52,                        /* The target EF is full */
+    RIL_E_NETWORK_REJECT = 53,                  /* Request is rejected by network */
+    RIL_E_OPERATION_NOT_ALLOWED = 54,           /* Not allowed the request now */
+    RIL_E_EMPTY_RECORD = 55,                    /* The request record is empty */
+    RIL_E_INVALID_SMS_FORMAT = 56,              /* Invalid sms format */
+    RIL_E_ENCODING_ERR = 57,                    /* Message not encoded properly */
+    RIL_E_INVALID_SMSC_ADDRESS = 58,            /* SMSC address specified is invalid */
+    RIL_E_NO_SUCH_ENTRY = 59,                   /* No such entry present to perform the request */
+    RIL_E_NETWORK_NOT_READY = 60,               /* Network is not ready to perform the request */
+    RIL_E_NOT_PROVISIONED = 61,                 /* Device doesnot have this value provisioned */
+    RIL_E_NO_SUBSCRIPTION = 62,                 /* Device doesnot have subscription */
+    RIL_E_NO_NETWORK_FOUND = 63,                /* Network cannot be found */
+    RIL_E_DEVICE_IN_USE = 64,                   /* Operation cannot be performed because the device
+                                                   is currently in use */
+    RIL_E_ABORTED = 65,                         /* Operation aborted */
+    // OEM specific error codes. To be used by OEM when they don't want to reveal
+    // specific error codes which would be replaced by Generic failure.
+    RIL_E_OEM_ERROR_1 = 501,
+    RIL_E_OEM_ERROR_2 = 502,
+    RIL_E_OEM_ERROR_3 = 503,
+    RIL_E_OEM_ERROR_4 = 504,
+    RIL_E_OEM_ERROR_5 = 505,
+    RIL_E_OEM_ERROR_6 = 506,
+    RIL_E_OEM_ERROR_7 = 507,
+    RIL_E_OEM_ERROR_8 = 508,
+    RIL_E_OEM_ERROR_9 = 509,
+    RIL_E_OEM_ERROR_10 = 510,
+    RIL_E_OEM_ERROR_11 = 511,
+    RIL_E_OEM_ERROR_12 = 512,
+    RIL_E_OEM_ERROR_13 = 513,
+    RIL_E_OEM_ERROR_14 = 514,
+    RIL_E_OEM_ERROR_15 = 515,
+    RIL_E_OEM_ERROR_16 = 516,
+    RIL_E_OEM_ERROR_17 = 517,
+    RIL_E_OEM_ERROR_18 = 518,
+    RIL_E_OEM_ERROR_19 = 519,
+    RIL_E_OEM_ERROR_20 = 520,
+    RIL_E_OEM_ERROR_21 = 521,
+    RIL_E_OEM_ERROR_22 = 522,
+    RIL_E_OEM_ERROR_23 = 523,
+    RIL_E_OEM_ERROR_24 = 524,
+    RIL_E_OEM_ERROR_25 = 525
+} RIL_Errno;
+
+typedef enum {
+    RIL_CALL_ACTIVE = 0,
+    RIL_CALL_HOLDING = 1,
+    RIL_CALL_DIALING = 2,    /* MO call only */
+    RIL_CALL_ALERTING = 3,   /* MO call only */
+    RIL_CALL_INCOMING = 4,   /* MT call only */
+    RIL_CALL_WAITING = 5     /* MT call only */
+} RIL_CallState;
+
+typedef enum {
+    RADIO_STATE_OFF = 0,                   /* Radio explictly powered off (eg CFUN=0) */
+    RADIO_STATE_UNAVAILABLE = 1,           /* Radio unavailable (eg, resetting or not booted) */
+    /* States 2-9 below are deprecated. Just leaving them here for backward compatibility. */
+    RADIO_STATE_SIM_NOT_READY = 2,         /* Radio is on, but the SIM interface is not ready */
+    RADIO_STATE_SIM_LOCKED_OR_ABSENT = 3,  /* SIM PIN locked, PUK required, network
+                                              personalization locked, or SIM absent */
+    RADIO_STATE_SIM_READY = 4,             /* Radio is on and SIM interface is available */
+    RADIO_STATE_RUIM_NOT_READY = 5,        /* Radio is on, but the RUIM interface is not ready */
+    RADIO_STATE_RUIM_READY = 6,            /* Radio is on and the RUIM interface is available */
+    RADIO_STATE_RUIM_LOCKED_OR_ABSENT = 7, /* RUIM PIN locked, PUK required, network
+                                              personalization locked, or RUIM absent */
+    RADIO_STATE_NV_NOT_READY = 8,          /* Radio is on, but the NV interface is not available */
+    RADIO_STATE_NV_READY = 9,              /* Radio is on and the NV interface is available */
+    RADIO_STATE_ON = 10                    /* Radio is on */
+} RIL_RadioState;
+
+typedef enum {
+    RADIO_TECH_UNKNOWN = 0,
+    RADIO_TECH_GPRS = 1,
+    RADIO_TECH_EDGE = 2,
+    RADIO_TECH_UMTS = 3,
+    RADIO_TECH_IS95A = 4,
+    RADIO_TECH_IS95B = 5,
+    RADIO_TECH_1xRTT =  6,
+    RADIO_TECH_EVDO_0 = 7,
+    RADIO_TECH_EVDO_A = 8,
+    RADIO_TECH_HSDPA = 9,
+    RADIO_TECH_HSUPA = 10,
+    RADIO_TECH_HSPA = 11,
+    RADIO_TECH_EVDO_B = 12,
+    RADIO_TECH_EHRPD = 13,
+    RADIO_TECH_LTE = 14,
+    RADIO_TECH_HSPAP = 15, // HSPA+
+    RADIO_TECH_GSM = 16, // Only supports voice
+    RADIO_TECH_TD_SCDMA = 17,
+    RADIO_TECH_IWLAN = 18,
+    RADIO_TECH_LTE_CA = 19
+} RIL_RadioTechnology;
+
+typedef enum {
+    RAF_UNKNOWN =  (1 <<  RADIO_TECH_UNKNOWN),
+    RAF_GPRS = (1 << RADIO_TECH_GPRS),
+    RAF_EDGE = (1 << RADIO_TECH_EDGE),
+    RAF_UMTS = (1 << RADIO_TECH_UMTS),
+    RAF_IS95A = (1 << RADIO_TECH_IS95A),
+    RAF_IS95B = (1 << RADIO_TECH_IS95B),
+    RAF_1xRTT = (1 << RADIO_TECH_1xRTT),
+    RAF_EVDO_0 = (1 << RADIO_TECH_EVDO_0),
+    RAF_EVDO_A = (1 << RADIO_TECH_EVDO_A),
+    RAF_HSDPA = (1 << RADIO_TECH_HSDPA),
+    RAF_HSUPA = (1 << RADIO_TECH_HSUPA),
+    RAF_HSPA = (1 << RADIO_TECH_HSPA),
+    RAF_EVDO_B = (1 << RADIO_TECH_EVDO_B),
+    RAF_EHRPD = (1 << RADIO_TECH_EHRPD),
+    RAF_LTE = (1 << RADIO_TECH_LTE),
+    RAF_HSPAP = (1 << RADIO_TECH_HSPAP),
+    RAF_GSM = (1 << RADIO_TECH_GSM),
+    RAF_TD_SCDMA = (1 << RADIO_TECH_TD_SCDMA),
+    RAF_LTE_CA = (1 << RADIO_TECH_LTE_CA)
+} RIL_RadioAccessFamily;
+
+typedef enum {
+    BAND_MODE_UNSPECIFIED = 0,      //"unspecified" (selected by baseband automatically)
+    BAND_MODE_EURO = 1,             //"EURO band" (GSM-900 / DCS-1800 / WCDMA-IMT-2000)
+    BAND_MODE_USA = 2,              //"US band" (GSM-850 / PCS-1900 / WCDMA-850 / WCDMA-PCS-1900)
+    BAND_MODE_JPN = 3,              //"JPN band" (WCDMA-800 / WCDMA-IMT-2000)
+    BAND_MODE_AUS = 4,              //"AUS band" (GSM-900 / DCS-1800 / WCDMA-850 / WCDMA-IMT-2000)
+    BAND_MODE_AUS_2 = 5,            //"AUS band 2" (GSM-900 / DCS-1800 / WCDMA-850)
+    BAND_MODE_CELL_800 = 6,         //"Cellular" (800-MHz Band)
+    BAND_MODE_PCS = 7,              //"PCS" (1900-MHz Band)
+    BAND_MODE_JTACS = 8,            //"Band Class 3" (JTACS Band)
+    BAND_MODE_KOREA_PCS = 9,        //"Band Class 4" (Korean PCS Band)
+    BAND_MODE_5_450M = 10,          //"Band Class 5" (450-MHz Band)
+    BAND_MODE_IMT2000 = 11,         //"Band Class 6" (2-GMHz IMT2000 Band)
+    BAND_MODE_7_700M_2 = 12,        //"Band Class 7" (Upper 700-MHz Band)
+    BAND_MODE_8_1800M = 13,         //"Band Class 8" (1800-MHz Band)
+    BAND_MODE_9_900M = 14,          //"Band Class 9" (900-MHz Band)
+    BAND_MODE_10_800M_2 = 15,       //"Band Class 10" (Secondary 800-MHz Band)
+    BAND_MODE_EURO_PAMR_400M = 16,  //"Band Class 11" (400-MHz European PAMR Band)
+    BAND_MODE_AWS = 17,             //"Band Class 15" (AWS Band)
+    BAND_MODE_USA_2500M = 18        //"Band Class 16" (US 2.5-GHz Band)
+} RIL_RadioBandMode;
+
+typedef enum {
+    RC_PHASE_CONFIGURED = 0,  // LM is configured is initial value and value after FINISH completes
+    RC_PHASE_START      = 1,  // START is sent before Apply and indicates that an APPLY will be
+                              // forthcoming with these same parameters
+    RC_PHASE_APPLY      = 2,  // APPLY is sent after all LM's receive START and returned
+                              // RIL_RadioCapability.status = 0, if any START's fail no
+                              // APPLY will be sent
+    RC_PHASE_UNSOL_RSP  = 3,  // UNSOL_RSP is sent with RIL_UNSOL_RADIO_CAPABILITY
+    RC_PHASE_FINISH     = 4   // FINISH is sent after all commands have completed. If an error
+                              // occurs in any previous command the RIL_RadioAccessesFamily and
+                              // logicalModemUuid fields will be the prior configuration thus
+                              // restoring the configuration to the previous value. An error
+                              // returned by this command will generally be ignored or may
+                              // cause that logical modem to be removed from service.
+} RadioCapabilityPhase;
+
+typedef enum {
+    RC_STATUS_NONE       = 0, // This parameter has no meaning with RC_PHASE_START,
+                              // RC_PHASE_APPLY
+    RC_STATUS_SUCCESS    = 1, // Tell modem the action transaction of set radio
+                              // capability was success with RC_PHASE_FINISH
+    RC_STATUS_FAIL       = 2, // Tell modem the action transaction of set radio
+                              // capability is fail with RC_PHASE_FINISH.
+} RadioCapabilityStatus;
+
+#define RIL_RADIO_CAPABILITY_VERSION 1
+typedef struct {
+    int version;            // Version of structure, RIL_RADIO_CAPABILITY_VERSION
+    int session;            // Unique session value defined by framework returned in all "responses/unsol"
+    int phase;              // CONFIGURED, START, APPLY, FINISH
+    int rat;                // RIL_RadioAccessFamily for the radio
+    char logicalModemUuid[MAX_UUID_LENGTH]; // A UUID typically "com.xxxx.lmX where X is the logical modem.
+    int status;             // Return status and an input parameter for RC_PHASE_FINISH
+} RIL_RadioCapability;
+
+// Do we want to split Data from Voice and the use
+// RIL_RadioTechnology for get/setPreferredVoice/Data ?
+typedef enum {
+    PREF_NET_TYPE_GSM_WCDMA                = 0, /* GSM/WCDMA (WCDMA preferred) */
+    PREF_NET_TYPE_GSM_ONLY                 = 1, /* GSM only */
+    PREF_NET_TYPE_WCDMA                    = 2, /* WCDMA  */
+    PREF_NET_TYPE_GSM_WCDMA_AUTO           = 3, /* GSM/WCDMA (auto mode, according to PRL) */
+    PREF_NET_TYPE_CDMA_EVDO_AUTO           = 4, /* CDMA and EvDo (auto mode, according to PRL) */
+    PREF_NET_TYPE_CDMA_ONLY                = 5, /* CDMA only */
+    PREF_NET_TYPE_EVDO_ONLY                = 6, /* EvDo only */
+    PREF_NET_TYPE_GSM_WCDMA_CDMA_EVDO_AUTO = 7, /* GSM/WCDMA, CDMA, and EvDo (auto mode, according to PRL) */
+    PREF_NET_TYPE_LTE_CDMA_EVDO            = 8, /* LTE, CDMA and EvDo */
+    PREF_NET_TYPE_LTE_GSM_WCDMA            = 9, /* LTE, GSM/WCDMA */
+    PREF_NET_TYPE_LTE_CMDA_EVDO_GSM_WCDMA  = 10, /* LTE, CDMA, EvDo, GSM/WCDMA */
+    PREF_NET_TYPE_LTE_ONLY                 = 11, /* LTE only */
+    PREF_NET_TYPE_LTE_WCDMA                = 12  /* LTE/WCDMA */
+} RIL_PreferredNetworkType;
+
+/* Source for cdma subscription */
+typedef enum {
+   CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM = 0,
+   CDMA_SUBSCRIPTION_SOURCE_NV = 1
+} RIL_CdmaSubscriptionSource;
+
+/* User-to-User signaling Info activation types derived from 3GPP 23.087 v8.0 */
+typedef enum {
+    RIL_UUS_TYPE1_IMPLICIT = 0,
+    RIL_UUS_TYPE1_REQUIRED = 1,
+    RIL_UUS_TYPE1_NOT_REQUIRED = 2,
+    RIL_UUS_TYPE2_REQUIRED = 3,
+    RIL_UUS_TYPE2_NOT_REQUIRED = 4,
+    RIL_UUS_TYPE3_REQUIRED = 5,
+    RIL_UUS_TYPE3_NOT_REQUIRED = 6
+} RIL_UUS_Type;
+
+/* User-to-User Signaling Information data coding schemes. Possible values for
+ * Octet 3 (Protocol Discriminator field) in the UUIE. The values have been
+ * specified in section 10.5.4.25 of 3GPP TS 24.008 */
+typedef enum {
+    RIL_UUS_DCS_USP = 0,          /* User specified protocol */
+    RIL_UUS_DCS_OSIHLP = 1,       /* OSI higher layer protocol */
+    RIL_UUS_DCS_X244 = 2,         /* X.244 */
+    RIL_UUS_DCS_RMCF = 3,         /* Reserved for system mangement
+                                     convergence function */
+    RIL_UUS_DCS_IA5c = 4          /* IA5 characters */
+} RIL_UUS_DCS;
+
+/* User-to-User Signaling Information defined in 3GPP 23.087 v8.0
+ * This data is passed in RIL_ExtensionRecord and rec contains this
+ * structure when type is RIL_UUS_INFO_EXT_REC */
+typedef struct {
+  RIL_UUS_Type    uusType;    /* UUS Type */
+  RIL_UUS_DCS     uusDcs;     /* UUS Data Coding Scheme */
+  int             uusLength;  /* Length of UUS Data */
+  char *          uusData;    /* UUS Data */
+} RIL_UUS_Info;
+
+/* CDMA Signal Information Record as defined in C.S0005 section 3.7.5.5 */
+typedef struct {
+  char isPresent;    /* non-zero if signal information record is present */
+  char signalType;   /* as defined 3.7.5.5-1 */
+  char alertPitch;   /* as defined 3.7.5.5-2 */
+  char signal;       /* as defined 3.7.5.5-3, 3.7.5.5-4 or 3.7.5.5-5 */
+} RIL_CDMA_SignalInfoRecord;
+
+typedef struct {
+    RIL_CallState   state;
+    int             index;      /* Connection Index for use with, eg, AT+CHLD */
+    int             toa;        /* type of address, eg 145 = intl */
+    char            isMpty;     /* nonzero if is mpty call */
+    char            isMT;       /* nonzero if call is mobile terminated */
+    char            als;        /* ALS line indicator if available
+                                   (0 = line 1) */
+    char            isVoice;    /* nonzero if this is is a voice call */
+    char            isVoicePrivacy;     /* nonzero if CDMA voice privacy mode is active */
+    char *          number;     /* Remote party number */
+    int             numberPresentation; /* 0=Allowed, 1=Restricted, 2=Not Specified/Unknown 3=Payphone */
+    char *          name;       /* Remote party name */
+    int             namePresentation; /* 0=Allowed, 1=Restricted, 2=Not Specified/Unknown 3=Payphone */
+    RIL_UUS_Info *  uusInfo;    /* NULL or Pointer to User-User Signaling Information */
+} RIL_Call;
+
+/* Deprecated, use RIL_Data_Call_Response_v6 */
+typedef struct {
+    int             cid;        /* Context ID, uniquely identifies this call */
+    int             active;     /* 0=inactive, 1=active/physical link down, 2=active/physical link up */
+    char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
+                                   For example, "IP", "IPV6", "IPV4V6", or "PPP". */
+    char *          apn;        /* ignored */
+    char *          address;    /* An address, e.g., "192.0.1.3" or "2001:db8::1". */
+} RIL_Data_Call_Response_v4;
+
+/*
+ * Returned by RIL_REQUEST_SETUP_DATA_CALL, RIL_REQUEST_DATA_CALL_LIST
+ * and RIL_UNSOL_DATA_CALL_LIST_CHANGED, on error status != 0.
+ */
+typedef struct {
+    int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
+    int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
+                                           back-off timer value RIL wants to override the one
+                                           pre-configured in FW.
+                                           The unit is miliseconds.
+                                           The value < 0 means no value is suggested.
+                                           The value 0 means retry should be done ASAP.
+                                           The value of INT_MAX(0x7fffffff) means no retry. */
+    int             cid;        /* Context ID, uniquely identifies this call */
+    int             active;     /* 0=inactive, 1=active/physical link down, 2=active/physical link up */
+    char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
+                                   For example, "IP", "IPV6", "IPV4V6", or "PPP". If status is
+                                   PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED this is the type supported
+                                   such as "IP" or "IPV6" */
+    char *          ifname;     /* The network interface name */
+    char *          addresses;  /* A space-delimited list of addresses with optional "/" prefix length,
+                                   e.g., "192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
+                                   May not be empty, typically 1 IPv4 or 1 IPv6 or
+                                   one of each. If the prefix length is absent the addresses
+                                   are assumed to be point to point with IPv4 having a prefix
+                                   length of 32 and IPv6 128. */
+    char *          dnses;      /* A space-delimited list of DNS server addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty. */
+    char *          gateways;   /* A space-delimited list of default gateway addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty in which case the addresses represent point
+                                   to point connections. */
+} RIL_Data_Call_Response_v6;
+
+typedef struct {
+    int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
+    int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
+                                           back-off timer value RIL wants to override the one
+                                           pre-configured in FW.
+                                           The unit is miliseconds.
+                                           The value < 0 means no value is suggested.
+                                           The value 0 means retry should be done ASAP.
+                                           The value of INT_MAX(0x7fffffff) means no retry. */
+    int             cid;        /* Context ID, uniquely identifies this call */
+    int             active;     /* 0=inactive, 1=active/physical link down, 2=active/physical link up */
+    char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
+                                   For example, "IP", "IPV6", "IPV4V6", or "PPP". If status is
+                                   PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED this is the type supported
+                                   such as "IP" or "IPV6" */
+    char *          ifname;     /* The network interface name */
+    char *          addresses;  /* A space-delimited list of addresses with optional "/" prefix length,
+                                   e.g., "192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
+                                   May not be empty, typically 1 IPv4 or 1 IPv6 or
+                                   one of each. If the prefix length is absent the addresses
+                                   are assumed to be point to point with IPv4 having a prefix
+                                   length of 32 and IPv6 128. */
+    char *          dnses;      /* A space-delimited list of DNS server addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty. */
+    char *          gateways;   /* A space-delimited list of default gateway addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty in which case the addresses represent point
+                                   to point connections. */
+    char *          pcscf;    /* the Proxy Call State Control Function address
+                                 via PCO(Protocol Configuration Option) for IMS client. */
+} RIL_Data_Call_Response_v9;
+
+typedef struct {
+    int             status;     /* A RIL_DataCallFailCause, 0 which is PDP_FAIL_NONE if no error */
+    int             suggestedRetryTime; /* If status != 0, this fields indicates the suggested retry
+                                           back-off timer value RIL wants to override the one
+                                           pre-configured in FW.
+                                           The unit is miliseconds.
+                                           The value < 0 means no value is suggested.
+                                           The value 0 means retry should be done ASAP.
+                                           The value of INT_MAX(0x7fffffff) means no retry. */
+    int             cid;        /* Context ID, uniquely identifies this call */
+    int             active;     /* 0=inactive, 1=active/physical link down, 2=active/physical link up */
+    char *          type;       /* One of the PDP_type values in TS 27.007 section 10.1.1.
+                                   For example, "IP", "IPV6", "IPV4V6", or "PPP". If status is
+                                   PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED this is the type supported
+                                   such as "IP" or "IPV6" */
+    char *          ifname;     /* The network interface name */
+    char *          addresses;  /* A space-delimited list of addresses with optional "/" prefix length,
+                                   e.g., "192.0.1.3" or "192.0.1.11/16 2001:db8::1/64".
+                                   May not be empty, typically 1 IPv4 or 1 IPv6 or
+                                   one of each. If the prefix length is absent the addresses
+                                   are assumed to be point to point with IPv4 having a prefix
+                                   length of 32 and IPv6 128. */
+    char *          dnses;      /* A space-delimited list of DNS server addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty. */
+    char *          gateways;   /* A space-delimited list of default gateway addresses,
+                                   e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
+                                   May be empty in which case the addresses represent point
+                                   to point connections. */
+    char *          pcscf;    /* the Proxy Call State Control Function address
+                                 via PCO(Protocol Configuration Option) for IMS client. */
+    int             mtu;        /* MTU received from network
+                                   Value <= 0 means network has either not sent a value or
+                                   sent an invalid value */
+} RIL_Data_Call_Response_v11;
+
+typedef enum {
+    RADIO_TECH_3GPP = 1, /* 3GPP Technologies - GSM, WCDMA */
+    RADIO_TECH_3GPP2 = 2 /* 3GPP2 Technologies - CDMA */
+} RIL_RadioTechnologyFamily;
+
+typedef struct {
+    RIL_RadioTechnologyFamily tech;
+    unsigned char             retry;       /* 0 == not retry, nonzero == retry */
+    int                       messageRef;  /* Valid field if retry is set to nonzero.
+                                              Contains messageRef from RIL_SMS_Response
+                                              corresponding to failed MO SMS.
+                                            */
+
+    union {
+        /* Valid field if tech is RADIO_TECH_3GPP2. See RIL_REQUEST_CDMA_SEND_SMS */
+        RIL_CDMA_SMS_Message* cdmaMessage;
+
+        /* Valid field if tech is RADIO_TECH_3GPP. See RIL_REQUEST_SEND_SMS */
+        char**                gsmMessage;   /* This is an array of pointers where pointers
+                                               are contiguous but elements pointed by those pointers
+                                               are not contiguous
+                                            */
+    } message;
+} RIL_IMS_SMS_Message;
+
+typedef struct {
+    int messageRef;   /* TP-Message-Reference for GSM,
+                         and BearerData MessageId for CDMA
+                         (See 3GPP2 C.S0015-B, v2.0, table 4.5-1). */
+    char *ackPDU;     /* or NULL if n/a */
+    int errorCode;    /* See 3GPP 27.005, 3.2.5 for GSM/UMTS,
+                         3GPP2 N.S0005 (IS-41C) Table 171 for CDMA,
+                         -1 if unknown or not applicable*/
+} RIL_SMS_Response;
+
+/** Used by RIL_REQUEST_WRITE_SMS_TO_SIM */
+typedef struct {
+    int status;     /* Status of message.  See TS 27.005 3.1, "<stat>": */
+                    /*      0 = "REC UNREAD"    */
+                    /*      1 = "REC READ"      */
+                    /*      2 = "STO UNSENT"    */
+                    /*      3 = "STO SENT"      */
+    char * pdu;     /* PDU of message to write, as an ASCII hex string less the SMSC address,
+                       the TP-layer length is "strlen(pdu)/2". */
+    char * smsc;    /* SMSC address in GSM BCD format prefixed by a length byte
+                       (as expected by TS 27.005) or NULL for default SMSC */
+} RIL_SMS_WriteArgs;
+
+/** Used by RIL_REQUEST_DIAL */
+typedef struct {
+    char * address;
+    int clir;
+            /* (same as 'n' paremeter in TS 27.007 7.7 "+CLIR"
+             * clir == 0 on "use subscription default value"
+             * clir == 1 on "CLIR invocation" (restrict CLI presentation)
+             * clir == 2 on "CLIR suppression" (allow CLI presentation)
+             */
+    RIL_UUS_Info *  uusInfo;    /* NULL or Pointer to User-User Signaling Information */
+} RIL_Dial;
+
+typedef struct {
+    int command;    /* one of the commands listed for TS 27.007 +CRSM*/
+    int fileid;     /* EF id */
+    char *path;     /* "pathid" from TS 27.007 +CRSM command.
+                       Path is in hex asciii format eg "7f205f70"
+                       Path must always be provided.
+                     */
+    int p1;
+    int p2;
+    int p3;
+    char *data;     /* May be NULL*/
+    char *pin2;     /* May be NULL*/
+} RIL_SIM_IO_v5;
+
+typedef struct {
+    int command;    /* one of the commands listed for TS 27.007 +CRSM*/
+    int fileid;     /* EF id */
+    char *path;     /* "pathid" from TS 27.007 +CRSM command.
+                       Path is in hex asciii format eg "7f205f70"
+                       Path must always be provided.
+                     */
+    int p1;
+    int p2;
+    int p3;
+    char *data;     /* May be NULL*/
+    char *pin2;     /* May be NULL*/
+    char *aidPtr;   /* AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value. */
+} RIL_SIM_IO_v6;
+
+/* Used by RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL and
+ * RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC. */
+typedef struct {
+    int sessionid;  /* "sessionid" from TS 27.007 +CGLA command. Should be
+                       ignored for +CSIM command. */
+
+    /* Following fields are used to derive the APDU ("command" and "length"
+       values in TS 27.007 +CSIM and +CGLA commands). */
+    int cla;
+    int instruction;
+    int p1;
+    int p2;
+    int p3;         /* A negative P3 implies a 4 byte APDU. */
+    char *data;     /* May be NULL. In hex string format. */
+} RIL_SIM_APDU;
+
+typedef struct {
+    int sw1;
+    int sw2;
+    char *simResponse;  /* In hex string format ([a-fA-F0-9]*), except for SIM_AUTHENTICATION
+                           response for which it is in Base64 format, see 3GPP TS 31.102 7.1.2 */
+} RIL_SIM_IO_Response;
+
+/* See also com.android.internal.telephony.gsm.CallForwardInfo */
+
+typedef struct {
+    int             status;     /*
+                                 * For RIL_REQUEST_QUERY_CALL_FORWARD_STATUS
+                                 * status 1 = active, 0 = not active
+                                 *
+                                 * For RIL_REQUEST_SET_CALL_FORWARD:
+                                 * status is:
+                                 * 0 = disable
+                                 * 1 = enable
+                                 * 2 = interrogate
+                                 * 3 = registeration
+                                 * 4 = erasure
+                                 */
+
+    int             reason;      /* from TS 27.007 7.11 "reason" */
+    int             serviceClass;/* From 27.007 +CCFC/+CLCK "class"
+                                    See table for Android mapping from
+                                    MMI service code
+                                    0 means user doesn't input class */
+    int             toa;         /* "type" from TS 27.007 7.11 */
+    char *          number;      /* "number" from TS 27.007 7.11. May be NULL */
+    int             timeSeconds; /* for CF no reply only */
+}RIL_CallForwardInfo;
+
+typedef struct {
+   char * cid;         /* Combination of LAC and Cell Id in 32 bits in GSM.
+                        * Upper 16 bits is LAC and lower 16 bits
+                        * is CID (as described in TS 27.005)
+                        * Primary Scrambling Code (as described in TS 25.331)
+                        *         in 9 bits in UMTS
+                        * Valid values are hexadecimal 0x0000 - 0xffffffff.
+                        */
+   int    rssi;        /* Received RSSI in GSM,
+                        * Level index of CPICH Received Signal Code Power in UMTS
+                        */
+} RIL_NeighboringCell;
+
+typedef struct {
+  char lce_status;                 /* LCE service status:
+                                    * -1 = not supported;
+                                    * 0 = stopped;
+                                    * 1 = active.
+                                    */
+  unsigned int actual_interval_ms; /* actual LCE reporting interval,
+                                    * meaningful only if LCEStatus = 1.
+                                    */
+} RIL_LceStatusInfo;
+
+typedef struct {
+  unsigned int last_hop_capacity_kbps; /* last-hop cellular capacity: kilobits/second. */
+  unsigned char confidence_level;      /* capacity estimate confidence: 0-100 */
+  unsigned char lce_suspended;         /* LCE report going to be suspended? (e.g., radio
+                                        * moves to inactive state or network type change)
+                                        * 1 = suspended;
+                                        * 0 = not suspended.
+                                        */
+} RIL_LceDataInfo;
+
+typedef enum {
+    RIL_MATCH_ALL = 0,          /* Apply to all carriers with the same mcc/mnc */
+    RIL_MATCH_SPN = 1,          /* Use SPN and mcc/mnc to identify the carrier */
+    RIL_MATCH_IMSI_PREFIX = 2,  /* Use IMSI prefix and mcc/mnc to identify the carrier */
+    RIL_MATCH_GID1 = 3,         /* Use GID1 and mcc/mnc to identify the carrier */
+    RIL_MATCH_GID2 = 4,         /* Use GID2 and mcc/mnc to identify the carrier */
+} RIL_CarrierMatchType;
+
+typedef struct {
+    const char * mcc;
+    const char * mnc;
+    RIL_CarrierMatchType match_type;   /* Specify match type for the carrier.
+                                        * If itâ€™s RIL_MATCH_ALL, match_data is null;
+                                        * otherwise, match_data is the value for the match type.
+                                        */
+    const char * match_data;
+} RIL_Carrier;
+
+typedef struct {
+  int32_t len_allowed_carriers;         /* length of array allowed_carriers */
+  int32_t len_excluded_carriers;        /* length of array excluded_carriers */
+  RIL_Carrier * allowed_carriers;       /* whitelist for allowed carriers */
+  RIL_Carrier * excluded_carriers;      /* blacklist for explicitly excluded carriers
+                                         * which match allowed_carriers. Eg. allowed_carriers match
+                                         * mcc/mnc, excluded_carriers has same mcc/mnc and gid1
+                                         * is ABCD. It means except the carrier whose gid1 is ABCD,
+                                         * all carriers with the same mcc/mnc are allowed.
+                                         */
+} RIL_CarrierRestrictions;
+
+/* See RIL_REQUEST_LAST_CALL_FAIL_CAUSE */
+typedef enum {
+    CALL_FAIL_UNOBTAINABLE_NUMBER = 1,
+    CALL_FAIL_NO_ROUTE_TO_DESTINATION = 3,
+    CALL_FAIL_CHANNEL_UNACCEPTABLE = 6,
+    CALL_FAIL_OPERATOR_DETERMINED_BARRING = 8,
+    CALL_FAIL_NORMAL = 16,
+    CALL_FAIL_BUSY = 17,
+    CALL_FAIL_NO_USER_RESPONDING = 18,
+    CALL_FAIL_NO_ANSWER_FROM_USER = 19,
+    CALL_FAIL_CALL_REJECTED = 21,
+    CALL_FAIL_NUMBER_CHANGED = 22,
+    CALL_FAIL_PREEMPTION = 25,
+    CALL_FAIL_DESTINATION_OUT_OF_ORDER = 27,
+    CALL_FAIL_INVALID_NUMBER_FORMAT = 28,
+    CALL_FAIL_FACILITY_REJECTED = 29,
+    CALL_FAIL_RESP_TO_STATUS_ENQUIRY = 30,
+    CALL_FAIL_NORMAL_UNSPECIFIED = 31,
+    CALL_FAIL_CONGESTION = 34,
+    CALL_FAIL_NETWORK_OUT_OF_ORDER = 38,
+    CALL_FAIL_TEMPORARY_FAILURE = 41,
+    CALL_FAIL_SWITCHING_EQUIPMENT_CONGESTION = 42,
+    CALL_FAIL_ACCESS_INFORMATION_DISCARDED = 43,
+    CALL_FAIL_REQUESTED_CIRCUIT_OR_CHANNEL_NOT_AVAILABLE = 44,
+    CALL_FAIL_RESOURCES_UNAVAILABLE_OR_UNSPECIFIED = 47,
+    CALL_FAIL_QOS_UNAVAILABLE = 49,
+    CALL_FAIL_REQUESTED_FACILITY_NOT_SUBSCRIBED = 50,
+    CALL_FAIL_INCOMING_CALLS_BARRED_WITHIN_CUG = 55,
+    CALL_FAIL_BEARER_CAPABILITY_NOT_AUTHORIZED = 57,
+    CALL_FAIL_BEARER_CAPABILITY_UNAVAILABLE = 58,
+    CALL_FAIL_SERVICE_OPTION_NOT_AVAILABLE = 63,
+    CALL_FAIL_BEARER_SERVICE_NOT_IMPLEMENTED = 65,
+    CALL_FAIL_ACM_LIMIT_EXCEEDED = 68,
+    CALL_FAIL_REQUESTED_FACILITY_NOT_IMPLEMENTED = 69,
+    CALL_FAIL_ONLY_DIGITAL_INFORMATION_BEARER_AVAILABLE = 70,
+    CALL_FAIL_SERVICE_OR_OPTION_NOT_IMPLEMENTED = 79,
+    CALL_FAIL_INVALID_TRANSACTION_IDENTIFIER = 81,
+    CALL_FAIL_USER_NOT_MEMBER_OF_CUG = 87,
+    CALL_FAIL_INCOMPATIBLE_DESTINATION = 88,
+    CALL_FAIL_INVALID_TRANSIT_NW_SELECTION = 91,
+    CALL_FAIL_SEMANTICALLY_INCORRECT_MESSAGE = 95,
+    CALL_FAIL_INVALID_MANDATORY_INFORMATION = 96,
+    CALL_FAIL_MESSAGE_TYPE_NON_IMPLEMENTED = 97,
+    CALL_FAIL_MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 98,
+    CALL_FAIL_INFORMATION_ELEMENT_NON_EXISTENT = 99,
+    CALL_FAIL_CONDITIONAL_IE_ERROR = 100,
+    CALL_FAIL_MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE = 101,
+    CALL_FAIL_RECOVERY_ON_TIMER_EXPIRED = 102,
+    CALL_FAIL_PROTOCOL_ERROR_UNSPECIFIED = 111,
+    CALL_FAIL_INTERWORKING_UNSPECIFIED = 127,
+    CALL_FAIL_CALL_BARRED = 240,
+    CALL_FAIL_FDN_BLOCKED = 241,
+    CALL_FAIL_IMSI_UNKNOWN_IN_VLR = 242,
+    CALL_FAIL_IMEI_NOT_ACCEPTED = 243,
+    CALL_FAIL_DIAL_MODIFIED_TO_USSD = 244, /* STK Call Control */
+    CALL_FAIL_DIAL_MODIFIED_TO_SS = 245,
+    CALL_FAIL_DIAL_MODIFIED_TO_DIAL = 246,
+    CALL_FAIL_CDMA_LOCKED_UNTIL_POWER_CYCLE = 1000,
+    CALL_FAIL_CDMA_DROP = 1001,
+    CALL_FAIL_CDMA_INTERCEPT = 1002,
+    CALL_FAIL_CDMA_REORDER = 1003,
+    CALL_FAIL_CDMA_SO_REJECT = 1004,
+    CALL_FAIL_CDMA_RETRY_ORDER = 1005,
+    CALL_FAIL_CDMA_ACCESS_FAILURE = 1006,
+    CALL_FAIL_CDMA_PREEMPTED = 1007,
+    CALL_FAIL_CDMA_NOT_EMERGENCY = 1008, /* For non-emergency number dialed
+                                            during emergency callback mode */
+    CALL_FAIL_CDMA_ACCESS_BLOCKED = 1009, /* CDMA network access probes blocked */
+    CALL_FAIL_ERROR_UNSPECIFIED = 0xffff /* This error will be deprecated soon,
+                                            vendor code should make sure to map error
+                                            code to specific error */
+} RIL_LastCallFailCause;
+
+typedef struct {
+  RIL_LastCallFailCause cause_code;
+  char *                vendor_cause;
+} RIL_LastCallFailCauseInfo;
+
+/* See RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE */
+typedef enum {
+    PDP_FAIL_NONE = 0, /* No error, connection ok */
+
+    /* an integer cause code defined in TS 24.008
+       section 6.1.3.1.3 or TS 24.301 Release 8+ Annex B.
+       If the implementation does not have access to the exact cause codes,
+       then it should return one of the following values,
+       as the UI layer needs to distinguish these
+       cases for error notification and potential retries. */
+    PDP_FAIL_OPERATOR_BARRED = 0x08,               /* no retry */
+    PDP_FAIL_NAS_SIGNALLING = 0x0E,
+    PDP_FAIL_LLC_SNDCP = 0x19,
+    PDP_FAIL_INSUFFICIENT_RESOURCES = 0x1A,
+    PDP_FAIL_MISSING_UKNOWN_APN = 0x1B,            /* no retry */
+    PDP_FAIL_UNKNOWN_PDP_ADDRESS_TYPE = 0x1C,      /* no retry */
+    PDP_FAIL_USER_AUTHENTICATION = 0x1D,           /* no retry */
+    PDP_FAIL_ACTIVATION_REJECT_GGSN = 0x1E,        /* no retry */
+    PDP_FAIL_ACTIVATION_REJECT_UNSPECIFIED = 0x1F,
+    PDP_FAIL_SERVICE_OPTION_NOT_SUPPORTED = 0x20,  /* no retry */
+    PDP_FAIL_SERVICE_OPTION_NOT_SUBSCRIBED = 0x21, /* no retry */
+    PDP_FAIL_SERVICE_OPTION_OUT_OF_ORDER = 0x22,
+    PDP_FAIL_NSAPI_IN_USE = 0x23,                  /* no retry */
+    PDP_FAIL_REGULAR_DEACTIVATION = 0x24,          /* possibly restart radio,
+                                                      based on framework config */
+    PDP_FAIL_QOS_NOT_ACCEPTED = 0x25,
+    PDP_FAIL_NETWORK_FAILURE = 0x26,
+    PDP_FAIL_UMTS_REACTIVATION_REQ = 0x27,
+    PDP_FAIL_FEATURE_NOT_SUPP = 0x28,
+    PDP_FAIL_TFT_SEMANTIC_ERROR = 0x29,
+    PDP_FAIL_TFT_SYTAX_ERROR = 0x2A,
+    PDP_FAIL_UNKNOWN_PDP_CONTEXT = 0x2B,
+    PDP_FAIL_FILTER_SEMANTIC_ERROR = 0x2C,
+    PDP_FAIL_FILTER_SYTAX_ERROR = 0x2D,
+    PDP_FAIL_PDP_WITHOUT_ACTIVE_TFT = 0x2E,
+    PDP_FAIL_ONLY_IPV4_ALLOWED = 0x32,             /* no retry */
+    PDP_FAIL_ONLY_IPV6_ALLOWED = 0x33,             /* no retry */
+    PDP_FAIL_ONLY_SINGLE_BEARER_ALLOWED = 0x34,
+    PDP_FAIL_ESM_INFO_NOT_RECEIVED = 0x35,
+    PDP_FAIL_PDN_CONN_DOES_NOT_EXIST = 0x36,
+    PDP_FAIL_MULTI_CONN_TO_SAME_PDN_NOT_ALLOWED = 0x37,
+    PDP_FAIL_MAX_ACTIVE_PDP_CONTEXT_REACHED = 0x41,
+    PDP_FAIL_UNSUPPORTED_APN_IN_CURRENT_PLMN = 0x42,
+    PDP_FAIL_INVALID_TRANSACTION_ID = 0x51,
+    PDP_FAIL_MESSAGE_INCORRECT_SEMANTIC = 0x5F,
+    PDP_FAIL_INVALID_MANDATORY_INFO = 0x60,
+    PDP_FAIL_MESSAGE_TYPE_UNSUPPORTED = 0x61,
+    PDP_FAIL_MSG_TYPE_NONCOMPATIBLE_STATE = 0x62,
+    PDP_FAIL_UNKNOWN_INFO_ELEMENT = 0x63,
+    PDP_FAIL_CONDITIONAL_IE_ERROR = 0x64,
+    PDP_FAIL_MSG_AND_PROTOCOL_STATE_UNCOMPATIBLE = 0x65,
+    PDP_FAIL_PROTOCOL_ERRORS = 0x6F,             /* no retry */
+    PDP_FAIL_APN_TYPE_CONFLICT = 0x70,
+    PDP_FAIL_INVALID_PCSCF_ADDR = 0x71,
+    PDP_FAIL_INTERNAL_CALL_PREEMPT_BY_HIGH_PRIO_APN = 0x72,
+    PDP_FAIL_EMM_ACCESS_BARRED = 0x73,
+    PDP_FAIL_EMERGENCY_IFACE_ONLY = 0x74,
+    PDP_FAIL_IFACE_MISMATCH = 0x75,
+    PDP_FAIL_COMPANION_IFACE_IN_USE = 0x76,
+    PDP_FAIL_IP_ADDRESS_MISMATCH = 0x77,
+    PDP_FAIL_IFACE_AND_POL_FAMILY_MISMATCH = 0x78,
+    PDP_FAIL_EMM_ACCESS_BARRED_INFINITE_RETRY = 0x79,
+    PDP_FAIL_AUTH_FAILURE_ON_EMERGENCY_CALL = 0x7A,
+
+    // OEM specific error codes. To be used by OEMs when they don't want to
+    // reveal error code which would be replaced by PDP_FAIL_ERROR_UNSPECIFIED
+    PDP_FAIL_OEM_DCFAILCAUSE_1 = 0x1001,
+    PDP_FAIL_OEM_DCFAILCAUSE_2 = 0x1002,
+    PDP_FAIL_OEM_DCFAILCAUSE_3 = 0x1003,
+    PDP_FAIL_OEM_DCFAILCAUSE_4 = 0x1004,
+    PDP_FAIL_OEM_DCFAILCAUSE_5 = 0x1005,
+    PDP_FAIL_OEM_DCFAILCAUSE_6 = 0x1006,
+    PDP_FAIL_OEM_DCFAILCAUSE_7 = 0x1007,
+    PDP_FAIL_OEM_DCFAILCAUSE_8 = 0x1008,
+    PDP_FAIL_OEM_DCFAILCAUSE_9 = 0x1009,
+    PDP_FAIL_OEM_DCFAILCAUSE_10 = 0x100A,
+    PDP_FAIL_OEM_DCFAILCAUSE_11 = 0x100B,
+    PDP_FAIL_OEM_DCFAILCAUSE_12 = 0x100C,
+    PDP_FAIL_OEM_DCFAILCAUSE_13 = 0x100D,
+    PDP_FAIL_OEM_DCFAILCAUSE_14 = 0x100E,
+    PDP_FAIL_OEM_DCFAILCAUSE_15 = 0x100F,
+
+    /* Not mentioned in the specification */
+    PDP_FAIL_VOICE_REGISTRATION_FAIL = -1,
+    PDP_FAIL_DATA_REGISTRATION_FAIL = -2,
+
+   /* reasons for data call drop - network/modem disconnect */
+    PDP_FAIL_SIGNAL_LOST = -3,
+    PDP_FAIL_PREF_RADIO_TECH_CHANGED = -4,/* preferred technology has changed, should retry
+                                             with parameters appropriate for new technology */
+    PDP_FAIL_RADIO_POWER_OFF = -5,        /* data call was disconnected because radio was resetting,
+                                             powered off - no retry */
+    PDP_FAIL_TETHERED_CALL_ACTIVE = -6,   /* data call was disconnected by modem because tethered
+                                             mode was up on same APN/data profile - no retry until
+                                             tethered call is off */
+
+    PDP_FAIL_ERROR_UNSPECIFIED = 0xffff,  /* retry silently. Will be deprecated soon as
+                                             new error codes are added making this unnecessary */
+} RIL_DataCallFailCause;
+
+/* See RIL_REQUEST_SETUP_DATA_CALL */
+typedef enum {
+    RIL_DATA_PROFILE_DEFAULT    = 0,
+    RIL_DATA_PROFILE_TETHERED   = 1,
+    RIL_DATA_PROFILE_IMS        = 2,
+    RIL_DATA_PROFILE_FOTA       = 3,
+    RIL_DATA_PROFILE_CBS        = 4,
+    RIL_DATA_PROFILE_OEM_BASE   = 1000,    /* Start of OEM-specific profiles */
+    RIL_DATA_PROFILE_INVALID    = 0xFFFFFFFF
+} RIL_DataProfile;
+
+/* Used by RIL_UNSOL_SUPP_SVC_NOTIFICATION */
+typedef struct {
+    int     notificationType;   /*
+                                 * 0 = MO intermediate result code
+                                 * 1 = MT unsolicited result code
+                                 */
+    int     code;               /* See 27.007 7.17
+                                   "code1" for MO
+                                   "code2" for MT. */
+    int     index;              /* CUG index. See 27.007 7.17. */
+    int     type;               /* "type" from 27.007 7.17 (MT only). */
+    char *  number;             /* "number" from 27.007 7.17
+                                   (MT only, may be NULL). */
+} RIL_SuppSvcNotification;
+
+#define RIL_CARD_MAX_APPS     8
+
+typedef enum {
+    RIL_CARDSTATE_ABSENT     = 0,
+    RIL_CARDSTATE_PRESENT    = 1,
+    RIL_CARDSTATE_ERROR      = 2,
+    RIL_CARDSTATE_RESTRICTED = 3  /* card is present but not usable due to carrier restrictions.*/
+} RIL_CardState;
+
+typedef enum {
+    RIL_PERSOSUBSTATE_UNKNOWN                   = 0, /* initial state */
+    RIL_PERSOSUBSTATE_IN_PROGRESS               = 1, /* in between each lock transition */
+    RIL_PERSOSUBSTATE_READY                     = 2, /* when either SIM or RUIM Perso is finished
+                                                        since each app can only have 1 active perso
+                                                        involved */
+    RIL_PERSOSUBSTATE_SIM_NETWORK               = 3,
+    RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET        = 4,
+    RIL_PERSOSUBSTATE_SIM_CORPORATE             = 5,
+    RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER      = 6,
+    RIL_PERSOSUBSTATE_SIM_SIM                   = 7,
+    RIL_PERSOSUBSTATE_SIM_NETWORK_PUK           = 8, /* The corresponding perso lock is blocked */
+    RIL_PERSOSUBSTATE_SIM_NETWORK_SUBSET_PUK    = 9,
+    RIL_PERSOSUBSTATE_SIM_CORPORATE_PUK         = 10,
+    RIL_PERSOSUBSTATE_SIM_SERVICE_PROVIDER_PUK  = 11,
+    RIL_PERSOSUBSTATE_SIM_SIM_PUK               = 12,
+    RIL_PERSOSUBSTATE_RUIM_NETWORK1             = 13,
+    RIL_PERSOSUBSTATE_RUIM_NETWORK2             = 14,
+    RIL_PERSOSUBSTATE_RUIM_HRPD                 = 15,
+    RIL_PERSOSUBSTATE_RUIM_CORPORATE            = 16,
+    RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER     = 17,
+    RIL_PERSOSUBSTATE_RUIM_RUIM                 = 18,
+    RIL_PERSOSUBSTATE_RUIM_NETWORK1_PUK         = 19, /* The corresponding perso lock is blocked */
+    RIL_PERSOSUBSTATE_RUIM_NETWORK2_PUK         = 20,
+    RIL_PERSOSUBSTATE_RUIM_HRPD_PUK             = 21,
+    RIL_PERSOSUBSTATE_RUIM_CORPORATE_PUK        = 22,
+    RIL_PERSOSUBSTATE_RUIM_SERVICE_PROVIDER_PUK = 23,
+    RIL_PERSOSUBSTATE_RUIM_RUIM_PUK             = 24
+} RIL_PersoSubstate;
+
+typedef enum {
+    RIL_APPSTATE_UNKNOWN               = 0,
+    RIL_APPSTATE_DETECTED              = 1,
+    RIL_APPSTATE_PIN                   = 2, /* If PIN1 or UPin is required */
+    RIL_APPSTATE_PUK                   = 3, /* If PUK1 or Puk for UPin is required */
+    RIL_APPSTATE_SUBSCRIPTION_PERSO    = 4, /* perso_substate should be look at
+                                               when app_state is assigned to this value */
+    RIL_APPSTATE_READY                 = 5
+} RIL_AppState;
+
+typedef enum {
+    RIL_PINSTATE_UNKNOWN              = 0,
+    RIL_PINSTATE_ENABLED_NOT_VERIFIED = 1,
+    RIL_PINSTATE_ENABLED_VERIFIED     = 2,
+    RIL_PINSTATE_DISABLED             = 3,
+    RIL_PINSTATE_ENABLED_BLOCKED      = 4,
+    RIL_PINSTATE_ENABLED_PERM_BLOCKED = 5
+} RIL_PinState;
+
+typedef enum {
+  RIL_APPTYPE_UNKNOWN = 0,
+  RIL_APPTYPE_SIM     = 1,
+  RIL_APPTYPE_USIM    = 2,
+  RIL_APPTYPE_RUIM    = 3,
+  RIL_APPTYPE_CSIM    = 4,
+  RIL_APPTYPE_ISIM    = 5
+} RIL_AppType;
+
+typedef struct
+{
+  RIL_AppType      app_type;
+  RIL_AppState     app_state;
+  RIL_PersoSubstate perso_substate; /* applicable only if app_state ==
+                                       RIL_APPSTATE_SUBSCRIPTION_PERSO */
+  char             *aid_ptr;        /* null terminated string, e.g., from 0xA0, 0x00 -> 0x41,
+                                       0x30, 0x30, 0x30 */
+  char             *app_label_ptr;  /* null terminated string */
+  int              pin1_replaced;   /* applicable to USIM, CSIM & ISIM */
+  RIL_PinState     pin1;
+  RIL_PinState     pin2;
+} RIL_AppStatus;
+
+/* Deprecated, use RIL_CardStatus_v6 */
+typedef struct
+{
+  RIL_CardState card_state;
+  RIL_PinState  universal_pin_state;             /* applicable to USIM and CSIM: RIL_PINSTATE_xxx */
+  int           gsm_umts_subscription_app_index; /* value < RIL_CARD_MAX_APPS, -1 if none */
+  int           cdma_subscription_app_index;     /* value < RIL_CARD_MAX_APPS, -1 if none */
+  int           num_applications;                /* value <= RIL_CARD_MAX_APPS */
+  RIL_AppStatus applications[RIL_CARD_MAX_APPS];
+} RIL_CardStatus_v5;
+
+typedef struct
+{
+  RIL_CardState card_state;
+  RIL_PinState  universal_pin_state;             /* applicable to USIM and CSIM: RIL_PINSTATE_xxx */
+  int           gsm_umts_subscription_app_index; /* value < RIL_CARD_MAX_APPS, -1 if none */
+  int           cdma_subscription_app_index;     /* value < RIL_CARD_MAX_APPS, -1 if none */
+  int           ims_subscription_app_index;      /* value < RIL_CARD_MAX_APPS, -1 if none */
+  int           num_applications;                /* value <= RIL_CARD_MAX_APPS */
+  RIL_AppStatus applications[RIL_CARD_MAX_APPS];
+} RIL_CardStatus_v6;
+
+/** The result of a SIM refresh, returned in data[0] of RIL_UNSOL_SIM_REFRESH
+ *      or as part of RIL_SimRefreshResponse_v7
+ */
+typedef enum {
+    /* A file on SIM has been updated.  data[1] contains the EFID. */
+    SIM_FILE_UPDATE = 0,
+    /* SIM initialized.  All files should be re-read. */
+    SIM_INIT = 1,
+    /* SIM reset.  SIM power required, SIM may be locked and all files should be re-read. */
+    SIM_RESET = 2
+} RIL_SimRefreshResult;
+
+typedef struct {
+    RIL_SimRefreshResult result;
+    int                  ef_id; /* is the EFID of the updated file if the result is */
+                                /* SIM_FILE_UPDATE or 0 for any other result. */
+    char *               aid;   /* is AID(application ID) of the card application */
+                                /* See ETSI 102.221 8.1 and 101.220 4 */
+                                /*     For SIM_FILE_UPDATE result it can be set to AID of */
+                                /*         application in which updated EF resides or it can be */
+                                /*         NULL if EF is outside of an application. */
+                                /*     For SIM_INIT result this field is set to AID of */
+                                /*         application that caused REFRESH */
+                                /*     For SIM_RESET result it is NULL. */
+} RIL_SimRefreshResponse_v7;
+
+/* Deprecated, use RIL_CDMA_CallWaiting_v6 */
+typedef struct {
+    char *          number;             /* Remote party number */
+    int             numberPresentation; /* 0=Allowed, 1=Restricted, 2=Not Specified/Unknown */
+    char *          name;               /* Remote party name */
+    RIL_CDMA_SignalInfoRecord signalInfoRecord;
+} RIL_CDMA_CallWaiting_v5;
+
+typedef struct {
+    char *          number;             /* Remote party number */
+    int             numberPresentation; /* 0=Allowed, 1=Restricted, 2=Not Specified/Unknown */
+    char *          name;               /* Remote party name */
+    RIL_CDMA_SignalInfoRecord signalInfoRecord;
+    /* Number type/Number plan required to support International Call Waiting */
+    int             number_type;        /* 0=Unknown, 1=International, 2=National,
+                                           3=Network specific, 4=subscriber */
+    int             number_plan;        /* 0=Unknown, 1=ISDN, 3=Data, 4=Telex, 8=Nat'l, 9=Private */
+} RIL_CDMA_CallWaiting_v6;
+
+/**
+ * Which types of Cell Broadcast Message (CBM) are to be received by the ME
+ *
+ * uFromServiceID - uToServiceID defines a range of CBM message identifiers
+ * whose value is 0x0000 - 0xFFFF as defined in TS 23.041 9.4.1.2.2 for GMS
+ * and 9.4.4.2.2 for UMTS. All other values can be treated as empty
+ * CBM message ID.
+ *
+ * uFromCodeScheme - uToCodeScheme defines a range of CBM data coding schemes
+ * whose value is 0x00 - 0xFF as defined in TS 23.041 9.4.1.2.3 for GMS
+ * and 9.4.4.2.3 for UMTS.
+ * All other values can be treated as empty CBM data coding scheme.
+ *
+ * selected 0 means message types specified in <fromServiceId, toServiceId>
+ * and <fromCodeScheme, toCodeScheme>are not accepted, while 1 means accepted.
+ *
+ * Used by RIL_REQUEST_GSM_GET_BROADCAST_CONFIG and
+ * RIL_REQUEST_GSM_SET_BROADCAST_CONFIG.
+ */
+typedef struct {
+    int fromServiceId;
+    int toServiceId;
+    int fromCodeScheme;
+    int toCodeScheme;
+    unsigned char selected;
+} RIL_GSM_BroadcastSmsConfigInfo;
+
+/* No restriction at all including voice/SMS/USSD/SS/AV64 and packet data. */
+#define RIL_RESTRICTED_STATE_NONE           0x00
+/* Block emergency call due to restriction. But allow all normal voice/SMS/USSD/SS/AV64. */
+#define RIL_RESTRICTED_STATE_CS_EMERGENCY   0x01
+/* Block all normal voice/SMS/USSD/SS/AV64 due to restriction. Only Emergency call allowed. */
+#define RIL_RESTRICTED_STATE_CS_NORMAL      0x02
+/* Block all voice/SMS/USSD/SS/AV64 including emergency call due to restriction.*/
+#define RIL_RESTRICTED_STATE_CS_ALL         0x04
+/* Block packet data access due to restriction. */
+#define RIL_RESTRICTED_STATE_PS_ALL         0x10
+
+/* The status for an OTASP/OTAPA session */
+typedef enum {
+    CDMA_OTA_PROVISION_STATUS_SPL_UNLOCKED,
+    CDMA_OTA_PROVISION_STATUS_SPC_RETRIES_EXCEEDED,
+    CDMA_OTA_PROVISION_STATUS_A_KEY_EXCHANGED,
+    CDMA_OTA_PROVISION_STATUS_SSD_UPDATED,
+    CDMA_OTA_PROVISION_STATUS_NAM_DOWNLOADED,
+    CDMA_OTA_PROVISION_STATUS_MDN_DOWNLOADED,
+    CDMA_OTA_PROVISION_STATUS_IMSI_DOWNLOADED,
+    CDMA_OTA_PROVISION_STATUS_PRL_DOWNLOADED,
+    CDMA_OTA_PROVISION_STATUS_COMMITTED,
+    CDMA_OTA_PROVISION_STATUS_OTAPA_STARTED,
+    CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED,
+    CDMA_OTA_PROVISION_STATUS_OTAPA_ABORTED
+} RIL_CDMA_OTA_ProvisionStatus;
+
+typedef struct {
+    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
+    int bitErrorRate;    /* bit error rate (0-7, 99) as defined in TS 27.007 8.5 */
+} RIL_GW_SignalStrength;
+
+typedef struct {
+    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
+    int bitErrorRate;    /* bit error rate (0-7, 99) as defined in TS 27.007 8.5 */
+    int timingAdvance;   /* Timing Advance in bit periods. 1 bit period = 48/13 us.
+                          * INT_MAX denotes invalid value */
+} RIL_GSM_SignalStrength_v12;
+
+typedef struct {
+    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
+    int bitErrorRate;    /* bit error rate (0-7, 99) as defined in TS 27.007 8.5 */
+} RIL_SignalStrengthWcdma;
+
+typedef struct {
+    int dbm;  /* Valid values are positive integers.  This value is the actual RSSI value
+               * multiplied by -1.  Example: If the actual RSSI is -75, then this response
+               * value will be 75.
+               */
+    int ecio; /* Valid values are positive integers.  This value is the actual Ec/Io multiplied
+               * by -10.  Example: If the actual Ec/Io is -12.5 dB, then this response value
+               * will be 125.
+               */
+} RIL_CDMA_SignalStrength;
+
+
+typedef struct {
+    int dbm;  /* Valid values are positive integers.  This value is the actual RSSI value
+               * multiplied by -1.  Example: If the actual RSSI is -75, then this response
+               * value will be 75.
+               */
+    int ecio; /* Valid values are positive integers.  This value is the actual Ec/Io multiplied
+               * by -10.  Example: If the actual Ec/Io is -12.5 dB, then this response value
+               * will be 125.
+               */
+    int signalNoiseRatio; /* Valid values are 0-8.  8 is the highest signal to noise ratio. */
+} RIL_EVDO_SignalStrength;
+
+typedef struct {
+    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
+    int rsrp;            /* The current Reference Signal Receive Power in dBm multipled by -1.
+                          * Range: 44 to 140 dBm
+                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.133 9.1.4 */
+    int rsrq;            /* The current Reference Signal Receive Quality in dB multiplied by -1.
+                          * Range: 20 to 3 dB.
+                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.133 9.1.7 */
+    int rssnr;           /* The current reference signal signal-to-noise ratio in 0.1 dB units.
+                          * Range: -200 to +300 (-200 = -20.0 dB, +300 = 30dB).
+                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.101 8.1.1 */
+    int cqi;             /* The current Channel Quality Indicator.
+                          * Range: 0 to 15.
+                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.101 9.2, 9.3, A.4 */
+} RIL_LTE_SignalStrength;
+
+typedef struct {
+    int signalStrength;  /* Valid values are (0-31, 99) as defined in TS 27.007 8.5 */
+    int rsrp;            /* The current Reference Signal Receive Power in dBm multipled by -1.
+                          * Range: 44 to 140 dBm
+                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.133 9.1.4 */
+    int rsrq;            /* The current Reference Signal Receive Quality in dB multiplied by -1.
+                          * Range: 20 to 3 dB.
+                          * INT_MAX: 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.133 9.1.7 */
+    int rssnr;           /* The current reference signal signal-to-noise ratio in 0.1 dB units.
+                          * Range: -200 to +300 (-200 = -20.0 dB, +300 = 30dB).
+                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.101 8.1.1 */
+    int cqi;             /* The current Channel Quality Indicator.
+                          * Range: 0 to 15.
+                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP TS 36.101 9.2, 9.3, A.4 */
+    int timingAdvance;   /* timing advance in micro seconds for a one way trip from cell to device.
+                          * Approximate distance can be calculated using 300m/us * timingAdvance.
+                          * Range: 0 to 0x7FFFFFFE
+                          * INT_MAX : 0x7FFFFFFF denotes invalid value.
+                          * Reference: 3GPP 36.321 section 6.1.3.5
+                          * also: http://www.cellular-planningoptimization.com/2010/02/timing-advance-with-calculation.html */
+} RIL_LTE_SignalStrength_v8;
+
+typedef struct {
+    int rscp;    /* The Received Signal Code Power in dBm multipled by -1.
+                  * Range : 25 to 120
+                  * INT_MAX: 0x7FFFFFFF denotes invalid value.
+                  * Reference: 3GPP TS 25.123, section 9.1.1.1 */
+} RIL_TD_SCDMA_SignalStrength;
+
+/* Deprecated, use RIL_SignalStrength_v6 */
+typedef struct {
+    RIL_GW_SignalStrength   GW_SignalStrength;
+    RIL_CDMA_SignalStrength CDMA_SignalStrength;
+    RIL_EVDO_SignalStrength EVDO_SignalStrength;
+} RIL_SignalStrength_v5;
+
+typedef struct {
+    RIL_GW_SignalStrength   GW_SignalStrength;
+    RIL_CDMA_SignalStrength CDMA_SignalStrength;
+    RIL_EVDO_SignalStrength EVDO_SignalStrength;
+    RIL_LTE_SignalStrength  LTE_SignalStrength;
+} RIL_SignalStrength_v6;
+
+typedef struct {
+    RIL_GW_SignalStrength       GW_SignalStrength;
+    RIL_CDMA_SignalStrength     CDMA_SignalStrength;
+    RIL_EVDO_SignalStrength     EVDO_SignalStrength;
+    RIL_LTE_SignalStrength_v8   LTE_SignalStrength;
+} RIL_SignalStrength_v8;
+
+typedef struct {
+    RIL_GW_SignalStrength       GW_SignalStrength;
+    RIL_CDMA_SignalStrength     CDMA_SignalStrength;
+    RIL_EVDO_SignalStrength     EVDO_SignalStrength;
+    RIL_LTE_SignalStrength_v8   LTE_SignalStrength;
+    RIL_TD_SCDMA_SignalStrength TD_SCDMA_SignalStrength;
+} RIL_SignalStrength_v10;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown */
+    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
+    int cid;    /* 16-bit GSM Cell Identity described in TS 27.007, 0..65535, INT_MAX if unknown  */
+} RIL_CellIdentityGsm;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown */
+    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
+    int cid;    /* 16-bit GSM Cell Identity described in TS 27.007, 0..65535, INT_MAX if unknown  */
+    int arfcn;  /* 16-bit GSM Absolute RF channel number, INT_MAX if unknown */
+    uint8_t bsic;/* 6-bit Base Station Identity Code, 0xFF if unknown */
+} RIL_CellIdentityGsm_v12;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
+    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
+    int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
+    int psc;    /* 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511, INT_MAX if unknown */
+} RIL_CellIdentityWcdma;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
+    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
+    int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
+    int psc;    /* 9-bit UMTS Primary Scrambling Code described in TS 25.331, 0..511, INT_MAX if unknown */
+    int uarfcn; /* 16-bit UMTS Absolute RF Channel Number, INT_MAX if unknown */
+} RIL_CellIdentityWcdma_v12;
+
+typedef struct {
+    int networkId;      /* Network Id 0..65535, INT_MAX if unknown */
+    int systemId;       /* CDMA System Id 0..32767, INT_MAX if unknown  */
+    int basestationId;  /* Base Station Id 0..65535, INT_MAX if unknown  */
+    int longitude;      /* Longitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
+                         * It is represented in units of 0.25 seconds and ranges from -2592000
+                         * to 2592000, both values inclusive (corresponding to a range of -180
+                         * to +180 degrees). INT_MAX if unknown */
+
+    int latitude;       /* Latitude is a decimal number as specified in 3GPP2 C.S0005-A v6.0.
+                         * It is represented in units of 0.25 seconds and ranges from -1296000
+                         * to 1296000, both values inclusive (corresponding to a range of -90
+                         * to +90 degrees). INT_MAX if unknown */
+} RIL_CellIdentityCdma;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
+    int ci;     /* 28-bit Cell Identity described in TS ???, INT_MAX if unknown */
+    int pci;    /* physical cell id 0..503, INT_MAX if unknown  */
+    int tac;    /* 16-bit tracking area code, INT_MAX if unknown  */
+} RIL_CellIdentityLte;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
+    int ci;     /* 28-bit Cell Identity described in TS ???, INT_MAX if unknown */
+    int pci;    /* physical cell id 0..503, INT_MAX if unknown  */
+    int tac;    /* 16-bit tracking area code, INT_MAX if unknown  */
+    int earfcn; /* 18-bit LTE Absolute RC Channel Number, INT_MAX if unknown */
+} RIL_CellIdentityLte_v12;
+
+typedef struct {
+    int mcc;    /* 3-digit Mobile Country Code, 0..999, INT_MAX if unknown  */
+    int mnc;    /* 2 or 3-digit Mobile Network Code, 0..999, INT_MAX if unknown  */
+    int lac;    /* 16-bit Location Area Code, 0..65535, INT_MAX if unknown  */
+    int cid;    /* 28-bit UMTS Cell Identity described in TS 25.331, 0..268435455, INT_MAX if unknown  */
+    int cpid;    /* 8-bit Cell Parameters ID described in TS 25.331, 0..127, INT_MAX if unknown */
+} RIL_CellIdentityTdscdma;
+
+typedef struct {
+  RIL_CellIdentityGsm   cellIdentityGsm;
+  RIL_GW_SignalStrength signalStrengthGsm;
+} RIL_CellInfoGsm;
+
+typedef struct {
+  RIL_CellIdentityGsm_v12   cellIdentityGsm;
+  RIL_GSM_SignalStrength_v12 signalStrengthGsm;
+} RIL_CellInfoGsm_v12;
+
+typedef struct {
+  RIL_CellIdentityWcdma cellIdentityWcdma;
+  RIL_SignalStrengthWcdma signalStrengthWcdma;
+} RIL_CellInfoWcdma;
+
+typedef struct {
+  RIL_CellIdentityWcdma_v12 cellIdentityWcdma;
+  RIL_SignalStrengthWcdma signalStrengthWcdma;
+} RIL_CellInfoWcdma_v12;
+
+typedef struct {
+  RIL_CellIdentityCdma      cellIdentityCdma;
+  RIL_CDMA_SignalStrength   signalStrengthCdma;
+  RIL_EVDO_SignalStrength   signalStrengthEvdo;
+} RIL_CellInfoCdma;
+
+typedef struct {
+  RIL_CellIdentityLte        cellIdentityLte;
+  RIL_LTE_SignalStrength_v8  signalStrengthLte;
+} RIL_CellInfoLte;
+
+typedef struct {
+  RIL_CellIdentityLte_v12    cellIdentityLte;
+  RIL_LTE_SignalStrength_v8  signalStrengthLte;
+} RIL_CellInfoLte_v12;
+
+typedef struct {
+  RIL_CellIdentityTdscdma cellIdentityTdscdma;
+  RIL_TD_SCDMA_SignalStrength signalStrengthTdscdma;
+} RIL_CellInfoTdscdma;
+
+// Must be the same as CellInfo.TYPE_XXX
+typedef enum {
+  RIL_CELL_INFO_TYPE_GSM    = 1,
+  RIL_CELL_INFO_TYPE_CDMA   = 2,
+  RIL_CELL_INFO_TYPE_LTE    = 3,
+  RIL_CELL_INFO_TYPE_WCDMA  = 4,
+  RIL_CELL_INFO_TYPE_TD_SCDMA  = 5
+} RIL_CellInfoType;
+
+// Must be the same as CellInfo.TIMESTAMP_TYPE_XXX
+typedef enum {
+    RIL_TIMESTAMP_TYPE_UNKNOWN = 0,
+    RIL_TIMESTAMP_TYPE_ANTENNA = 1,
+    RIL_TIMESTAMP_TYPE_MODEM = 2,
+    RIL_TIMESTAMP_TYPE_OEM_RIL = 3,
+    RIL_TIMESTAMP_TYPE_JAVA_RIL = 4,
+} RIL_TimeStampType;
+
+typedef struct {
+  RIL_CellInfoType  cellInfoType;   /* cell type for selecting from union CellInfo */
+  int               registered;     /* !0 if this cell is registered 0 if not registered */
+  RIL_TimeStampType timeStampType;  /* type of time stamp represented by timeStamp */
+  uint64_t          timeStamp;      /* Time in nanos as returned by ril_nano_time */
+  union {
+    RIL_CellInfoGsm     gsm;
+    RIL_CellInfoCdma    cdma;
+    RIL_CellInfoLte     lte;
+    RIL_CellInfoWcdma   wcdma;
+    RIL_CellInfoTdscdma tdscdma;
+  } CellInfo;
+} RIL_CellInfo;
+
+typedef struct {
+  RIL_CellInfoType  cellInfoType;   /* cell type for selecting from union CellInfo */
+  int               registered;     /* !0 if this cell is registered 0 if not registered */
+  RIL_TimeStampType timeStampType;  /* type of time stamp represented by timeStamp */
+  uint64_t          timeStamp;      /* Time in nanos as returned by ril_nano_time */
+  union {
+    RIL_CellInfoGsm_v12     gsm;
+    RIL_CellInfoCdma        cdma;
+    RIL_CellInfoLte_v12     lte;
+    RIL_CellInfoWcdma_v12   wcdma;
+    RIL_CellInfoTdscdma     tdscdma;
+  } CellInfo;
+} RIL_CellInfo_v12;
+
+/* Names of the CDMA info records (C.S0005 section 3.7.5) */
+typedef enum {
+  RIL_CDMA_DISPLAY_INFO_REC,
+  RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC,
+  RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC,
+  RIL_CDMA_CONNECTED_NUMBER_INFO_REC,
+  RIL_CDMA_SIGNAL_INFO_REC,
+  RIL_CDMA_REDIRECTING_NUMBER_INFO_REC,
+  RIL_CDMA_LINE_CONTROL_INFO_REC,
+  RIL_CDMA_EXTENDED_DISPLAY_INFO_REC,
+  RIL_CDMA_T53_CLIR_INFO_REC,
+  RIL_CDMA_T53_RELEASE_INFO_REC,
+  RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC
+} RIL_CDMA_InfoRecName;
+
+/* Display Info Rec as defined in C.S0005 section 3.7.5.1
+   Extended Display Info Rec as defined in C.S0005 section 3.7.5.16
+   Note: the Extended Display info rec contains multiple records of the
+   form: display_tag, display_len, and display_len occurrences of the
+   chari field if the display_tag is not 10000000 or 10000001.
+   To save space, the records are stored consecutively in a byte buffer.
+   The display_tag, display_len and chari fields are all 1 byte.
+*/
+
+typedef struct {
+  char alpha_len;
+  char alpha_buf[CDMA_ALPHA_INFO_BUFFER_LENGTH];
+} RIL_CDMA_DisplayInfoRecord;
+
+/* Called Party Number Info Rec as defined in C.S0005 section 3.7.5.2
+   Calling Party Number Info Rec as defined in C.S0005 section 3.7.5.3
+   Connected Number Info Rec as defined in C.S0005 section 3.7.5.4
+*/
+
+typedef struct {
+  char len;
+  char buf[CDMA_NUMBER_INFO_BUFFER_LENGTH];
+  char number_type;
+  char number_plan;
+  char pi;
+  char si;
+} RIL_CDMA_NumberInfoRecord;
+
+/* Redirecting Number Information Record as defined in C.S0005 section 3.7.5.11 */
+typedef enum {
+  RIL_REDIRECTING_REASON_UNKNOWN = 0,
+  RIL_REDIRECTING_REASON_CALL_FORWARDING_BUSY = 1,
+  RIL_REDIRECTING_REASON_CALL_FORWARDING_NO_REPLY = 2,
+  RIL_REDIRECTING_REASON_CALLED_DTE_OUT_OF_ORDER = 9,
+  RIL_REDIRECTING_REASON_CALL_FORWARDING_BY_THE_CALLED_DTE = 10,
+  RIL_REDIRECTING_REASON_CALL_FORWARDING_UNCONDITIONAL = 15,
+  RIL_REDIRECTING_REASON_RESERVED
+} RIL_CDMA_RedirectingReason;
+
+typedef struct {
+  RIL_CDMA_NumberInfoRecord redirectingNumber;
+  /* redirectingReason is set to RIL_REDIRECTING_REASON_UNKNOWN if not included */
+  RIL_CDMA_RedirectingReason redirectingReason;
+} RIL_CDMA_RedirectingNumberInfoRecord;
+
+/* Line Control Information Record as defined in C.S0005 section 3.7.5.15 */
+typedef struct {
+  char lineCtrlPolarityIncluded;
+  char lineCtrlToggle;
+  char lineCtrlReverse;
+  char lineCtrlPowerDenial;
+} RIL_CDMA_LineControlInfoRecord;
+
+/* T53 CLIR Information Record */
+typedef struct {
+  char cause;
+} RIL_CDMA_T53_CLIRInfoRecord;
+
+/* T53 Audio Control Information Record */
+typedef struct {
+  char upLink;
+  char downLink;
+} RIL_CDMA_T53_AudioControlInfoRecord;
+
+typedef struct {
+
+  RIL_CDMA_InfoRecName name;
+
+  union {
+    /* Display and Extended Display Info Rec */
+    RIL_CDMA_DisplayInfoRecord           display;
+
+    /* Called Party Number, Calling Party Number, Connected Number Info Rec */
+    RIL_CDMA_NumberInfoRecord            number;
+
+    /* Signal Info Rec */
+    RIL_CDMA_SignalInfoRecord            signal;
+
+    /* Redirecting Number Info Rec */
+    RIL_CDMA_RedirectingNumberInfoRecord redir;
+
+    /* Line Control Info Rec */
+    RIL_CDMA_LineControlInfoRecord       lineCtrl;
+
+    /* T53 CLIR Info Rec */
+    RIL_CDMA_T53_CLIRInfoRecord          clir;
+
+    /* T53 Audio Control Info Rec */
+    RIL_CDMA_T53_AudioControlInfoRecord  audioCtrl;
+  } rec;
+} RIL_CDMA_InformationRecord;
+
+#define RIL_CDMA_MAX_NUMBER_OF_INFO_RECS 10
+
+typedef struct {
+  char numberOfInfoRecs;
+  RIL_CDMA_InformationRecord infoRec[RIL_CDMA_MAX_NUMBER_OF_INFO_RECS];
+} RIL_CDMA_InformationRecords;
+
+/* See RIL_REQUEST_NV_READ_ITEM */
+typedef struct {
+  RIL_NV_Item itemID;
+} RIL_NV_ReadItem;
+
+/* See RIL_REQUEST_NV_WRITE_ITEM */
+typedef struct {
+  RIL_NV_Item   itemID;
+  char *        value;
+} RIL_NV_WriteItem;
+
+typedef enum {
+    HANDOVER_STARTED = 0,
+    HANDOVER_COMPLETED = 1,
+    HANDOVER_FAILED = 2,
+    HANDOVER_CANCELED = 3
+} RIL_SrvccState;
+
+/* hardware configuration reported to RILJ. */
+typedef enum {
+   RIL_HARDWARE_CONFIG_MODEM = 0,
+   RIL_HARDWARE_CONFIG_SIM = 1,
+} RIL_HardwareConfig_Type;
+
+typedef enum {
+   RIL_HARDWARE_CONFIG_STATE_ENABLED = 0,
+   RIL_HARDWARE_CONFIG_STATE_STANDBY = 1,
+   RIL_HARDWARE_CONFIG_STATE_DISABLED = 2,
+} RIL_HardwareConfig_State;
+
+typedef struct {
+   int rilModel;
+   uint32_t rat; /* bitset - ref. RIL_RadioTechnology. */
+   int maxVoice;
+   int maxData;
+   int maxStandby;
+} RIL_HardwareConfig_Modem;
+
+typedef struct {
+   char modemUuid[MAX_UUID_LENGTH];
+} RIL_HardwareConfig_Sim;
+
+typedef struct {
+  RIL_HardwareConfig_Type type;
+  char uuid[MAX_UUID_LENGTH];
+  RIL_HardwareConfig_State state;
+  union {
+     RIL_HardwareConfig_Modem modem;
+     RIL_HardwareConfig_Sim sim;
+  } cfg;
+} RIL_HardwareConfig;
+
+typedef enum {
+  SS_CFU,
+  SS_CF_BUSY,
+  SS_CF_NO_REPLY,
+  SS_CF_NOT_REACHABLE,
+  SS_CF_ALL,
+  SS_CF_ALL_CONDITIONAL,
+  SS_CLIP,
+  SS_CLIR,
+  SS_COLP,
+  SS_COLR,
+  SS_WAIT,
+  SS_BAOC,
+  SS_BAOIC,
+  SS_BAOIC_EXC_HOME,
+  SS_BAIC,
+  SS_BAIC_ROAMING,
+  SS_ALL_BARRING,
+  SS_OUTGOING_BARRING,
+  SS_INCOMING_BARRING
+} RIL_SsServiceType;
+
+typedef enum {
+  SS_ACTIVATION,
+  SS_DEACTIVATION,
+  SS_INTERROGATION,
+  SS_REGISTRATION,
+  SS_ERASURE
+} RIL_SsRequestType;
+
+typedef enum {
+  SS_ALL_TELE_AND_BEARER_SERVICES,
+  SS_ALL_TELESEVICES,
+  SS_TELEPHONY,
+  SS_ALL_DATA_TELESERVICES,
+  SS_SMS_SERVICES,
+  SS_ALL_TELESERVICES_EXCEPT_SMS
+} RIL_SsTeleserviceType;
+
+#define SS_INFO_MAX 4
+#define NUM_SERVICE_CLASSES 7
+
+typedef struct {
+  int numValidIndexes; /* This gives the number of valid values in cfInfo.
+                       For example if voice is forwarded to one number and data
+                       is forwarded to a different one then numValidIndexes will be
+                       2 indicating total number of valid values in cfInfo.
+                       Similarly if all the services are forwarded to the same
+                       number then the value of numValidIndexes will be 1. */
+
+  RIL_CallForwardInfo cfInfo[NUM_SERVICE_CLASSES]; /* This is the response data
+                                                      for SS request to query call
+                                                      forward status. see
+                                                      RIL_REQUEST_QUERY_CALL_FORWARD_STATUS */
+} RIL_CfData;
+
+typedef struct {
+  RIL_SsServiceType serviceType;
+  RIL_SsRequestType requestType;
+  RIL_SsTeleserviceType teleserviceType;
+  int serviceClass;
+  RIL_Errno result;
+
+  union {
+    int ssInfo[SS_INFO_MAX]; /* This is the response data for most of the SS GET/SET
+                                RIL requests. E.g. RIL_REQUSET_GET_CLIR returns
+                                two ints, so first two values of ssInfo[] will be
+                                used for response if serviceType is SS_CLIR and
+                                requestType is SS_INTERROGATION */
+
+    RIL_CfData cfData;
+  };
+} RIL_StkCcUnsolSsResponse;
+
+/**
+ * Data connection power state
+ */
+typedef enum {
+    RIL_DC_POWER_STATE_LOW      = 1,        // Low power state
+    RIL_DC_POWER_STATE_MEDIUM   = 2,        // Medium power state
+    RIL_DC_POWER_STATE_HIGH     = 3,        // High power state
+    RIL_DC_POWER_STATE_UNKNOWN  = INT32_MAX // Unknown state
+} RIL_DcPowerStates;
+
+/**
+ * Data connection real time info
+ */
+typedef struct {
+    uint64_t                    time;       // Time in nanos as returned by ril_nano_time
+    RIL_DcPowerStates           powerState; // Current power state
+} RIL_DcRtInfo;
+
+/**
+ * Data profile to modem
+ */
+typedef struct {
+    /* id of the data profile */
+    int profileId;
+    /* the APN to connect to */
+    char* apn;
+    /** one of the PDP_type values in TS 27.007 section 10.1.1.
+     * For example, "IP", "IPV6", "IPV4V6", or "PPP".
+     */
+    char* protocol;
+    /** authentication protocol used for this PDP context
+     * (None: 0, PAP: 1, CHAP: 2, PAP&CHAP: 3)
+     */
+    int authType;
+    /* the username for APN, or NULL */
+    char* user;
+    /* the password for APN, or NULL */
+    char* password;
+    /* the profile type, TYPE_COMMON-0, TYPE_3GPP-1, TYPE_3GPP2-2 */
+    int type;
+    /* the period in seconds to limit the maximum connections */
+    int maxConnsTime;
+    /* the maximum connections during maxConnsTime */
+    int maxConns;
+    /** the required wait time in seconds after a successful UE initiated
+     * disconnect of a given PDN connection before the device can send
+     * a new PDN connection request for that given PDN
+     */
+    int waitTime;
+    /* true to enable the profile, 0 to disable, 1 to enable */
+    int enabled;
+} RIL_DataProfileInfo;
+
+/* Tx Power Levels */
+#define RIL_NUM_TX_POWER_LEVELS     5
+
+/**
+ * Aggregate modem activity information
+ */
+typedef struct {
+
+  /* total time (in ms) when modem is in a low power or
+   * sleep state
+   */
+  uint32_t sleep_mode_time_ms;
+
+  /* total time (in ms) when modem is awake but neither
+   * the transmitter nor receiver are active/awake */
+  uint32_t idle_mode_time_ms;
+
+  /* total time (in ms) during which the transmitter is active/awake,
+   * subdivided by manufacturer-defined device-specific
+   * contiguous increasing ranges of transmit power between
+   * 0 and the transmitter's maximum transmit power.
+   */
+  uint32_t tx_mode_time_ms[RIL_NUM_TX_POWER_LEVELS];
+
+  /* total time (in ms) for which receiver is active/awake and
+   * the transmitter is inactive */
+  uint32_t rx_mode_time_ms;
+} RIL_ActivityStatsInfo;
+
+/**
+ * RIL_REQUEST_GET_SIM_STATUS
+ *
+ * Requests status of the SIM interface and the SIM card
+ *
+ * "data" is NULL
+ *
+ * "response" is const RIL_CardStatus_v6 *
+ *
+ * Valid errors:
+ *  Must never fail
+ */
+#define RIL_REQUEST_GET_SIM_STATUS 1
+
+/**
+ * RIL_REQUEST_ENTER_SIM_PIN
+ *
+ * Supplies SIM PIN. Only called if RIL_CardStatus has RIL_APPSTATE_PIN state
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is PIN value
+ * ((const char **)data)[1] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE (radio resetting)
+ * GENERIC_FAILURE
+ * PASSWORD_INCORRECT
+ */
+
+#define RIL_REQUEST_ENTER_SIM_PIN 2
+
+/**
+ * RIL_REQUEST_ENTER_SIM_PUK
+ *
+ * Supplies SIM PUK and new PIN.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is PUK value
+ * ((const char **)data)[1] is new PIN value
+ * ((const char **)data)[2] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ *     (PUK is invalid)
+ */
+
+#define RIL_REQUEST_ENTER_SIM_PUK 3
+
+/**
+ * RIL_REQUEST_ENTER_SIM_PIN2
+ *
+ * Supplies SIM PIN2. Only called following operation where SIM_PIN2 was
+ * returned as a a failure from a previous operation.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is PIN2 value
+ * ((const char **)data)[1] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ */
+
+#define RIL_REQUEST_ENTER_SIM_PIN2 4
+
+/**
+ * RIL_REQUEST_ENTER_SIM_PUK2
+ *
+ * Supplies SIM PUK2 and new PIN2.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is PUK2 value
+ * ((const char **)data)[1] is new PIN2 value
+ * ((const char **)data)[2] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ *     (PUK2 is invalid)
+ */
+
+#define RIL_REQUEST_ENTER_SIM_PUK2 5
+
+/**
+ * RIL_REQUEST_CHANGE_SIM_PIN
+ *
+ * Supplies old SIM PIN and new PIN.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is old PIN value
+ * ((const char **)data)[1] is new PIN value
+ * ((const char **)data)[2] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ *     (old PIN is invalid)
+ *
+ */
+
+#define RIL_REQUEST_CHANGE_SIM_PIN 6
+
+
+/**
+ * RIL_REQUEST_CHANGE_SIM_PIN2
+ *
+ * Supplies old SIM PIN2 and new PIN2.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is old PIN2 value
+ * ((const char **)data)[1] is new PIN2 value
+ * ((const char **)data)[2] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ *     (old PIN2 is invalid)
+ *
+ */
+
+#define RIL_REQUEST_CHANGE_SIM_PIN2 7
+
+/**
+ * RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION
+ *
+ * Requests that network personlization be deactivated
+ *
+ * "data" is const char **
+ * ((const char **)(data))[0]] is network depersonlization code
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  PASSWORD_INCORRECT
+ *     (code is invalid)
+ */
+
+#define RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION 8
+
+/**
+ * RIL_REQUEST_GET_CURRENT_CALLS
+ *
+ * Requests current call list
+ *
+ * "data" is NULL
+ *
+ * "response" must be a "const RIL_Call **"
+ *
+ * Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  NO_MEMORY
+ *  GENERIC_FAILURE
+ *      (request will be made again in a few hundred msec)
+ */
+
+#define RIL_REQUEST_GET_CURRENT_CALLS 9
+
+
+/**
+ * RIL_REQUEST_DIAL
+ *
+ * Initiate voice call
+ *
+ * "data" is const RIL_Dial *
+ * "response" is NULL
+ *
+ * This method is never used for supplementary service codes
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  DIAL_MODIFIED_TO_USSD
+ *  DIAL_MODIFIED_TO_SS
+ *  DIAL_MODIFIED_TO_DIAL
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  INVALID_STATE
+ *  NO_RESOURCES
+ *  INTERNAL_ERR
+ *  FDN_CHECK_FAILURE
+ *  MODEM_ERR
+ *  NO_SUBSCRIPTION
+ *  NO_NETWORK_FOUND
+ *  INVALID_CALL_ID
+ *  DEVICE_IN_USE
+ *  MODE_NOT_SUPPORTED
+ *  ABORTED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_DIAL 10
+
+/**
+ * RIL_REQUEST_GET_IMSI
+ *
+ * Get the SIM IMSI
+ *
+ * Only valid when radio state is "RADIO_STATE_ON"
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ * "response" is a const char * containing the IMSI
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_GET_IMSI 11
+
+/**
+ * RIL_REQUEST_HANGUP
+ *
+ * Hang up a specific line (like AT+CHLD=1x)
+ *
+ * After this HANGUP request returns, RIL should show the connection is NOT
+ * active anymore in next RIL_REQUEST_GET_CURRENT_CALLS query.
+ *
+ * "data" is an int *
+ * (int *)data)[0] contains Connection index (value of 'x' in CHLD above)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  INVALID_STATE
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_CALL_ID
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_HANGUP 12
+
+/**
+ * RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND
+ *
+ * Hang up waiting or held (like AT+CHLD=0)
+ *
+ * After this HANGUP request returns, RIL should show the connection is NOT
+ * active anymore in next RIL_REQUEST_GET_CURRENT_CALLS query.
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_CALL_ID
+ *  NO_RESOURCES
+ *  OPERATION_NOT_ALLOWED
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND 13
+
+/**
+ * RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND
+ *
+ * Hang up waiting or held (like AT+CHLD=1)
+ *
+ * After this HANGUP request returns, RIL should show the connection is NOT
+ * active anymore in next RIL_REQUEST_GET_CURRENT_CALLS query.
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  OPERATION_NOT_ALLOWED
+ *  INVALID_ARGUMENTS
+ *  NO_RESOURCES
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND 14
+
+/**
+ * RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE
+ *
+ * Switch waiting or holding call and active call (like AT+CHLD=2)
+ *
+ * State transitions should be is follows:
+ *
+ * If call 1 is waiting and call 2 is active, then if this re
+ *
+ *   BEFORE                               AFTER
+ * Call 1   Call 2                 Call 1       Call 2
+ * ACTIVE   HOLDING                HOLDING     ACTIVE
+ * ACTIVE   WAITING                HOLDING     ACTIVE
+ * HOLDING  WAITING                HOLDING     ACTIVE
+ * ACTIVE   IDLE                   HOLDING     IDLE
+ * IDLE     IDLE                   IDLE        IDLE
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  INVALID_CALL_ID
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE 15
+#define RIL_REQUEST_SWITCH_HOLDING_AND_ACTIVE 15
+
+/**
+ * RIL_REQUEST_CONFERENCE
+ *
+ * Conference holding and active (like AT+CHLD=3)
+
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_STATE
+ *  INVALID_CALL_ID
+ *  INVALID_ARGUMENTS
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_CONFERENCE 16
+
+/**
+ * RIL_REQUEST_UDUB
+ *
+ * Send UDUB (user determined used busy) to ringing or
+ * waiting call answer)(RIL_BasicRequest r);
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  OPERATION_NOT_ALLOWED
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_UDUB 17
+
+/**
+ * RIL_REQUEST_LAST_CALL_FAIL_CAUSE
+ *
+ * Requests the failure cause code for the most recently terminated call
+ *
+ * "data" is NULL
+ * "response" is a "int *"
+ * ((int *)response)[0] is RIL_LastCallFailCause.  GSM failure reasons are
+ * mapped to cause codes defined in TS 24.008 Annex H where possible. CDMA
+ * failure reasons are derived from the possible call failure scenarios
+ * described in the "CDMA IS-2000 Release A (C.S0005-A v6.0)" standard.
+ *
+ * The implementation should return CALL_FAIL_ERROR_UNSPECIFIED for blocked
+ * MO calls by restricted state (See RIL_UNSOL_RESTRICTED_STATE_CHANGED)
+ *
+ * If the implementation does not have access to the exact cause codes,
+ * then it should return one of the values listed in RIL_LastCallFailCause,
+ * as the UI layer needs to distinguish these cases for tone generation or
+ * error notification.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  NO_MEMORY
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE
+ */
+#define RIL_REQUEST_LAST_CALL_FAIL_CAUSE 18
+
+/**
+ * RIL_REQUEST_SIGNAL_STRENGTH
+ *
+ * Requests current signal strength and associated information
+ *
+ * Must succeed if radio is on.
+ *
+ * "data" is NULL
+ *
+ * "response" is a const RIL_SignalStrength *
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ */
+#define RIL_REQUEST_SIGNAL_STRENGTH 19
+
+/**
+ * RIL_REQUEST_VOICE_REGISTRATION_STATE
+ *
+ * Request current registration state
+ *
+ * "data" is NULL
+ * "response" is a "char **"
+ * ((const char **)response)[0] is registration state 0-6,
+ *              0 - Not registered, MT is not currently searching
+ *                  a new operator to register
+ *              1 - Registered, home network
+ *              2 - Not registered, but MT is currently searching
+ *                  a new operator to register
+ *              3 - Registration denied
+ *              4 - Unknown
+ *              5 - Registered, roaming
+ *             10 - Same as 0, but indicates that emergency calls
+ *                  are enabled.
+ *             12 - Same as 2, but indicates that emergency calls
+ *                  are enabled.
+ *             13 - Same as 3, but indicates that emergency calls
+ *                  are enabled.
+ *             14 - Same as 4, but indicates that emergency calls
+ *                  are enabled.
+ *
+ * ((const char **)response)[1] is LAC if registered on a GSM/WCDMA system or
+ *                              NULL if not.Valid LAC are 0x0000 - 0xffff
+ * ((const char **)response)[2] is CID if registered on a * GSM/WCDMA or
+ *                              NULL if not.
+ *                                 Valid CID are 0x00000000 - 0xffffffff
+ *                                    In GSM, CID is Cell ID (see TS 27.007)
+ *                                            in 16 bits
+ *                                    In UMTS, CID is UMTS Cell Identity
+ *                                             (see TS 25.331) in 28 bits
+ * ((const char **)response)[3] indicates the available voice radio technology,
+ *                              valid values as defined by RIL_RadioTechnology.
+ * ((const char **)response)[4] is Base Station ID if registered on a CDMA
+ *                              system or NULL if not.  Base Station ID in
+ *                              decimal format
+ * ((const char **)response)[5] is Base Station latitude if registered on a
+ *                              CDMA system or NULL if not. Base Station
+ *                              latitude is a decimal number as specified in
+ *                              3GPP2 C.S0005-A v6.0. It is represented in
+ *                              units of 0.25 seconds and ranges from -1296000
+ *                              to 1296000, both values inclusive (corresponding
+ *                              to a range of -90 to +90 degrees).
+ * ((const char **)response)[6] is Base Station longitude if registered on a
+ *                              CDMA system or NULL if not. Base Station
+ *                              longitude is a decimal number as specified in
+ *                              3GPP2 C.S0005-A v6.0. It is represented in
+ *                              units of 0.25 seconds and ranges from -2592000
+ *                              to 2592000, both values inclusive (corresponding
+ *                              to a range of -180 to +180 degrees).
+ * ((const char **)response)[7] is concurrent services support indicator if
+ *                              registered on a CDMA system 0-1.
+ *                                   0 - Concurrent services not supported,
+ *                                   1 - Concurrent services supported
+ * ((const char **)response)[8] is System ID if registered on a CDMA system or
+ *                              NULL if not. Valid System ID are 0 - 32767
+ * ((const char **)response)[9] is Network ID if registered on a CDMA system or
+ *                              NULL if not. Valid System ID are 0 - 65535
+ * ((const char **)response)[10] is the TSB-58 Roaming Indicator if registered
+ *                               on a CDMA or EVDO system or NULL if not. Valid values
+ *                               are 0-255.
+ * ((const char **)response)[11] indicates whether the current system is in the
+ *                               PRL if registered on a CDMA or EVDO system or NULL if
+ *                               not. 0=not in the PRL, 1=in the PRL
+ * ((const char **)response)[12] is the default Roaming Indicator from the PRL,
+ *                               if registered on a CDMA or EVDO system or NULL if not.
+ *                               Valid values are 0-255.
+ * ((const char **)response)[13] if registration state is 3 (Registration
+ *                               denied) this is an enumerated reason why
+ *                               registration was denied.  See 3GPP TS 24.008,
+ *                               10.5.3.6 and Annex G.
+ *                                 0 - General
+ *                                 1 - Authentication Failure
+ *                                 2 - IMSI unknown in HLR
+ *                                 3 - Illegal MS
+ *                                 4 - Illegal ME
+ *                                 5 - PLMN not allowed
+ *                                 6 - Location area not allowed
+ *                                 7 - Roaming not allowed
+ *                                 8 - No Suitable Cells in this Location Area
+ *                                 9 - Network failure
+ *                                10 - Persistent location update reject
+ *                                11 - PLMN not allowed
+ *                                12 - Location area not allowed
+ *                                13 - Roaming not allowed in this Location Area
+ *                                15 - No Suitable Cells in this Location Area
+ *                                17 - Network Failure
+ *                                20 - MAC Failure
+ *                                21 - Sync Failure
+ *                                22 - Congestion
+ *                                23 - GSM Authentication unacceptable
+ *                                25 - Not Authorized for this CSG
+ *                                32 - Service option not supported
+ *                                33 - Requested service option not subscribed
+ *                                34 - Service option temporarily out of order
+ *                                38 - Call cannot be identified
+ *                                48-63 - Retry upon entry into a new cell
+ *                                95 - Semantically incorrect message
+ *                                96 - Invalid mandatory information
+ *                                97 - Message type non-existent or not implemented
+ *                                98 - Message not compatible with protocol state
+ *                                99 - Information element non-existent or not implemented
+ *                               100 - Conditional IE error
+ *                               101 - Message not compatible with protocol state
+ *                               111 - Protocol error, unspecified
+ * ((const char **)response)[14] is the Primary Scrambling Code of the current
+ *                               cell as described in TS 25.331, in hexadecimal
+ *                               format, or NULL if unknown or not registered
+ *                               to a UMTS network.
+ *
+ * Please note that registration state 4 ("unknown") is treated
+ * as "out of service" in the Android telephony system
+ *
+ * Registration state 3 can be returned if Location Update Reject
+ * (with cause 17 - Network Failure) is received repeatedly from the network,
+ * to facilitate "managed roaming"
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_VOICE_REGISTRATION_STATE 20
+
+/**
+ * RIL_REQUEST_DATA_REGISTRATION_STATE
+ *
+ * Request current DATA registration state
+ *
+ * "data" is NULL
+ * "response" is a "char **"
+ * ((const char **)response)[0] is registration state 0-5 from TS 27.007 10.1.20 AT+CGREG
+ * ((const char **)response)[1] is LAC if registered or NULL if not
+ * ((const char **)response)[2] is CID if registered or NULL if not
+ * ((const char **)response)[3] indicates the available data radio technology,
+ *                              valid values as defined by RIL_RadioTechnology.
+ * ((const char **)response)[4] if registration state is 3 (Registration
+ *                               denied) this is an enumerated reason why
+ *                               registration was denied.  See 3GPP TS 24.008,
+ *                               Annex G.6 "Additonal cause codes for GMM".
+ *      7 == GPRS services not allowed
+ *      8 == GPRS services and non-GPRS services not allowed
+ *      9 == MS identity cannot be derived by the network
+ *      10 == Implicitly detached
+ *      14 == GPRS services not allowed in this PLMN
+ *      16 == MSC temporarily not reachable
+ *      40 == No PDP context activated
+ * ((const char **)response)[5] The maximum number of simultaneous Data Calls that can be
+ *                              established using RIL_REQUEST_SETUP_DATA_CALL.
+ *
+ * The values at offsets 6..10 are optional LTE location information in decimal.
+ * If a value is unknown that value may be NULL. If all values are NULL,
+ * none need to be present.
+ *  ((const char **)response)[6] is TAC, a 16-bit Tracking Area Code.
+ *  ((const char **)response)[7] is CID, a 0-503 Physical Cell Identifier.
+ *  ((const char **)response)[8] is ECI, a 28-bit E-UTRAN Cell Identifier.
+ *  ((const char **)response)[9] is CSGID, a 27-bit Closed Subscriber Group Identity.
+ *  ((const char **)response)[10] is TADV, a 6-bit timing advance value.
+ *
+ * LAC and CID are in hexadecimal format.
+ * valid LAC are 0x0000 - 0xffff
+ * valid CID are 0x00000000 - 0x0fffffff
+ *
+ * Please note that registration state 4 ("unknown") is treated
+ * as "out of service" in the Android telephony system
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_DATA_REGISTRATION_STATE 21
+
+/**
+ * RIL_REQUEST_OPERATOR
+ *
+ * Request current operator ONS or EONS
+ *
+ * "data" is NULL
+ * "response" is a "const char **"
+ * ((const char **)response)[0] is long alpha ONS or EONS
+ *                                  or NULL if unregistered
+ *
+ * ((const char **)response)[1] is short alpha ONS or EONS
+ *                                  or NULL if unregistered
+ * ((const char **)response)[2] is 5 or 6 digit numeric code (MCC + MNC)
+ *                                  or NULL if unregistered
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_OPERATOR 22
+
+/**
+ * RIL_REQUEST_RADIO_POWER
+ *
+ * Toggle radio on and off (for "airplane" mode)
+ * If the radio is is turned off/on the radio modem subsystem
+ * is expected return to an initialized state. For instance,
+ * any voice and data calls will be terminated and all associated
+ * lists emptied.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is > 0 for "Radio On"
+ * ((int *)data)[0] is == 0 for "Radio Off"
+ *
+ * "response" is NULL
+ *
+ * Turn radio on if "on" > 0
+ * Turn radio off if "on" == 0
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_RADIO_POWER 23
+
+/**
+ * RIL_REQUEST_DTMF
+ *
+ * Send a DTMF tone
+ *
+ * If the implementation is currently playing a tone requested via
+ * RIL_REQUEST_DTMF_START, that tone should be cancelled and the new tone
+ * should be played instead
+ *
+ * "data" is a char * containing a single character with one of 12 values: 0-9,*,#
+ * "response" is NULL
+ *
+ * FIXME should this block/mute microphone?
+ * How does this interact with local DTMF feedback?
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_DTMF_STOP, RIL_REQUEST_DTMF_START
+ *
+ */
+#define RIL_REQUEST_DTMF 24
+
+/**
+ * RIL_REQUEST_SEND_SMS
+ *
+ * Send an SMS message
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is SMSC address in GSM BCD format prefixed
+ *      by a length byte (as expected by TS 27.005) or NULL for default SMSC
+ * ((const char **)data)[1] is SMS in PDU format as an ASCII hex string
+ *      less the SMSC address
+ *      TP-Layer-Length is be "strlen(((const char **)data)[1])/2"
+ *
+ * "response" is a const RIL_SMS_Response *
+ *
+ * Based on the return error, caller decides to resend if sending sms
+ * fails. SMS_SEND_FAIL_RETRY means retry (i.e. error cause is 332)
+ * and GENERIC_FAILURE means no retry (i.e. error cause is 500)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SMS_SEND_FAIL_RETRY
+ *  FDN_CHECK_FAILURE
+ *  NETWORK_REJECT
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  INVALID_SMS_FORMAT
+ *  SYSTEM_ERR
+ *  ENCODING_ERR
+ *  INVALID_SMSC_ADDRESS
+ *  MODEM_ERR
+ *  NETWORK_ERR
+ *  MODE_NOT_SUPPORTED
+ *  GENERIC_FAILURE
+ *
+ * FIXME how do we specify TP-Message-Reference if we need to resend?
+ */
+#define RIL_REQUEST_SEND_SMS 25
+
+
+/**
+ * RIL_REQUEST_SEND_SMS_EXPECT_MORE
+ *
+ * Send an SMS message. Identical to RIL_REQUEST_SEND_SMS,
+ * except that more messages are expected to be sent soon. If possible,
+ * keep SMS relay protocol link open (eg TS 27.005 AT+CMMS command)
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is SMSC address in GSM BCD format prefixed
+ *      by a length byte (as expected by TS 27.005) or NULL for default SMSC
+ * ((const char **)data)[1] is SMS in PDU format as an ASCII hex string
+ *      less the SMSC address
+ *      TP-Layer-Length is be "strlen(((const char **)data)[1])/2"
+ *
+ * "response" is a const RIL_SMS_Response *
+ *
+ * Based on the return error, caller decides to resend if sending sms
+ * fails. SMS_SEND_FAIL_RETRY means retry (i.e. error cause is 332)
+ * and GENERIC_FAILURE means no retry (i.e. error cause is 500)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SMS_SEND_FAIL_RETRY
+ *  NETWORK_REJECT
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  INVALID_SMS_FORMAT
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  FDN_CHECK_FAILURE
+ *  MODEM_ERR
+ *  NETWORK_ERR
+ *  ENCODING_ERR
+ *  INVALID_SMSC_ADDRESS
+ *  MODE_NOT_SUPPORTED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_SEND_SMS_EXPECT_MORE 26
+
+
+/**
+ * RIL_REQUEST_SETUP_DATA_CALL
+ *
+ * Setup a packet data connection. If RIL_Data_Call_Response_v6.status
+ * return success it is added to the list of data calls and a
+ * RIL_UNSOL_DATA_CALL_LIST_CHANGED is sent. The call remains in the
+ * list until RIL_REQUEST_DEACTIVATE_DATA_CALL is issued or the
+ * radio is powered off/on. This list is returned by RIL_REQUEST_DATA_CALL_LIST
+ * and RIL_UNSOL_DATA_CALL_LIST_CHANGED.
+ *
+ * The RIL is expected to:
+ *  - Create one data call context.
+ *  - Create and configure a dedicated interface for the context
+ *  - The interface must be point to point.
+ *  - The interface is configured with one or more addresses and
+ *    is capable of sending and receiving packets. The prefix length
+ *    of the addresses must be /32 for IPv4 and /128 for IPv6.
+ *  - Must NOT change the linux routing table.
+ *  - Support up to RIL_REQUEST_DATA_REGISTRATION_STATE response[5]
+ *    number of simultaneous data call contexts.
+ *
+ * "data" is a const char **
+ * ((const char **)data)[0] Radio technology to use: 0-CDMA, 1-GSM/UMTS, 2...
+ *                          for values above 2 this is RIL_RadioTechnology + 2.
+ * ((const char **)data)[1] is a RIL_DataProfile (support is optional)
+ * ((const char **)data)[2] is the APN to connect to if radio technology is GSM/UMTS. This APN will
+ *                          override the one in the profile. NULL indicates no APN overrride.
+ * ((const char **)data)[3] is the username for APN, or NULL
+ * ((const char **)data)[4] is the password for APN, or NULL
+ * ((const char **)data)[5] is the PAP / CHAP auth type. Values:
+ *                          0 => PAP and CHAP is never performed.
+ *                          1 => PAP may be performed; CHAP is never performed.
+ *                          2 => CHAP may be performed; PAP is never performed.
+ *                          3 => PAP / CHAP may be performed - baseband dependent.
+ * ((const char **)data)[6] is the connection type to request must be one of the
+ *                          PDP_type values in TS 27.007 section 10.1.1.
+ *                          For example, "IP", "IPV6", "IPV4V6", or "PPP".
+ * ((const char **)data)[7] Optional connection property parameters, format to be defined.
+ *
+ * "response" is a RIL_Data_Call_Response_v11
+ *
+ * FIXME may need way to configure QoS settings
+ *
+ * Valid errors:
+ *  SUCCESS should be returned on both success and failure of setup with
+ *  the RIL_Data_Call_Response_v6.status containing the actual status.
+ *  For all other errors the RIL_Data_Call_Resonse_v6 is ignored.
+ *
+ *  Other errors could include:
+ *    RADIO_NOT_AVAILABLE, GENERIC_FAILURE, OP_NOT_ALLOWED_BEFORE_REG_TO_NW,
+ *    OP_NOT_ALLOWED_DURING_VOICE_CALL and REQUEST_NOT_SUPPORTED.
+ *
+ * See also: RIL_REQUEST_DEACTIVATE_DATA_CALL
+ */
+#define RIL_REQUEST_SETUP_DATA_CALL 27
+
+
+/**
+ * RIL_REQUEST_SIM_IO
+ *
+ * Request SIM I/O operation.
+ * This is similar to the TS 27.007 "restricted SIM" operation
+ * where it assumes all of the EF selection will be done by the
+ * callee.
+ *
+ * "data" is a const RIL_SIM_IO_v6 *
+ * Please note that RIL_SIM_IO has a "PIN2" field which may be NULL,
+ * or may specify a PIN2 for operations that require a PIN2 (eg
+ * updating FDN records)
+ *
+ * "response" is a const RIL_SIM_IO_Response *
+ *
+ * Arguments and responses that are unused for certain
+ * values of "command" should be ignored or set to NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  SIM_PIN2
+ *  SIM_PUK2
+ */
+#define RIL_REQUEST_SIM_IO 28
+
+/**
+ * RIL_REQUEST_SEND_USSD
+ *
+ * Send a USSD message
+ *
+ * If a USSD session already exists, the message should be sent in the
+ * context of that session. Otherwise, a new session should be created.
+ *
+ * The network reply should be reported via RIL_UNSOL_ON_USSD
+ *
+ * Only one USSD session may exist at a time, and the session is assumed
+ * to exist until:
+ *   a) The android system invokes RIL_REQUEST_CANCEL_USSD
+ *   b) The implementation sends a RIL_UNSOL_ON_USSD with a type code
+ *      of "0" (USSD-Notify/no further action) or "2" (session terminated)
+ *
+ * "data" is a const char * containing the USSD request in UTF-8 format
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  FDN_CHECK_FAILURE
+ *  USSD_MODIFIED_TO_DIAL
+ *  USSD_MODIFIED_TO_SS
+ *  USSD_MODIFIED_TO_USSD
+ *  SIM_BUSY
+ *  OPERATION_NOT_ALLOWED
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  ABORTED
+ *  SYSTEM_ERR
+ *  INVALID_STATE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_CANCEL_USSD, RIL_UNSOL_ON_USSD
+ */
+
+#define RIL_REQUEST_SEND_USSD 29
+
+/**
+ * RIL_REQUEST_CANCEL_USSD
+ *
+ * Cancel the current USSD session if one exists
+ *
+ * "data" is null
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SIM_BUSY
+ *  OPERATION_NOT_ALLOWED
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_STATE
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_CANCEL_USSD 30
+
+/**
+ * RIL_REQUEST_GET_CLIR
+ *
+ * Gets current CLIR status
+ * "data" is NULL
+ * "response" is int *
+ * ((int *)data)[0] is "n" parameter from TS 27.007 7.7
+ * ((int *)data)[1] is "m" parameter from TS 27.007 7.7
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  FDN_CHECK_FAILURE
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_GET_CLIR 31
+
+/**
+ * RIL_REQUEST_SET_CLIR
+ *
+ * "data" is int *
+ * ((int *)data)[0] is "n" parameter from TS 27.007 7.7
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_CLIR 32
+
+/**
+ * RIL_REQUEST_QUERY_CALL_FORWARD_STATUS
+ *
+ * "data" is const RIL_CallForwardInfo *
+ *
+ * "response" is const RIL_CallForwardInfo **
+ * "response" points to an array of RIL_CallForwardInfo *'s, one for
+ * each distinct registered phone number.
+ *
+ * For example, if data is forwarded to +18005551212 and voice is forwarded
+ * to +18005559999, then two separate RIL_CallForwardInfo's should be returned
+ *
+ * If, however, both data and voice are forwarded to +18005551212, then
+ * a single RIL_CallForwardInfo can be returned with the service class
+ * set to "data + voice = 3")
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_QUERY_CALL_FORWARD_STATUS 33
+
+
+/**
+ * RIL_REQUEST_SET_CALL_FORWARD
+ *
+ * Configure call forward rule
+ *
+ * "data" is const RIL_CallForwardInfo *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_STATE
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_CALL_FORWARD 34
+
+
+/**
+ * RIL_REQUEST_QUERY_CALL_WAITING
+ *
+ * Query current call waiting state
+ *
+ * "data" is const int *
+ * ((const int *)data)[0] is the TS 27.007 service class to query.
+ * "response" is a const int *
+ * ((const int *)response)[0] is 0 for "disabled" and 1 for "enabled"
+ *
+ * If ((const int *)response)[0] is = 1, then ((const int *)response)[1]
+ * must follow, with the TS 27.007 service class bit vector of services
+ * for which call waiting is enabled.
+ *
+ * For example, if ((const int *)response)[0]  is 1 and
+ * ((const int *)response)[1] is 3, then call waiting is enabled for data
+ * and voice and disabled for everything else
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  FDN_CHECK_FAILURE
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_QUERY_CALL_WAITING 35
+
+
+/**
+ * RIL_REQUEST_SET_CALL_WAITING
+ *
+ * Configure current call waiting state
+ *
+ * "data" is const int *
+ * ((const int *)data)[0] is 0 for "disabled" and 1 for "enabled"
+ * ((const int *)data)[1] is the TS 27.007 service class bit vector of
+ *                           services to modify
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_STATE
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_CALL_WAITING 36
+
+/**
+ * RIL_REQUEST_SMS_ACKNOWLEDGE
+ *
+ * Acknowledge successful or failed receipt of SMS previously indicated
+ * via RIL_UNSOL_RESPONSE_NEW_SMS
+ *
+ * "data" is int *
+ * ((int *)data)[0] is 1 on successful receipt
+ *                  (basically, AT+CNMA=1 from TS 27.005
+ *                  is 0 on failed receipt
+ *                  (basically, AT+CNMA=2 from TS 27.005)
+ * ((int *)data)[1] if data[0] is 0, this contains the failure cause as defined
+ *                  in TS 23.040, 9.2.3.22. Currently only 0xD3 (memory
+ *                  capacity exceeded) and 0xFF (unspecified error) are
+ *                  reported.
+ *
+ * "response" is NULL
+ *
+ * FIXME would like request that specified RP-ACK/RP-ERROR PDU
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SMS_ACKNOWLEDGE  37
+
+/**
+ * RIL_REQUEST_GET_IMEI - DEPRECATED
+ *
+ * Get the device IMEI, including check digit
+ *
+ * The request is DEPRECATED, use RIL_REQUEST_DEVICE_IDENTITY
+ * Valid when RadioState is not RADIO_STATE_UNAVAILABLE
+ *
+ * "data" is NULL
+ * "response" is a const char * containing the IMEI
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_GET_IMEI 38
+
+/**
+ * RIL_REQUEST_GET_IMEISV - DEPRECATED
+ *
+ * Get the device IMEISV, which should be two decimal digits
+ *
+ * The request is DEPRECATED, use RIL_REQUEST_DEVICE_IDENTITY
+ * Valid when RadioState is not RADIO_STATE_UNAVAILABLE
+ *
+ * "data" is NULL
+ * "response" is a const char * containing the IMEISV
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_GET_IMEISV 39
+
+
+/**
+ * RIL_REQUEST_ANSWER
+ *
+ * Answer incoming call
+ *
+ * Will not be called for WAITING calls.
+ * RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE will be used in this case
+ * instead
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_ANSWER 40
+
+/**
+ * RIL_REQUEST_DEACTIVATE_DATA_CALL
+ *
+ * Deactivate packet data connection and remove from the
+ * data call list if SUCCESS is returned. Any other return
+ * values should also try to remove the call from the list,
+ * but that may not be possible. In any event a
+ * RIL_REQUEST_RADIO_POWER off/on must clear the list. An
+ * RIL_UNSOL_DATA_CALL_LIST_CHANGED is not expected to be
+ * issued because of an RIL_REQUEST_DEACTIVATE_DATA_CALL.
+ *
+ * "data" is const char **
+ * ((char**)data)[0] indicating CID
+ * ((char**)data)[1] indicating Disconnect Reason
+ *                   0 => No specific reason specified
+ *                   1 => Radio shutdown requested
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_SETUP_DATA_CALL
+ */
+#define RIL_REQUEST_DEACTIVATE_DATA_CALL 41
+
+/**
+ * RIL_REQUEST_QUERY_FACILITY_LOCK
+ *
+ * Query the status of a facility lock state
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is the facility string code from TS 27.007 7.4
+ *                      (eg "AO" for BAOC, "SC" for SIM lock)
+ * ((const char **)data)[1] is the password, or "" if not required
+ * ((const char **)data)[2] is the TS 27.007 service class bit vector of
+ *                           services to query
+ * ((const char **)data)[3] is AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *                            This is only applicable in the case of Fixed Dialing Numbers
+ *                            (FDN) requests.
+ *
+ * "response" is an int *
+ * ((const int *)response) 0 is the TS 27.007 service class bit vector of
+ *                           services for which the specified barring facility
+ *                           is active. "0" means "disabled for all"
+ *
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  INTERNAL_ERR
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_QUERY_FACILITY_LOCK 42
+
+/**
+ * RIL_REQUEST_SET_FACILITY_LOCK
+ *
+ * Enable/disable one facility lock
+ *
+ * "data" is const char **
+ *
+ * ((const char **)data)[0] = facility string code from TS 27.007 7.4
+ * (eg "AO" for BAOC)
+ * ((const char **)data)[1] = "0" for "unlock" and "1" for "lock"
+ * ((const char **)data)[2] = password
+ * ((const char **)data)[3] = string representation of decimal TS 27.007
+ *                            service class bit vector. Eg, the string
+ *                            "1" means "set this facility for voice services"
+ * ((const char **)data)[4] = AID value, See ETSI 102.221 8.1 and 101.220 4, NULL if no value.
+ *                            This is only applicable in the case of Fixed Dialing Numbers
+ *                            (FDN) requests.
+ *
+ * "response" is int *
+ * ((int *)response)[0] is the number of retries remaining, or -1 if unknown
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INVALID_STATE
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_SET_FACILITY_LOCK 43
+
+/**
+ * RIL_REQUEST_CHANGE_BARRING_PASSWORD
+ *
+ * Change call barring facility password
+ *
+ * "data" is const char **
+ *
+ * ((const char **)data)[0] = facility string code from TS 27.007 7.4
+ * (eg "AO" for BAOC)
+ * ((const char **)data)[1] = old password
+ * ((const char **)data)[2] = new password
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  SYSTEM_ERR
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CHANGE_BARRING_PASSWORD 44
+
+/**
+ * RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE
+ *
+ * Query current network selectin mode
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((const int *)response)[0] is
+ *     0 for automatic selection
+ *     1 for manual selection
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE 45
+
+/**
+ * RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC
+ *
+ * Specify that the network should be selected automatically
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * This request must not respond until the new operator is selected
+ * and registered
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  ILLEGAL_SIM_OR_ME
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ *
+ * Note: Returns ILLEGAL_SIM_OR_ME when the failure is permanent and
+ *       no retries needed, such as illegal SIM or ME.
+ *       Returns GENERIC_FAILURE for all other causes that might be
+ *       fixed by retries.
+ *
+ */
+#define RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC 46
+
+/**
+ * RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL
+ *
+ * Manually select a specified network.
+ *
+ * "data" is const char * specifying MCCMNC of network to select (eg "310170")
+ * "response" is NULL
+ *
+ * This request must not respond until the new operator is selected
+ * and registered
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  ILLEGAL_SIM_OR_ME
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ *
+ * Note: Returns ILLEGAL_SIM_OR_ME when the failure is permanent and
+ *       no retries needed, such as illegal SIM or ME.
+ *       Returns GENERIC_FAILURE for all other causes that might be
+ *       fixed by retries.
+ *
+ */
+#define RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL 47
+
+/**
+ * RIL_REQUEST_QUERY_AVAILABLE_NETWORKS
+ *
+ * Scans for available networks
+ *
+ * "data" is NULL
+ * "response" is const char ** that should be an array of n*4 strings, where
+ *    n is the number of available networks
+ * For each available network:
+ *
+ * ((const char **)response)[n+0] is long alpha ONS or EONS
+ * ((const char **)response)[n+1] is short alpha ONS or EONS
+ * ((const char **)response)[n+2] is 5 or 6 digit numeric code (MCC + MNC)
+ * ((const char **)response)[n+3] is a string value of the status:
+ *           "unknown"
+ *           "available"
+ *           "current"
+ *           "forbidden"
+ *
+ * This request must not respond until the new operator is selected
+ * and registered
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_QUERY_AVAILABLE_NETWORKS 48
+
+/**
+ * RIL_REQUEST_DTMF_START
+ *
+ * Start playing a DTMF tone. Continue playing DTMF tone until
+ * RIL_REQUEST_DTMF_STOP is received
+ *
+ * If a RIL_REQUEST_DTMF_START is received while a tone is currently playing,
+ * it should cancel the previous tone and play the new one.
+ *
+ * "data" is a char *
+ * ((char *)data)[0] is a single character with one of 12 values: 0-9,*,#
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_DTMF, RIL_REQUEST_DTMF_STOP
+ */
+#define RIL_REQUEST_DTMF_START 49
+
+/**
+ * RIL_REQUEST_DTMF_STOP
+ *
+ * Stop playing a currently playing DTMF tone.
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  INVALID_ARGUMENTS
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_DTMF, RIL_REQUEST_DTMF_START
+ */
+#define RIL_REQUEST_DTMF_STOP 50
+
+/**
+ * RIL_REQUEST_BASEBAND_VERSION
+ *
+ * Return string value indicating baseband version, eg
+ * response from AT+CGMR
+ *
+ * "data" is NULL
+ * "response" is const char * containing version string for log reporting
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  EMPTY_RECORD
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_BASEBAND_VERSION 51
+
+/**
+ * RIL_REQUEST_SEPARATE_CONNECTION
+ *
+ * Separate a party from a multiparty call placing the multiparty call
+ * (less the specified party) on hold and leaving the specified party
+ * as the only other member of the current (active) call
+ *
+ * Like AT+CHLD=2x
+ *
+ * See TS 22.084 1.3.8.2 (iii)
+ * TS 22.030 6.5.5 "Entering "2X followed by send"
+ * TS 27.007 "AT+CHLD=2x"
+ *
+ * "data" is an int *
+ * (int *)data)[0] contains Connection index (value of 'x' in CHLD above) "response" is NULL
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_ARGUMENTS
+ *  INVALID_STATE
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  INVALID_STATE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SEPARATE_CONNECTION 52
+
+
+/**
+ * RIL_REQUEST_SET_MUTE
+ *
+ * Turn on or off uplink (microphone) mute.
+ *
+ * Will only be sent while voice call is active.
+ * Will always be reset to "disable mute" when a new voice call is initiated
+ *
+ * "data" is an int *
+ * (int *)data)[0] is 1 for "enable mute" and 0 for "disable mute"
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_SET_MUTE 53
+
+/**
+ * RIL_REQUEST_GET_MUTE
+ *
+ * Queries the current state of the uplink mute setting
+ *
+ * "data" is NULL
+ * "response" is an int *
+ * (int *)response)[0] is 1 for "mute enabled" and 0 for "mute disabled"
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  SS_MODIFIED_TO_DIAL
+ *  SS_MODIFIED_TO_USSD
+ *  SS_MODIFIED_TO_SS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_GET_MUTE 54
+
+/**
+ * RIL_REQUEST_QUERY_CLIP
+ *
+ * Queries the status of the CLIP supplementary service
+ *
+ * (for MMI code "*#30#")
+ *
+ * "data" is NULL
+ * "response" is an int *
+ * (int *)response)[0] is 1 for "CLIP provisioned"
+ *                           and 0 for "CLIP not provisioned"
+ *                           and 2 for "unknown, e.g. no network etc"
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  FDN_CHECK_FAILURE
+ *  GENERIC_FAILURE
+ */
+
+#define RIL_REQUEST_QUERY_CLIP 55
+
+/**
+ * RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE - Deprecated use the status
+ * field in RIL_Data_Call_Response_v6.
+ *
+ * Requests the failure cause code for the most recently failed PDP
+ * context or CDMA data connection active
+ * replaces RIL_REQUEST_LAST_PDP_FAIL_CAUSE
+ *
+ * "data" is NULL
+ *
+ * "response" is a "int *"
+ * ((int *)response)[0] is an integer cause code defined in TS 24.008
+ *   section 6.1.3.1.3 or close approximation
+ *
+ * If the implementation does not have access to the exact cause codes,
+ * then it should return one of the values listed in
+ * RIL_DataCallFailCause, as the UI layer needs to distinguish these
+ * cases for error notification
+ * and potential retries.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_LAST_CALL_FAIL_CAUSE
+ *
+ * Deprecated use the status field in RIL_Data_Call_Response_v6.
+ */
+
+#define RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE 56
+
+/**
+ * RIL_REQUEST_DATA_CALL_LIST
+ *
+ * Returns the data call list. An entry is added when a
+ * RIL_REQUEST_SETUP_DATA_CALL is issued and removed on a
+ * RIL_REQUEST_DEACTIVATE_DATA_CALL. The list is emptied
+ * when RIL_REQUEST_RADIO_POWER off/on is issued.
+ *
+ * "data" is NULL
+ * "response" is an array of RIL_Data_Call_Response_v6
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_UNSOL_DATA_CALL_LIST_CHANGED
+ */
+
+#define RIL_REQUEST_DATA_CALL_LIST 57
+
+/**
+ * RIL_REQUEST_RESET_RADIO - DEPRECATED
+ *
+ * Request a radio reset. The RIL implementation may postpone
+ * the reset until after this request is responded to if the baseband
+ * is presently busy.
+ *
+ * The request is DEPRECATED, use RIL_REQUEST_RADIO_POWER
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  REQUEST_NOT_SUPPORTED
+ */
+
+#define RIL_REQUEST_RESET_RADIO 58
+
+/**
+ * RIL_REQUEST_OEM_HOOK_RAW
+ *
+ * This request reserved for OEM-specific uses. It passes raw byte arrays
+ * back and forth.
+ *
+ * It can be invoked on the Java side from
+ * com.android.internal.telephony.Phone.invokeOemRilRequestRaw()
+ *
+ * "data" is a char * of bytes copied from the byte[] data argument in java
+ * "response" is a char * of bytes that will returned via the
+ * caller's "response" Message here:
+ * (byte[])(((AsyncResult)response.obj).result)
+ *
+ * An error response here will result in
+ * (((AsyncResult)response.obj).result) == null and
+ * (((AsyncResult)response.obj).exception) being an instance of
+ * com.android.internal.telephony.gsm.CommandException
+ *
+ * Valid errors:
+ *  All
+ */
+
+#define RIL_REQUEST_OEM_HOOK_RAW 59
+
+/**
+ * RIL_REQUEST_OEM_HOOK_STRINGS
+ *
+ * This request reserved for OEM-specific uses. It passes strings
+ * back and forth.
+ *
+ * It can be invoked on the Java side from
+ * com.android.internal.telephony.Phone.invokeOemRilRequestStrings()
+ *
+ * "data" is a const char **, representing an array of null-terminated UTF-8
+ * strings copied from the "String[] strings" argument to
+ * invokeOemRilRequestStrings()
+ *
+ * "response" is a const char **, representing an array of null-terminated UTF-8
+ * stings that will be returned via the caller's response message here:
+ *
+ * (String[])(((AsyncResult)response.obj).result)
+ *
+ * An error response here will result in
+ * (((AsyncResult)response.obj).result) == null and
+ * (((AsyncResult)response.obj).exception) being an instance of
+ * com.android.internal.telephony.gsm.CommandException
+ *
+ * Valid errors:
+ *  All
+ */
+
+#define RIL_REQUEST_OEM_HOOK_STRINGS 60
+
+/**
+ * RIL_REQUEST_SCREEN_STATE
+ *
+ * Indicates the current state of the screen.  When the screen is off, the
+ * RIL should notify the baseband to suppress certain notifications (eg,
+ * signal strength and changes in LAC/CID or BID/SID/NID/latitude/longitude)
+ * in an effort to conserve power.  These notifications should resume when the
+ * screen is on.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 1 for "Screen On"
+ * ((int *)data)[0] is == 0 for "Screen Off"
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SCREEN_STATE 61
+
+
+/**
+ * RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION
+ *
+ * Enables/disables supplementary service related notifications
+ * from the network.
+ *
+ * Notifications are reported via RIL_UNSOL_SUPP_SVC_NOTIFICATION.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 1 for notifications enabled
+ * ((int *)data)[0] is == 0 for notifications disabled
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SIM_BUSY
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_UNSOL_SUPP_SVC_NOTIFICATION.
+ */
+#define RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION 62
+
+/**
+ * RIL_REQUEST_WRITE_SMS_TO_SIM
+ *
+ * Stores a SMS message to SIM memory.
+ *
+ * "data" is RIL_SMS_WriteArgs *
+ *
+ * "response" is int *
+ * ((const int *)response)[0] is the record index where the message is stored.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  SIM_FULL
+ *  INVALID_ARGUMENTS
+ *  INVALID_SMS_FORMAT
+ *  INTERNAL_ERR
+ *  MODEM_ERR
+ *  ENCODING_ERR
+ *  NO_MEMORY
+ *  NO_RESOURCES
+ *  INVALID_MODEM_STATE
+ *  MODE_NOT_SUPPORTED
+ *  INVALID_SMSC_ADDRESS
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_WRITE_SMS_TO_SIM 63
+
+/**
+ * RIL_REQUEST_DELETE_SMS_ON_SIM
+ *
+ * Deletes a SMS message from SIM memory.
+ *
+ * "data" is int  *
+ * ((int *)data)[0] is the record index of the message to delete.
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  SIM_FULL
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  NO_SUCH_ENTRY
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_DELETE_SMS_ON_SIM 64
+
+/**
+ * RIL_REQUEST_SET_BAND_MODE
+ *
+ * Assign a specified band for RF configuration.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is a RIL_RadioBandMode
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE
+ */
+#define RIL_REQUEST_SET_BAND_MODE 65
+
+/**
+ * RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE
+ *
+ * Query the list of band mode supported by RF.
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * "response" points to an array of int's, the int[0] is the size of array;
+ * subsequent values are a list of RIL_RadioBandMode listing supported modes.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_SET_BAND_MODE
+ */
+#define RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE 66
+
+/**
+ * RIL_REQUEST_STK_GET_PROFILE
+ *
+ * Requests the profile of SIM tool kit.
+ * The profile indicates the SAT/USAT features supported by ME.
+ * The SAT/USAT features refer to 3GPP TS 11.14 and 3GPP TS 31.111
+ *
+ * "data" is NULL
+ *
+ * "response" is a const char * containing SAT/USAT profile
+ * in hexadecimal format string starting with first byte of terminal profile
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_GET_PROFILE 67
+
+/**
+ * RIL_REQUEST_STK_SET_PROFILE
+ *
+ * Download the STK terminal profile as part of SIM initialization
+ * procedure
+ *
+ * "data" is a const char * containing SAT/USAT profile
+ * in hexadecimal format string starting with first byte of terminal profile
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_SET_PROFILE 68
+
+/**
+ * RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND
+ *
+ * Requests to send a SAT/USAT envelope command to SIM.
+ * The SAT/USAT envelope command refers to 3GPP TS 11.14 and 3GPP TS 31.111
+ *
+ * "data" is a const char * containing SAT/USAT command
+ * in hexadecimal format string starting with command tag
+ *
+ * "response" is a const char * containing SAT/USAT response
+ * in hexadecimal format string starting with first byte of response
+ * (May be NULL)
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  SIM_BUSY
+ *  OPERATION_NOT_ALLOWED
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND 69
+
+/**
+ * RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE
+ *
+ * Requests to send a terminal response to SIM for a received
+ * proactive command
+ *
+ * "data" is a const char * containing SAT/USAT response
+ * in hexadecimal format string starting with first byte of response data
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  RIL_E_OPERATION_NOT_ALLOWED
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE 70
+
+/**
+ * RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM
+ *
+ * When STK application gets RIL_UNSOL_STK_CALL_SETUP, the call actually has
+ * been initialized by ME already. (We could see the call has been in the 'call
+ * list') So, STK application needs to accept/reject the call according as user
+ * operations.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is > 0 for "accept" the call setup
+ * ((int *)data)[0] is == 0 for "reject" the call setup
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  RIL_E_OPERATION_NOT_ALLOWED
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM 71
+
+/**
+ * RIL_REQUEST_EXPLICIT_CALL_TRANSFER
+ *
+ * Connects the two calls and disconnects the subscriber from both calls.
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  INVALID_STATE
+ *  NO_RESOURCES
+ *  NO_MEMORY
+ *  INVALID_ARGUMENTS
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  INVALID_STATE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_EXPLICIT_CALL_TRANSFER 72
+
+/**
+ * RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE
+ *
+ * Requests to set the preferred network type for searching and registering
+ * (CS/PS domain, RAT, and operation mode)
+ *
+ * "data" is int * which is RIL_PreferredNetworkType
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  OPERATION_NOT_ALLOWED
+ *  MODE_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE 73
+
+/**
+ * RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE
+ *
+ * Query the preferred network type (CS/PS domain, RAT, and operation mode)
+ * for searching and registering
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)reponse)[0] is == RIL_PreferredNetworkType
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE
+ */
+#define RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE 74
+
+/**
+ * RIL_REQUEST_NEIGHBORING_CELL_IDS
+ *
+ * Request neighboring cell id in GSM network
+ *
+ * "data" is NULL
+ * "response" must be a " const RIL_NeighboringCell** "
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_GET_NEIGHBORING_CELL_IDS 75
+
+/**
+ * RIL_REQUEST_SET_LOCATION_UPDATES
+ *
+ * Enables/disables network state change notifications due to changes in
+ * LAC and/or CID (for GSM) or BID/SID/NID/latitude/longitude (for CDMA).
+ * Basically +CREG=2 vs. +CREG=1 (TS 27.007).
+ *
+ * Note:  The RIL implementation should default to "updates enabled"
+ * when the screen is on and "updates disabled" when the screen is off.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 1 for updates enabled (+CREG=2)
+ * ((int *)data)[0] is == 0 for updates disabled (+CREG=1)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_REQUEST_SCREEN_STATE, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED
+ */
+#define RIL_REQUEST_SET_LOCATION_UPDATES 76
+
+/**
+ * RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE
+ *
+ * Request to set the location where the CDMA subscription shall
+ * be retrieved
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == RIL_CdmaSubscriptionSource
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  SIM_ABSENT
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ *
+ * See also: RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
+ */
+#define RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE 77
+
+/**
+ * RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE
+ *
+ * Request to set the roaming preferences in CDMA
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 0 for Home Networks only, as defined in PRL
+ * ((int *)data)[0] is == 1 for Roaming on Affiliated networks, as defined in PRL
+ * ((int *)data)[0] is == 2 for Roaming on Any Network, as defined in the PRL
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE 78
+
+/**
+ * RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE
+ *
+ * Request the actual setting of the roaming preferences in CDMA in the modem
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)response)[0] is == 0 for Home Networks only, as defined in PRL
+ * ((int *)response)[0] is == 1 for Roaming on Affiliated networks, as defined in PRL
+ * ((int *)response)[0] is == 2 for Roaming on Any Network, as defined in the PRL
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE 79
+
+/**
+ * RIL_REQUEST_SET_TTY_MODE
+ *
+ * Request to set the TTY mode
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 0 for TTY off
+ * ((int *)data)[0] is == 1 for TTY Full
+ * ((int *)data)[0] is == 2 for TTY HCO (hearing carryover)
+ * ((int *)data)[0] is == 3 for TTY VCO (voice carryover)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMOR
+ *  INVALID_ARGUMENTS
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORYY
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_TTY_MODE 80
+
+/**
+ * RIL_REQUEST_QUERY_TTY_MODE
+ *
+ * Request the setting of TTY mode
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)response)[0] is == 0 for TTY off
+ * ((int *)response)[0] is == 1 for TTY Full
+ * ((int *)response)[0] is == 2 for TTY HCO (hearing carryover)
+ * ((int *)response)[0] is == 3 for TTY VCO (voice carryover)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_QUERY_TTY_MODE 81
+
+/**
+ * RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE
+ *
+ * Request to set the preferred voice privacy mode used in voice
+ * scrambling
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == 0 for Standard Privacy Mode (Public Long Code Mask)
+ * ((int *)data)[0] is == 1 for Enhanced Privacy Mode (Private Long Code Mask)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE 82
+
+/**
+ * RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE
+ *
+ * Request the setting of preferred voice privacy mode
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)response)[0] is == 0 for Standard Privacy Mode (Public Long Code Mask)
+ * ((int *)response)[0] is == 1 for Enhanced Privacy Mode (Private Long Code Mask)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  NO_MEMORY
+ *  INVALID_ARGUMENTS
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE 83
+
+/**
+ * RIL_REQUEST_CDMA_FLASH
+ *
+ * Send FLASH
+ *
+ * "data" is const char *
+ * ((const char *)data)[0] is a FLASH string
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  INVALID_STATE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_FLASH 84
+
+/**
+ * RIL_REQUEST_CDMA_BURST_DTMF
+ *
+ * Send DTMF string
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is a DTMF string
+ * ((const char **)data)[1] is the DTMF ON length in milliseconds, or 0 to use
+ *                          default
+ * ((const char **)data)[2] is the DTMF OFF length in milliseconds, or 0 to use
+ *                          default
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INTERNAL_ERR
+ *  INVALID_CALL_ID
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_BURST_DTMF 85
+
+/**
+ * RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY
+ *
+ * Takes a 26 digit string (20 digit AKEY + 6 digit checksum).
+ * If the checksum is valid the 20 digit AKEY is written to NV,
+ * replacing the existing AKEY no matter what it was before.
+ *
+ * "data" is const char *
+ * ((const char *)data)[0] is a 26 digit string (ASCII digits '0'-'9')
+ *                         where the last 6 digits are a checksum of the
+ *                         first 20, as specified in TR45.AHAG
+ *                         "Common Cryptographic Algorithms, Revision D.1
+ *                         Section 2.2"
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY 86
+
+/**
+ * RIL_REQUEST_CDMA_SEND_SMS
+ *
+ * Send a CDMA SMS message
+ *
+ * "data" is const RIL_CDMA_SMS_Message *
+ *
+ * "response" is a const RIL_SMS_Response *
+ *
+ * Based on the return error, caller decides to resend if sending sms
+ * fails. The CDMA error class is derived as follows,
+ * SUCCESS is error class 0 (no error)
+ * SMS_SEND_FAIL_RETRY is error class 2 (temporary failure)
+ * and GENERIC_FAILURE is error class 3 (permanent and no retry)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SMS_SEND_FAIL_RETRY
+ *  NETWORK_REJECT
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  INVALID_SMS_FORMAT
+ *  SYSTEM_ERR
+ *  FDN_CHECK_FAILURE
+ *  MODEM_ERR
+ *  NETWORK_ERR
+ *  ENCODING_ERR
+ *  INVALID_SMSC_ADDRESS
+ *  MODE_NOT_SUPPORTED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_SEND_SMS 87
+
+/**
+ * RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE
+ *
+ * Acknowledge the success or failure in the receipt of SMS
+ * previously indicated via RIL_UNSOL_RESPONSE_CDMA_NEW_SMS
+ *
+ * "data" is const RIL_CDMA_SMS_Ack *
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_SMS_TO_ACK
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  INVALID_STATE
+ *  MODE_NOT_SUPPORTED
+ *  NETWORK_NOT_READY
+ *  INVALID_MODEM_STATE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE 88
+
+/**
+ * RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG
+ *
+ * Request the setting of GSM/WCDMA Cell Broadcast SMS config.
+ *
+ * "data" is NULL
+ *
+ * "response" is a const RIL_GSM_BroadcastSmsConfigInfo **
+ * "responselen" is count * sizeof (RIL_GSM_BroadcastSmsConfigInfo *)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  NO_RESOURCES
+ *  MODEM_ERR
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG 89
+
+/**
+ * RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG
+ *
+ * Set GSM/WCDMA Cell Broadcast SMS config
+ *
+ * "data" is a const RIL_GSM_BroadcastSmsConfigInfo **
+ * "datalen" is count * sizeof(RIL_GSM_BroadcastSmsConfigInfo *)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG 90
+
+/**
+ * RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION
+ *
+* Enable or disable the reception of GSM/WCDMA Cell Broadcast SMS
+ *
+ * "data" is const int *
+ * (const int *)data[0] indicates to activate or turn off the
+ * reception of GSM/WCDMA Cell Broadcast SMS, 0-1,
+ *                       0 - Activate, 1 - Turn off
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION 91
+
+/**
+ * RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG
+ *
+ * Request the setting of CDMA Broadcast SMS config
+ *
+ * "data" is NULL
+ *
+ * "response" is a const RIL_CDMA_BroadcastSmsConfigInfo **
+ * "responselen" is count * sizeof (RIL_CDMA_BroadcastSmsConfigInfo *)
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  NO_RESOURCES
+ *  MODEM_ERR
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG 92
+
+/**
+ * RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG
+ *
+ * Set CDMA Broadcast SMS config
+ *
+ * "data" is an const RIL_CDMA_BroadcastSmsConfigInfo **
+ * "datalen" is count * sizeof(const RIL_CDMA_BroadcastSmsConfigInfo *)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  SYSTEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG 93
+
+/**
+ * RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION
+ *
+ * Enable or disable the reception of CDMA Broadcast SMS
+ *
+ * "data" is const int *
+ * (const int *)data[0] indicates to activate or turn off the
+ * reception of CDMA Broadcast SMS, 0-1,
+ *                       0 - Activate, 1 - Turn off
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_STATE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION 94
+
+/**
+ * RIL_REQUEST_CDMA_SUBSCRIPTION
+ *
+ * Request the device MDN / H_SID / H_NID.
+ *
+ * The request is only allowed when CDMA subscription is available.  When CDMA
+ * subscription is changed, application layer should re-issue the request to
+ * update the subscription information.
+ *
+ * If a NULL value is returned for any of the device id, it means that error
+ * accessing the device.
+ *
+ * "response" is const char **
+ * ((const char **)response)[0] is MDN if CDMA subscription is available
+ * ((const char **)response)[1] is a comma separated list of H_SID (Home SID) if
+ *                              CDMA subscription is available, in decimal format
+ * ((const char **)response)[2] is a comma separated list of H_NID (Home NID) if
+ *                              CDMA subscription is available, in decimal format
+ * ((const char **)response)[3] is MIN (10 digits, MIN2+MIN1) if CDMA subscription is available
+ * ((const char **)response)[4] is PRL version if CDMA subscription is available
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RIL_E_SUBSCRIPTION_NOT_AVAILABLE
+ */
+
+#define RIL_REQUEST_CDMA_SUBSCRIPTION 95
+
+/**
+ * RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM
+ *
+ * Stores a CDMA SMS message to RUIM memory.
+ *
+ * "data" is RIL_CDMA_SMS_WriteArgs *
+ *
+ * "response" is int *
+ * ((const int *)response)[0] is the record index where the message is stored.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SIM_FULL
+ *  INVALID_ARGUMENTS
+ *  INVALID_SMS_FORMAT
+ *  INTERNAL_ERR
+ *  MODEM_ERR
+ *  ENCODING_ERR
+ *  NO_MEMORY
+ *  NO_RESOURCES
+ *  INVALID_MODEM_STATE
+ *  MODE_NOT_SUPPORTED
+ *  INVALID_SMSC_ADDRESS
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM 96
+
+/**
+ * RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM
+ *
+ * Deletes a CDMA SMS message from RUIM memory.
+ *
+ * "data" is int  *
+ * ((int *)data)[0] is the record index of the message to delete.
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  MODEM_ERR
+ *  NO_SUCH_ENTRY
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM 97
+
+/**
+ * RIL_REQUEST_DEVICE_IDENTITY
+ *
+ * Request the device ESN / MEID / IMEI / IMEISV.
+ *
+ * The request is always allowed and contains GSM and CDMA device identity;
+ * it substitutes the deprecated requests RIL_REQUEST_GET_IMEI and
+ * RIL_REQUEST_GET_IMEISV.
+ *
+ * If a NULL value is returned for any of the device id, it means that error
+ * accessing the device.
+ *
+ * When CDMA subscription is changed the ESN/MEID may change.  The application
+ * layer should re-issue the request to update the device identity in this case.
+ *
+ * "response" is const char **
+ * ((const char **)response)[0] is IMEI if GSM subscription is available
+ * ((const char **)response)[1] is IMEISV if GSM subscription is available
+ * ((const char **)response)[2] is ESN if CDMA subscription is available
+ * ((const char **)response)[3] is MEID if CDMA subscription is available
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_DEVICE_IDENTITY 98
+
+/**
+ * RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE
+ *
+ * Request the radio's system selection module to exit emergency
+ * callback mode.  RIL will not respond with SUCCESS until the modem has
+ * completely exited from Emergency Callback Mode.
+ *
+ * "data" is NULL
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE 99
+
+/**
+ * RIL_REQUEST_GET_SMSC_ADDRESS
+ *
+ * Queries the default Short Message Service Center address on the device.
+ *
+ * "data" is NULL
+ *
+ * "response" is const char * containing the SMSC address.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  NO_MEMORY
+ *  REQUEST_RATE_LIMITED
+ *  SYSTEM_ERR
+ *  INTERNAL_ERR
+ *  MODEM_ERR
+ *  INVALID_ARGUMENTS
+ *  INVALID_MODEM_STATE
+ *  NOT_PROVISIONED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_GET_SMSC_ADDRESS 100
+
+/**
+ * RIL_REQUEST_SET_SMSC_ADDRESS
+ *
+ * Sets the default Short Message Service Center address on the device.
+ *
+ * "data" is const char * containing the SMSC address.
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  INVALID_SMS_FORMAT
+ *  NO_MEMORY
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  NO_RESOURCES
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_SET_SMSC_ADDRESS 101
+
+/**
+ * RIL_REQUEST_REPORT_SMS_MEMORY_STATUS
+ *
+ * Indicates whether there is storage available for new SMS messages.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is 1 if memory is available for storing new messages
+ *                  is 0 if memory capacity is exceeded
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  INVALID_ARGUMENTS
+ *  NO_MEMORY
+ *  INVALID_STATE
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_REPORT_SMS_MEMORY_STATUS 102
+
+/**
+ * RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING
+ *
+ * Indicates that the StkSerivce is running and is
+ * ready to receive RIL_UNSOL_STK_XXXXX commands.
+ *
+ * "data" is NULL
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING 103
+
+/**
+ * RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
+ *
+ * Request to query the location where the CDMA subscription shall
+ * be retrieved
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)data)[0] is == RIL_CdmaSubscriptionSource
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ *
+ * See also: RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE
+ */
+#define RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE 104
+
+/**
+ * RIL_REQUEST_ISIM_AUTHENTICATION
+ *
+ * Request the ISIM application on the UICC to perform AKA
+ * challenge/response algorithm for IMS authentication
+ *
+ * "data" is a const char * containing the challenge string in Base64 format
+ * "response" is a const char * containing the response in Base64 format
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_ISIM_AUTHENTICATION 105
+
+/**
+ * RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU
+ *
+ * Acknowledge successful or failed receipt of SMS previously indicated
+ * via RIL_UNSOL_RESPONSE_NEW_SMS, including acknowledgement TPDU to send
+ * as the RP-User-Data element of the RP-ACK or RP-ERROR PDU.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] is "1" on successful receipt (send RP-ACK)
+ *                          is "0" on failed receipt (send RP-ERROR)
+ * ((const char **)data)[1] is the acknowledgement TPDU in hexadecimal format
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU 106
+
+/**
+ * RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS
+ *
+ * Requests to send a SAT/USAT envelope command to SIM.
+ * The SAT/USAT envelope command refers to 3GPP TS 11.14 and 3GPP TS 31.111.
+ *
+ * This request has one difference from RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
+ * the SW1 and SW2 status bytes from the UICC response are returned along with
+ * the response data, using the same structure as RIL_REQUEST_SIM_IO.
+ *
+ * The RIL implementation shall perform the normal processing of a '91XX'
+ * response in SW1/SW2 to retrieve the pending proactive command and send it
+ * as an unsolicited response, as RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND does.
+ *
+ * "data" is a const char * containing the SAT/USAT command
+ * in hexadecimal format starting with command tag
+ *
+ * "response" is a const RIL_SIM_IO_Response *
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE (radio resetting)
+ *  SIM_BUSY
+ *  OPERATION_NOT_ALLOWED
+ *  RIL_E_GENERIC_FAILURE
+ */
+#define RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS 107
+
+/**
+ * RIL_REQUEST_VOICE_RADIO_TECH
+ *
+ * Query the radio technology type (3GPP/3GPP2) used for voice. Query is valid only
+ * when radio state is RADIO_STATE_ON
+ *
+ * "data" is NULL
+ * "response" is int *
+ * ((int *) response)[0] is of type const RIL_RadioTechnology
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_VOICE_RADIO_TECH 108
+
+/**
+ * RIL_REQUEST_GET_CELL_INFO_LIST
+ *
+ * Request all of the current cell information known to the radio. The radio
+ * must a list of all current cells, including the neighboring cells. If for a particular
+ * cell information isn't known then the appropriate unknown value will be returned.
+ * This does not cause or change the rate of RIL_UNSOL_CELL_INFO_LIST.
+ *
+ * "data" is NULL
+ *
+ * "response" is an array of  RIL_CellInfo_v12.
+ */
+#define RIL_REQUEST_GET_CELL_INFO_LIST 109
+
+/**
+ * RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE
+ *
+ * Sets the minimum time between when RIL_UNSOL_CELL_INFO_LIST should be invoked.
+ * A value of 0, means invoke RIL_UNSOL_CELL_INFO_LIST when any of the reported
+ * information changes. Setting the value to INT_MAX(0x7fffffff) means never issue
+ * a RIL_UNSOL_CELL_INFO_LIST.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is minimum time in milliseconds
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE 110
+
+/**
+ * RIL_REQUEST_SET_INITIAL_ATTACH_APN
+ *
+ * Set an apn to initial attach network
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ */
+#define RIL_REQUEST_SET_INITIAL_ATTACH_APN 111
+
+/**
+ * RIL_REQUEST_IMS_REGISTRATION_STATE
+ *
+ * Request current IMS registration state
+ *
+ * "data" is NULL
+ *
+ * "response" is int *
+ * ((int *)response)[0] is registration state:
+ *              0 - Not registered
+ *              1 - Registered
+ *
+ * If ((int*)response)[0] is = 1, then ((int *) response)[1]
+ * must follow with IMS SMS format:
+ *
+ * ((int *) response)[1] is of type RIL_RadioTechnologyFamily
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_IMS_REGISTRATION_STATE 112
+
+/**
+ * RIL_REQUEST_IMS_SEND_SMS
+ *
+ * Send a SMS message over IMS
+ *
+ * "data" is const RIL_IMS_SMS_Message *
+ *
+ * "response" is a const RIL_SMS_Response *
+ *
+ * Based on the return error, caller decides to resend if sending sms
+ * fails. SMS_SEND_FAIL_RETRY means retry, and other errors means no retry.
+ * In case of retry, data is encoded based on Voice Technology available.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  SMS_SEND_FAIL_RETRY
+ *  FDN_CHECK_FAILURE
+ *  NETWORK_REJECT
+ *  INVALID_ARGUMENTS
+ *  INVALID_STATE
+ *  NO_MEMORY
+ *  INVALID_SMS_FORMAT
+ *  SYSTEM_ERR
+ *  REQUEST_RATE_LIMITED
+ *  MODEM_ERR
+ *  NETWORK_ERR
+ *  ENCODING_ERR
+ *  INVALID_SMSC_ADDRESS
+ *  MODE_NOT_SUPPORTED
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_IMS_SEND_SMS 113
+
+/**
+ * RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC
+ *
+ * Request APDU exchange on the basic channel. This command reflects TS 27.007
+ * "generic SIM access" operation (+CSIM). The modem must ensure proper function
+ * of GSM/CDMA, and filter commands appropriately. It should filter
+ * channel management and SELECT by DF name commands.
+ *
+ * "data" is a const RIL_SIM_APDU *
+ * "sessionid" field should be ignored.
+ *
+ * "response" is a const RIL_SIM_IO_Response *
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC 114
+
+/**
+ * RIL_REQUEST_SIM_OPEN_CHANNEL
+ *
+ * Open a new logical channel and select the given application. This command
+ * reflects TS 27.007 "open logical channel" operation (+CCHO).
+ *
+ * "data" is const char * and set to AID value, See ETSI 102.221 and 101.220.
+ *
+ * "response" is int *
+ * ((int *)data)[0] contains the session id of the logical channel.
+ * ((int *)data)[1] onwards may optionally contain the select response for the
+ *     open channel command with one byte per integer.
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *  MISSING_RESOURCE
+ *  NO_SUCH_ELEMENT
+ */
+#define RIL_REQUEST_SIM_OPEN_CHANNEL 115
+
+/**
+ * RIL_REQUEST_SIM_CLOSE_CHANNEL
+ *
+ * Close a previously opened logical channel. This command reflects TS 27.007
+ * "close logical channel" operation (+CCHC).
+ *
+ * "data" is int *
+ * ((int *)data)[0] is the session id of logical the channel to close.
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SIM_CLOSE_CHANNEL 116
+
+/**
+ * RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL
+ *
+ * Exchange APDUs with a UICC over a previously opened logical channel. This
+ * command reflects TS 27.007 "generic logical channel access" operation
+ * (+CGLA). The modem should filter channel management and SELECT by DF name
+ * commands.
+ *
+ * "data" is a const RIL_SIM_APDU*
+ *
+ * "response" is a const RIL_SIM_IO_Response *
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL 117
+
+/**
+ * RIL_REQUEST_NV_READ_ITEM
+ *
+ * Read one of the radio NV items defined in RadioNVItems.java / ril_nv_items.h.
+ * This is used for device configuration by some CDMA operators.
+ *
+ * "data" is a const RIL_NV_ReadItem *
+ *
+ * "response" is const char * containing the contents of the NV item
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_NV_READ_ITEM 118
+
+/**
+ * RIL_REQUEST_NV_WRITE_ITEM
+ *
+ * Write one of the radio NV items defined in RadioNVItems.java / ril_nv_items.h.
+ * This is used for device configuration by some CDMA operators.
+ *
+ * "data" is a const RIL_NV_WriteItem *
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_NV_WRITE_ITEM 119
+
+/**
+ * RIL_REQUEST_NV_WRITE_CDMA_PRL
+ *
+ * Update the CDMA Preferred Roaming List (PRL) in the radio NV storage.
+ * This is used for device configuration by some CDMA operators.
+ *
+ * "data" is a const char * containing the PRL as a byte array
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_NV_WRITE_CDMA_PRL 120
+
+/**
+ * RIL_REQUEST_NV_RESET_CONFIG
+ *
+ * Reset the radio NV configuration to the factory state.
+ * This is used for device configuration by some CDMA operators.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is 1 to reload all NV items
+ * ((int *)data)[0] is 2 for erase NV reset (SCRTN)
+ * ((int *)data)[0] is 3 for factory reset (RTN)
+ *
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_NV_RESET_CONFIG 121
+
+ /** RIL_REQUEST_SET_UICC_SUBSCRIPTION
+ * FIXME This API needs to have more documentation.
+ *
+ * Selection/de-selection of a subscription from a SIM card
+ * "data" is const  RIL_SelectUiccSub*
+
+ *
+ * "response" is NULL
+ *
+ *  Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_SUPPORTED
+ *
+ */
+#define RIL_REQUEST_SET_UICC_SUBSCRIPTION  122
+
+/**
+ *  RIL_REQUEST_ALLOW_DATA
+ *
+ *  Tells the modem whether data calls are allowed or not
+ *
+ * "data" is int *
+ * FIXME slotId and aid will be added.
+ * ((int *)data)[0] is == 0 to allow data calls
+ * ((int *)data)[0] is == 1 to disallow data calls
+ *
+ * "response" is NULL
+ *
+ *  Valid errors:
+ *
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *
+ */
+#define RIL_REQUEST_ALLOW_DATA  123
+
+/**
+ * RIL_REQUEST_GET_HARDWARE_CONFIG
+ *
+ * Request all of the current hardware (modem and sim) associated
+ * with the RIL.
+ *
+ * "data" is NULL
+ *
+ * "response" is an array of  RIL_HardwareConfig.
+ */
+#define RIL_REQUEST_GET_HARDWARE_CONFIG 124
+
+/**
+ * RIL_REQUEST_SIM_AUTHENTICATION
+ *
+ * Returns the response of SIM Authentication through RIL to a
+ * challenge request.
+ *
+ * "data" Base64 encoded string containing challenge:
+ *      int   authContext;          P2 value of authentication command, see P2 parameter in
+ *                                  3GPP TS 31.102 7.1.2
+ *      char *authData;             the challenge string in Base64 format, see 3GPP
+ *                                  TS 31.102 7.1.2
+ *      char *aid;                  AID value, See ETSI 102.221 8.1 and 101.220 4,
+ *                                  NULL if no value
+ *
+ * "response" Base64 encoded strings containing response:
+ *      int   sw1;                  Status bytes per 3GPP TS 31.102 section 7.3
+ *      int   sw2;
+ *      char *simResponse;          Response in Base64 format, see 3GPP TS 31.102 7.1.2
+ */
+#define RIL_REQUEST_SIM_AUTHENTICATION 125
+
+/**
+ * RIL_REQUEST_GET_DC_RT_INFO
+ *
+ * The request is DEPRECATED, use RIL_REQUEST_GET_ACTIVITY_INFO
+ * Requests the Data Connection Real Time Info
+ *
+ * "data" is NULL
+ *
+ * "response" is the most recent RIL_DcRtInfo
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  GENERIC_FAILURE
+ *
+ * See also: RIL_UNSOL_DC_RT_INFO_CHANGED
+ */
+#define RIL_REQUEST_GET_DC_RT_INFO 126
+
+/**
+ * RIL_REQUEST_SET_DC_RT_INFO_RATE
+ *
+ * The request is DEPRECATED
+ * This is the minimum number of milliseconds between successive
+ * RIL_UNSOL_DC_RT_INFO_CHANGED messages and defines the highest rate
+ * at which RIL_UNSOL_DC_RT_INFO_CHANGED's will be sent. A value of
+ * 0 means send as fast as possible.
+ *
+ * "data" The number of milliseconds as an int
+ *
+ * "response" is null
+ *
+ * Valid errors:
+ *  SUCCESS must not fail
+ */
+#define RIL_REQUEST_SET_DC_RT_INFO_RATE 127
+
+/**
+ * RIL_REQUEST_SET_DATA_PROFILE
+ *
+ * Set data profile in modem
+ * Modem should erase existed profiles from framework, and apply new profiles
+ * "data" is an const RIL_DataProfileInfo **
+ * "datalen" is count * sizeof(const RIL_DataProfileInfo *)
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE (radio resetting)
+ *  GENERIC_FAILURE
+ *  SUBSCRIPTION_NOT_AVAILABLE
+ */
+#define RIL_REQUEST_SET_DATA_PROFILE 128
+
+/**
+ * RIL_REQUEST_SHUTDOWN
+ *
+ * Device is shutting down. All further commands are ignored
+ * and RADIO_NOT_AVAILABLE must be returned.
+ *
+ * "data" is null
+ * "response" is NULL
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SHUTDOWN 129
+
+/**
+ * RIL_REQUEST_GET_RADIO_CAPABILITY
+ *
+ * Used to get phone radio capablility.
+ *
+ * "data" is the RIL_RadioCapability structure
+ *
+ * Valid errors:
+ *  SUCCESS
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_GET_RADIO_CAPABILITY 130
+
+/**
+ * RIL_REQUEST_SET_RADIO_CAPABILITY
+ *
+ * Used to set the phones radio capability. Be VERY careful
+ * using this request as it may cause some vendor modems to reset. Because
+ * of the possible modem reset any RIL commands after this one may not be
+ * processed.
+ *
+ * "data" is the RIL_RadioCapability structure
+ *
+ * "response" is the RIL_RadioCapability structure, used to feedback return status
+ *
+ * Valid errors:
+ *  SUCCESS means a RIL_UNSOL_RADIO_CAPABILITY will be sent within 30 seconds.
+ *  RADIO_NOT_AVAILABLE
+ *  OPERATION_NOT_ALLOWED
+ *  GENERIC_FAILURE
+ */
+#define RIL_REQUEST_SET_RADIO_CAPABILITY 131
+
+/**
+ * RIL_REQUEST_START_LCE
+ *
+ * Start Link Capacity Estimate (LCE) service if supported by the radio.
+ *
+ * "data" is const int *
+ * ((const int*)data)[0] specifies the desired reporting interval (ms).
+ * ((const int*)data)[1] specifies the LCE service mode. 1: PULL; 0: PUSH.
+ *
+ * "response" is the RIL_LceStatusInfo.
+ *
+ * Valid errors:
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE
+ * LCE_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_START_LCE 132
+
+/**
+ * RIL_REQUEST_STOP_LCE
+ *
+ * Stop Link Capacity Estimate (LCE) service, the STOP operation should be
+ * idempotent for the radio modem.
+ *
+ * "response" is the RIL_LceStatusInfo.
+ *
+ * Valid errors:
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE
+ * LCE_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_STOP_LCE 133
+
+/**
+ * RIL_REQUEST_PULL_LCEDATA
+ *
+ * Pull LCE service for capacity information.
+ *
+ * "response" is the RIL_LceDataInfo.
+ *
+ * Valid errors:
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE
+ * LCE_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_PULL_LCEDATA 134
+
+/**
+ * RIL_REQUEST_GET_ACTIVITY_INFO
+ *
+ * Get modem activity information for power consumption estimation.
+ *
+ * Request clear-on-read statistics information that is used for
+ * estimating the per-millisecond power consumption of the cellular
+ * modem.
+ *
+ * "data" is null
+ * "response" is const RIL_ActivityStatsInfo *
+ *
+ * Valid errors:
+ *
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE (radio resetting)
+ * GENERIC_FAILURE
+ */
+#define RIL_REQUEST_GET_ACTIVITY_INFO 135
+
+/**
+ * RIL_REQUEST_SET_CARRIER_RESTRICTIONS
+ *
+ * Set carrier restrictions for this sim slot. Expected modem behavior:
+ *  If never receives this command
+ *  - Must allow all carriers
+ *  Receives this command with data being NULL
+ *  - Must allow all carriers. If a previously allowed SIM is present, modem must not reload
+ *    the SIM. If a previously disallowed SIM is present, reload the SIM and notify Android.
+ *  Receives this command with a list of carriers
+ *  - Only allow specified carriers, persist across power cycles and FDR. If a present SIM
+ *    is in the allowed list, modem must not reload the SIM. If a present SIM is *not* in
+ *    the allowed list, modem must detach from the registered network and only keep emergency
+ *    service, and notify Android SIM refresh reset with new SIM state being
+ *    RIL_CARDSTATE_RESTRICTED. Emergency service must be enabled.
+ *
+ * "data" is const RIL_CarrierRestrictions *
+ * A list of allowed carriers and possibly a list of excluded carriers.
+ * If data is NULL, means to clear previous carrier restrictions and allow all carriers
+ *
+ * "response" is int *
+ * ((int *)data)[0] contains the number of allowed carriers which have been set correctly.
+ * On success, it should match the length of list data->allowed_carriers.
+ * If data is NULL, the value must be 0.
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_INVALID_ARGUMENTS
+ *  RIL_E_RADIO_NOT_AVAILABLE
+ *  RIL_E_REQUEST_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_SET_CARRIER_RESTRICTIONS 136
+
+/**
+ * RIL_REQUEST_GET_CARRIER_RESTRICTIONS
+ *
+ * Get carrier restrictions for this sim slot. Expected modem behavior:
+ *  Return list of allowed carriers, or null if all carriers are allowed.
+ *
+ * "data" is NULL
+ *
+ * "response" is const RIL_CarrierRestrictions *.
+ * If response is NULL, it means all carriers are allowed.
+ *
+ * Valid errors:
+ *  RIL_E_SUCCESS
+ *  RIL_E_RADIO_NOT_AVAILABLE
+ *  RIL_E_REQUEST_NOT_SUPPORTED
+ */
+#define RIL_REQUEST_GET_CARRIER_RESTRICTIONS 137
+
+/***********************************************************************/
+
+/**
+ * RIL_RESPONSE_ACKNOWLEDGEMENT
+ *
+ * This is used by Asynchronous solicited messages and Unsolicited messages
+ * to acknowledge the receipt of those messages in RIL.java so that the ack
+ * can be used to let ril.cpp to release wakelock.
+ *
+ * Valid errors
+ * SUCCESS
+ * RADIO_NOT_AVAILABLE
+ */
+
+#define RIL_RESPONSE_ACKNOWLEDGEMENT 800
+
+/***********************************************************************/
+
+
+#define RIL_UNSOL_RESPONSE_BASE 1000
+
+/**
+ * RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED
+ *
+ * Indicate when value of RIL_RadioState has changed.
+ *
+ * Callee will invoke RIL_RadioStateRequest method on main thread
+ *
+ * "data" is NULL
+ */
+
+#define RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED 1000
+
+
+/**
+ * RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED
+ *
+ * Indicate when call state has changed
+ *
+ * Callee will invoke RIL_REQUEST_GET_CURRENT_CALLS on main thread
+ *
+ * "data" is NULL
+ *
+ * Response should be invoked on, for example,
+ * "RING", "BUSY", "NO CARRIER", and also call state
+ * transitions (DIALING->ALERTING ALERTING->ACTIVE)
+ *
+ * Redundent or extraneous invocations are tolerated
+ */
+#define RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED 1001
+
+
+/**
+ * RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED
+ *
+ * Called when the voice network state changed
+ *
+ * Callee will invoke the following requests on main thread:
+ *
+ * RIL_REQUEST_VOICE_REGISTRATION_STATE
+ * RIL_REQUEST_OPERATOR
+ *
+ * "data" is NULL
+ *
+ * FIXME should this happen when SIM records are loaded? (eg, for
+ * EONS)
+ */
+#define RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED 1002
+
+/**
+ * RIL_UNSOL_RESPONSE_NEW_SMS
+ *
+ * Called when new SMS is received.
+ *
+ * "data" is const char *
+ * This is a pointer to a string containing the PDU of an SMS-DELIVER
+ * as an ascii string of hex digits. The PDU starts with the SMSC address
+ * per TS 27.005 (+CMT:)
+ *
+ * Callee will subsequently confirm the receipt of thei SMS with a
+ * RIL_REQUEST_SMS_ACKNOWLEDGE
+ *
+ * No new RIL_UNSOL_RESPONSE_NEW_SMS
+ * or RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT messages should be sent until a
+ * RIL_REQUEST_SMS_ACKNOWLEDGE has been received
+ */
+
+#define RIL_UNSOL_RESPONSE_NEW_SMS 1003
+
+/**
+ * RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT
+ *
+ * Called when new SMS Status Report is received.
+ *
+ * "data" is const char *
+ * This is a pointer to a string containing the PDU of an SMS-STATUS-REPORT
+ * as an ascii string of hex digits. The PDU starts with the SMSC address
+ * per TS 27.005 (+CDS:).
+ *
+ * Callee will subsequently confirm the receipt of the SMS with a
+ * RIL_REQUEST_SMS_ACKNOWLEDGE
+ *
+ * No new RIL_UNSOL_RESPONSE_NEW_SMS
+ * or RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT messages should be sent until a
+ * RIL_REQUEST_SMS_ACKNOWLEDGE has been received
+ */
+
+#define RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT 1004
+
+/**
+ * RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM
+ *
+ * Called when new SMS has been stored on SIM card
+ *
+ * "data" is const int *
+ * ((const int *)data)[0] contains the slot index on the SIM that contains
+ * the new message
+ */
+
+#define RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM 1005
+
+/**
+ * RIL_UNSOL_ON_USSD
+ *
+ * Called when a new USSD message is received.
+ *
+ * "data" is const char **
+ * ((const char **)data)[0] points to a type code, which is
+ *  one of these string values:
+ *      "0"   USSD-Notify -- text in ((const char **)data)[1]
+ *      "1"   USSD-Request -- text in ((const char **)data)[1]
+ *      "2"   Session terminated by network
+ *      "3"   other local client (eg, SIM Toolkit) has responded
+ *      "4"   Operation not supported
+ *      "5"   Network timeout
+ *
+ * The USSD session is assumed to persist if the type code is "1", otherwise
+ * the current session (if any) is assumed to have terminated.
+ *
+ * ((const char **)data)[1] points to a message string if applicable, which
+ * should always be in UTF-8.
+ */
+#define RIL_UNSOL_ON_USSD 1006
+/* Previously #define RIL_UNSOL_ON_USSD_NOTIFY 1006   */
+
+/**
+ * RIL_UNSOL_ON_USSD_REQUEST
+ *
+ * Obsolete. Send via RIL_UNSOL_ON_USSD
+ */
+#define RIL_UNSOL_ON_USSD_REQUEST 1007
+
+/**
+ * RIL_UNSOL_NITZ_TIME_RECEIVED
+ *
+ * Called when radio has received a NITZ time message
+ *
+ * "data" is const char * pointing to NITZ time string
+ * in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
+ */
+#define RIL_UNSOL_NITZ_TIME_RECEIVED  1008
+
+/**
+ * RIL_UNSOL_SIGNAL_STRENGTH
+ *
+ * Radio may report signal strength rather han have it polled.
+ *
+ * "data" is a const RIL_SignalStrength *
+ */
+#define RIL_UNSOL_SIGNAL_STRENGTH  1009
+
+
+/**
+ * RIL_UNSOL_DATA_CALL_LIST_CHANGED
+ *
+ * "data" is an array of RIL_Data_Call_Response_v6 identical to that
+ * returned by RIL_REQUEST_DATA_CALL_LIST. It is the complete list
+ * of current data contexts including new contexts that have been
+ * activated. A data call is only removed from this list when the
+ * framework sends a RIL_REQUEST_DEACTIVATE_DATA_CALL or the radio
+ * is powered off/on.
+ *
+ * See also: RIL_REQUEST_DATA_CALL_LIST
+ */
+
+#define RIL_UNSOL_DATA_CALL_LIST_CHANGED 1010
+
+/**
+ * RIL_UNSOL_SUPP_SVC_NOTIFICATION
+ *
+ * Reports supplementary service related notification from the network.
+ *
+ * "data" is a const RIL_SuppSvcNotification *
+ *
+ */
+
+#define RIL_UNSOL_SUPP_SVC_NOTIFICATION 1011
+
+/**
+ * RIL_UNSOL_STK_SESSION_END
+ *
+ * Indicate when STK session is terminated by SIM.
+ *
+ * "data" is NULL
+ */
+#define RIL_UNSOL_STK_SESSION_END 1012
+
+/**
+ * RIL_UNSOL_STK_PROACTIVE_COMMAND
+ *
+ * Indicate when SIM issue a STK proactive command to applications
+ *
+ * "data" is a const char * containing SAT/USAT proactive command
+ * in hexadecimal format string starting with command tag
+ *
+ */
+#define RIL_UNSOL_STK_PROACTIVE_COMMAND 1013
+
+/**
+ * RIL_UNSOL_STK_EVENT_NOTIFY
+ *
+ * Indicate when SIM notifies applcations some event happens.
+ * Generally, application does not need to have any feedback to
+ * SIM but shall be able to indicate appropriate messages to users.
+ *
+ * "data" is a const char * containing SAT/USAT commands or responses
+ * sent by ME to SIM or commands handled by ME, in hexadecimal format string
+ * starting with first byte of response data or command tag
+ *
+ */
+#define RIL_UNSOL_STK_EVENT_NOTIFY 1014
+
+/**
+ * RIL_UNSOL_STK_CALL_SETUP
+ *
+ * Indicate when SIM wants application to setup a voice call.
+ *
+ * "data" is const int *
+ * ((const int *)data)[0] contains timeout value (in milliseconds)
+ */
+#define RIL_UNSOL_STK_CALL_SETUP 1015
+
+/**
+ * RIL_UNSOL_SIM_SMS_STORAGE_FULL
+ *
+ * Indicates that SMS storage on the SIM is full.  Sent when the network
+ * attempts to deliver a new SMS message.  Messages cannot be saved on the
+ * SIM until space is freed.  In particular, incoming Class 2 messages
+ * cannot be stored.
+ *
+ * "data" is null
+ *
+ */
+#define RIL_UNSOL_SIM_SMS_STORAGE_FULL 1016
+
+/**
+ * RIL_UNSOL_SIM_REFRESH
+ *
+ * Indicates that file(s) on the SIM have been updated, or the SIM
+ * has been reinitialized.
+ *
+ * In the case where RIL is version 6 or older:
+ * "data" is an int *
+ * ((int *)data)[0] is a RIL_SimRefreshResult.
+ * ((int *)data)[1] is the EFID of the updated file if the result is
+ * SIM_FILE_UPDATE or NULL for any other result.
+ *
+ * In the case where RIL is version 7:
+ * "data" is a RIL_SimRefreshResponse_v7 *
+ *
+ * Note: If the SIM state changes as a result of the SIM refresh (eg,
+ * SIM_READY -> SIM_LOCKED_OR_ABSENT), RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED
+ * should be sent.
+ */
+#define RIL_UNSOL_SIM_REFRESH 1017
+
+/**
+ * RIL_UNSOL_CALL_RING
+ *
+ * Ring indication for an incoming call (eg, RING or CRING event).
+ * There must be at least one RIL_UNSOL_CALL_RING at the beginning
+ * of a call and sending multiple is optional. If the system property
+ * ro.telephony.call_ring.multiple is false then the upper layers
+ * will generate the multiple events internally. Otherwise the vendor
+ * ril must generate multiple RIL_UNSOL_CALL_RING if
+ * ro.telephony.call_ring.multiple is true or if it is absent.
+ *
+ * The rate of these events is controlled by ro.telephony.call_ring.delay
+ * and has a default value of 3000 (3 seconds) if absent.
+ *
+ * "data" is null for GSM
+ * "data" is const RIL_CDMA_SignalInfoRecord * if CDMA
+ */
+#define RIL_UNSOL_CALL_RING 1018
+
+/**
+ * RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED
+ *
+ * Indicates that SIM state changes.
+ *
+ * Callee will invoke RIL_REQUEST_GET_SIM_STATUS on main thread
+
+ * "data" is null
+ */
+#define RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED 1019
+
+/**
+ * RIL_UNSOL_RESPONSE_CDMA_NEW_SMS
+ *
+ * Called when new CDMA SMS is received
+ *
+ * "data" is const RIL_CDMA_SMS_Message *
+ *
+ * Callee will subsequently confirm the receipt of the SMS with
+ * a RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE
+ *
+ * No new RIL_UNSOL_RESPONSE_CDMA_NEW_SMS should be sent until
+ * RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE has been received
+ *
+ */
+#define RIL_UNSOL_RESPONSE_CDMA_NEW_SMS 1020
+
+/**
+ * RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS
+ *
+ * Called when new Broadcast SMS is received
+ *
+ * "data" can be one of the following:
+ * If received from GSM network, "data" is const char of 88 bytes
+ * which indicates each page of a CBS Message sent to the MS by the
+ * BTS as coded in 3GPP 23.041 Section 9.4.1.2.
+ * If received from UMTS network, "data" is const char of 90 up to 1252
+ * bytes which contain between 1 and 15 CBS Message pages sent as one
+ * packet to the MS by the BTS as coded in 3GPP 23.041 Section 9.4.2.2.
+ *
+ */
+#define RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS 1021
+
+/**
+ * RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL
+ *
+ * Indicates that SMS storage on the RUIM is full.  Messages
+ * cannot be saved on the RUIM until space is freed.
+ *
+ * "data" is null
+ *
+ */
+#define RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL 1022
+
+/**
+ * RIL_UNSOL_RESTRICTED_STATE_CHANGED
+ *
+ * Indicates a restricted state change (eg, for Domain Specific Access Control).
+ *
+ * Radio need send this msg after radio off/on cycle no matter it is changed or not.
+ *
+ * "data" is an int *
+ * ((int *)data)[0] contains a bitmask of RIL_RESTRICTED_STATE_* values.
+ */
+#define RIL_UNSOL_RESTRICTED_STATE_CHANGED 1023
+
+/**
+ * RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE
+ *
+ * Indicates that the radio system selection module has
+ * autonomously entered emergency callback mode.
+ *
+ * "data" is null
+ *
+ */
+#define RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE 1024
+
+/**
+ * RIL_UNSOL_CDMA_CALL_WAITING
+ *
+ * Called when CDMA radio receives a call waiting indication.
+ *
+ * "data" is const RIL_CDMA_CallWaiting *
+ *
+ */
+#define RIL_UNSOL_CDMA_CALL_WAITING 1025
+
+/**
+ * RIL_UNSOL_CDMA_OTA_PROVISION_STATUS
+ *
+ * Called when CDMA radio receives an update of the progress of an
+ * OTASP/OTAPA call.
+ *
+ * "data" is const int *
+ *  For CDMA this is an integer OTASP/OTAPA status listed in
+ *  RIL_CDMA_OTA_ProvisionStatus.
+ *
+ */
+#define RIL_UNSOL_CDMA_OTA_PROVISION_STATUS 1026
+
+/**
+ * RIL_UNSOL_CDMA_INFO_REC
+ *
+ * Called when CDMA radio receives one or more info recs.
+ *
+ * "data" is const RIL_CDMA_InformationRecords *
+ *
+ */
+#define RIL_UNSOL_CDMA_INFO_REC 1027
+
+/**
+ * RIL_UNSOL_OEM_HOOK_RAW
+ *
+ * This is for OEM specific use.
+ *
+ * "data" is a byte[]
+ */
+#define RIL_UNSOL_OEM_HOOK_RAW 1028
+
+/**
+ * RIL_UNSOL_RINGBACK_TONE
+ *
+ * Indicates that nework doesn't have in-band information,  need to
+ * play out-band tone.
+ *
+ * "data" is an int *
+ * ((int *)data)[0] == 0 for stop play ringback tone.
+ * ((int *)data)[0] == 1 for start play ringback tone.
+ */
+#define RIL_UNSOL_RINGBACK_TONE 1029
+
+/**
+ * RIL_UNSOL_RESEND_INCALL_MUTE
+ *
+ * Indicates that framework/application need reset the uplink mute state.
+ *
+ * There may be situations where the mute state becomes out of sync
+ * between the application and device in some GSM infrastructures.
+ *
+ * "data" is null
+ */
+#define RIL_UNSOL_RESEND_INCALL_MUTE 1030
+
+/**
+ * RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED
+ *
+ * Called when CDMA subscription source changed.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is == RIL_CdmaSubscriptionSource
+ */
+#define RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED 1031
+
+/**
+ * RIL_UNSOL_CDMA_PRL_CHANGED
+ *
+ * Called when PRL (preferred roaming list) changes.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is PRL_VERSION as would be returned by RIL_REQUEST_CDMA_SUBSCRIPTION
+ */
+#define RIL_UNSOL_CDMA_PRL_CHANGED 1032
+
+/**
+ * RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE
+ *
+ * Called when Emergency Callback Mode Ends
+ *
+ * Indicates that the radio system selection module has
+ * proactively exited emergency callback mode.
+ *
+ * "data" is NULL
+ *
+ */
+#define RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE 1033
+
+/**
+ * RIL_UNSOL_RIL_CONNECTED
+ *
+ * Called the ril connects and returns the version
+ *
+ * "data" is int *
+ * ((int *)data)[0] is RIL_VERSION
+ */
+#define RIL_UNSOL_RIL_CONNECTED 1034
+
+/**
+ * RIL_UNSOL_VOICE_RADIO_TECH_CHANGED
+ *
+ * Indicates that voice technology has changed. Contains new radio technology
+ * as a data in the message.
+ *
+ * "data" is int *
+ * ((int *)data)[0] is of type const RIL_RadioTechnology
+ *
+ */
+#define RIL_UNSOL_VOICE_RADIO_TECH_CHANGED 1035
+
+/**
+ * RIL_UNSOL_CELL_INFO_LIST
+ *
+ * Same information as returned by RIL_REQUEST_GET_CELL_INFO_LIST, but returned
+ * at the rate no greater than specified by RIL_REQUEST_SET_UNSOL_CELL_INFO_RATE.
+ *
+ * "data" is NULL
+ *
+ * "response" is an array of RIL_CellInfo_v12.
+ */
+#define RIL_UNSOL_CELL_INFO_LIST 1036
+
+/**
+ * RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED
+ *
+ * Called when IMS registration state has changed
+ *
+ * To get IMS registration state and IMS SMS format, callee needs to invoke the
+ * following request on main thread:
+ *
+ * RIL_REQUEST_IMS_REGISTRATION_STATE
+ *
+ * "data" is NULL
+ *
+ */
+#define RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED 1037
+
+/**
+ * RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED
+ *
+ * Indicated when there is a change in subscription status.
+ * This event will be sent in the following scenarios
+ *  - subscription readiness at modem, which was selected by telephony layer
+ *  - when subscription is deactivated by modem due to UICC card removal
+ *  - When network invalidates the subscription i.e. attach reject due to authentication reject
+ *
+ * "data" is const int *
+ * ((const int *)data)[0] == 0 for Subscription Deactivated
+ * ((const int *)data)[0] == 1 for Subscription Activated
+ *
+ */
+#define RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED 1038
+
+/**
+ * RIL_UNSOL_SRVCC_STATE_NOTIFY
+ *
+ * Called when Single Radio Voice Call Continuity(SRVCC)
+ * progress state has changed
+ *
+ * "data" is int *
+ * ((int *)data)[0] is of type const RIL_SrvccState
+ *
+ */
+
+#define RIL_UNSOL_SRVCC_STATE_NOTIFY 1039
+
+/**
+ * RIL_UNSOL_HARDWARE_CONFIG_CHANGED
+ *
+ * Called when the hardware configuration associated with the RILd changes
+ *
+ * "data" is an array of RIL_HardwareConfig
+ *
+ */
+#define RIL_UNSOL_HARDWARE_CONFIG_CHANGED 1040
+
+/**
+ * RIL_UNSOL_DC_RT_INFO_CHANGED
+ *
+ * The message is DEPRECATED, use RIL_REQUEST_GET_ACTIVITY_INFO
+ * Sent when the DC_RT_STATE changes but the time
+ * between these messages must not be less than the
+ * value set by RIL_REQUEST_SET_DC_RT_RATE.
+ *
+ * "data" is the most recent RIL_DcRtInfo
+ *
+ */
+#define RIL_UNSOL_DC_RT_INFO_CHANGED 1041
+
+/**
+ * RIL_UNSOL_RADIO_CAPABILITY
+ *
+ * Sent when RIL_REQUEST_SET_RADIO_CAPABILITY completes.
+ * Returns the phone radio capability exactly as
+ * RIL_REQUEST_GET_RADIO_CAPABILITY and should be the
+ * same set as sent by RIL_REQUEST_SET_RADIO_CAPABILITY.
+ *
+ * "data" is the RIL_RadioCapability structure
+ */
+#define RIL_UNSOL_RADIO_CAPABILITY 1042
+
+/*
+ * RIL_UNSOL_ON_SS
+ *
+ * Called when SS response is received when DIAL/USSD/SS is changed to SS by
+ * call control.
+ *
+ * "data" is const RIL_StkCcUnsolSsResponse *
+ *
+ */
+#define RIL_UNSOL_ON_SS 1043
+
+/**
+ * RIL_UNSOL_STK_CC_ALPHA_NOTIFY
+ *
+ * Called when there is an ALPHA from UICC during Call Control.
+ *
+ * "data" is const char * containing ALPHA string from UICC in UTF-8 format.
+ *
+ */
+#define RIL_UNSOL_STK_CC_ALPHA_NOTIFY 1044
+
+/**
+ * RIL_UNSOL_LCEDATA_RECV
+ *
+ * Called when there is an incoming Link Capacity Estimate (LCE) info report.
+ *
+ * "data" is the RIL_LceDataInfo structure.
+ *
+ */
+#define RIL_UNSOL_LCEDATA_RECV 1045
+
+ /**
+  * RIL_UNSOL_PCO_DATA
+  *
+  * Called when there is new Carrier PCO data received for a data call.  Ideally
+  * only new data will be forwarded, though this is not required.  Multiple
+  * boxes of carrier PCO data for a given call should result in a series of
+  * RIL_UNSOL_PCO_DATA calls.
+  *
+  * "data" is the RIL_PCO_Data structure.
+  *
+  */
+#define RIL_UNSOL_PCO_DATA 1046
+
+/***********************************************************************/
+
+
+#if defined(ANDROID_MULTI_SIM)
+/**
+ * RIL_Request Function pointer
+ *
+ * @param request is one of RIL_REQUEST_*
+ * @param data is pointer to data defined for that RIL_REQUEST_*
+ *        data is owned by caller, and should not be modified or freed by callee
+ *        structures passed as data may contain pointers to non-contiguous memory
+ * @param t should be used in subsequent call to RIL_onResponse
+ * @param datalen is the length of "data" which is defined as other argument. It may or may
+ *        not be equal to sizeof(data). Refer to the documentation of individual structures
+ *        to find if pointers listed in the structure are contiguous and counted in the datalen
+ *        length or not.
+ *        (Eg: RIL_IMS_SMS_Message where we don't have datalen equal to sizeof(data))
+ *
+ */
+typedef void (*RIL_RequestFunc) (int request, void *data,
+                                    size_t datalen, RIL_Token t, RIL_SOCKET_ID socket_id);
+
+/**
+ * This function should return the current radio state synchronously
+ */
+typedef RIL_RadioState (*RIL_RadioStateRequest)(RIL_SOCKET_ID socket_id);
+
+#else
+/* Backward compatible */
+
+/**
+ * RIL_Request Function pointer
+ *
+ * @param request is one of RIL_REQUEST_*
+ * @param data is pointer to data defined for that RIL_REQUEST_*
+ *        data is owned by caller, and should not be modified or freed by callee
+ *        structures passed as data may contain pointers to non-contiguous memory
+ * @param t should be used in subsequent call to RIL_onResponse
+ * @param datalen is the length of "data" which is defined as other argument. It may or may
+ *        not be equal to sizeof(data). Refer to the documentation of individual structures
+ *        to find if pointers listed in the structure are contiguous and counted in the datalen
+ *        length or not.
+ *        (Eg: RIL_IMS_SMS_Message where we don't have datalen equal to sizeof(data))
+ *
+ */
+typedef void (*RIL_RequestFunc) (int request, void *data,
+                                    size_t datalen, RIL_Token t);
+
+/**
+ * This function should return the current radio state synchronously
+ */
+typedef RIL_RadioState (*RIL_RadioStateRequest)();
+
+#endif
+
+
+/**
+ * This function returns "1" if the specified RIL_REQUEST code is
+ * supported and 0 if it is not
+ *
+ * @param requestCode is one of RIL_REQUEST codes
+ */
+
+typedef int (*RIL_Supports)(int requestCode);
+
+/**
+ * This function is called from a separate thread--not the
+ * thread that calls RIL_RequestFunc--and indicates that a pending
+ * request should be cancelled.
+ *
+ * On cancel, the callee should do its best to abandon the request and
+ * call RIL_onRequestComplete with RIL_Errno CANCELLED at some later point.
+ *
+ * Subsequent calls to  RIL_onRequestComplete for this request with
+ * other results will be tolerated but ignored. (That is, it is valid
+ * to ignore the cancellation request)
+ *
+ * RIL_Cancel calls should return immediately, and not wait for cancellation
+ *
+ * Please see ITU v.250 5.6.1 for how one might implement this on a TS 27.007
+ * interface
+ *
+ * @param t token wants to be canceled
+ */
+
+typedef void (*RIL_Cancel)(RIL_Token t);
+
+typedef void (*RIL_TimedCallback) (void *param);
+
+/**
+ * Return a version string for your RIL implementation
+ */
+typedef const char * (*RIL_GetVersion) (void);
+
+typedef struct {
+    int version;        /* set to RIL_VERSION */
+    RIL_RequestFunc onRequest;
+    RIL_RadioStateRequest onStateRequest;
+    RIL_Supports supports;
+    RIL_Cancel onCancel;
+    RIL_GetVersion getVersion;
+} RIL_RadioFunctions;
+
+typedef struct {
+    char *apn;
+    char *protocol;
+    int authtype;
+    char *username;
+    char *password;
+} RIL_InitialAttachApn;
+
+typedef struct {
+    int authContext;            /* P2 value of authentication command, see P2 parameter in
+                                   3GPP TS 31.102 7.1.2 */
+    char *authData;             /* the challenge string in Base64 format, see 3GPP
+                                   TS 31.102 7.1.2 */
+    char *aid;                  /* AID value, See ETSI 102.221 8.1 and 101.220 4,
+                                   NULL if no value. */
+} RIL_SimAuthentication;
+
+typedef struct {
+    int cid;             /* Context ID, uniquely identifies this call */
+    char *bearer_proto;  /* One of the PDP_type values in TS 27.007 section 10.1.1.
+                            For example, "IP", "IPV6", "IPV4V6" */
+    int pco_id;          /* The protocol ID for this box.  Note that only IDs from
+                            FF00H - FFFFH are accepted.  If more than one is included
+                            from the network, multiple calls should be made to send all
+                            of them. */
+    int contents_length; /* The number of octets in the contents. */
+    char *contents;      /* Carrier-defined content.  It is binary, opaque and
+                            loosely defined in LTE Layer 3 spec 24.008 */
+} RIL_PCO_Data;
+
+#ifdef RIL_SHLIB
+struct RIL_Env {
+    /**
+     * "t" is parameter passed in on previous call to RIL_Notification
+     * routine.
+     *
+     * If "e" != SUCCESS, then response can be null/is ignored
+     *
+     * "response" is owned by caller, and should not be modified or
+     * freed by callee
+     *
+     * RIL_onRequestComplete will return as soon as possible
+     */
+    void (*OnRequestComplete)(RIL_Token t, RIL_Errno e,
+                           void *response, size_t responselen);
+
+#if defined(ANDROID_MULTI_SIM)
+    /**
+     * "unsolResponse" is one of RIL_UNSOL_RESPONSE_*
+     * "data" is pointer to data defined for that RIL_UNSOL_RESPONSE_*
+     *
+     * "data" is owned by caller, and should not be modified or freed by callee
+     */
+    void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen, RIL_SOCKET_ID socket_id);
+#else
+    /**
+     * "unsolResponse" is one of RIL_UNSOL_RESPONSE_*
+     * "data" is pointer to data defined for that RIL_UNSOL_RESPONSE_*
+     *
+     * "data" is owned by caller, and should not be modified or freed by callee
+     */
+    void (*OnUnsolicitedResponse)(int unsolResponse, const void *data, size_t datalen);
+#endif
+    /**
+     * Call user-specifed "callback" function on on the same thread that
+     * RIL_RequestFunc is called. If "relativeTime" is specified, then it specifies
+     * a relative time value at which the callback is invoked. If relativeTime is
+     * NULL or points to a 0-filled structure, the callback will be invoked as
+     * soon as possible
+     */
+
+    void (*RequestTimedCallback) (RIL_TimedCallback callback,
+                                   void *param, const struct timeval *relativeTime);
+   /**
+    * "t" is parameter passed in on previous call RIL_Notification routine
+    *
+    * RIL_onRequestAck will be called by vendor when an Async RIL request was received
+    * by them and an ack needs to be sent back to java ril.
+    */
+    void (*OnRequestAck) (RIL_Token t);
+};
+
+
+/**
+ *  RIL implementations must defined RIL_Init
+ *  argc and argv will be command line arguments intended for the RIL implementation
+ *  Return NULL on error
+ *
+ * @param env is environment point defined as RIL_Env
+ * @param argc number of arguments
+ * @param argv list fo arguments
+ *
+ */
+const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv);
+
+/**
+ *  If BT SAP(SIM Access Profile) is supported, then RIL implementations must define RIL_SAP_Init
+ *  for initializing RIL_RadioFunctions used for BT SAP communcations. It is called whenever RILD
+ *  starts or modem restarts. Returns handlers for SAP related request that are made on SAP
+ *  sepecific socket, analogous to the RIL_RadioFunctions returned by the call to RIL_Init
+ *  and used on the general RIL socket.
+ *  argc and argv will be command line arguments intended for the RIL implementation
+ *  Return NULL on error.
+ *
+ * @param env is environment point defined as RIL_Env
+ * @param argc number of arguments
+ * @param argv list fo arguments
+ *
+ */
+const RIL_RadioFunctions *RIL_SAP_Init(const struct RIL_Env *env, int argc, char **argv);
+
+#else /* RIL_SHLIB */
+
+/**
+ * Call this once at startup to register notification routine
+ *
+ * @param callbacks user-specifed callback function
+ */
+void RIL_register (const RIL_RadioFunctions *callbacks);
+
+
+/**
+ *
+ * RIL_onRequestComplete will return as soon as possible
+ *
+ * @param t is parameter passed in on previous call to RIL_Notification
+ *          routine.
+ * @param e error code
+ *          if "e" != SUCCESS, then response can be null/is ignored
+ * @param response is owned by caller, and should not be modified or
+ *                 freed by callee
+ * @param responselen the length of response in byte
+ */
+void RIL_onRequestComplete(RIL_Token t, RIL_Errno e,
+                           void *response, size_t responselen);
+
+/**
+ * RIL_onRequestAck will be called by vendor when an Async RIL request was received by them and
+ * an ack needs to be sent back to java ril. This doesn't mark the end of the command or it's
+ * results, just that the command was received and will take a while. After sending this Ack
+ * its vendor's responsibility to make sure that AP is up whenever needed while command is
+ * being processed.
+ *
+ * @param t is parameter passed in on previous call to RIL_Notification
+ *          routine.
+ */
+void RIL_onRequestAck(RIL_Token t);
+
+#if defined(ANDROID_MULTI_SIM)
+/**
+ * @param unsolResponse is one of RIL_UNSOL_RESPONSE_*
+ * @param data is pointer to data defined for that RIL_UNSOL_RESPONSE_*
+ *     "data" is owned by caller, and should not be modified or freed by callee
+ * @param datalen the length of data in byte
+ */
+
+void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen, RIL_SOCKET_ID socket_id);
+#else
+/**
+ * @param unsolResponse is one of RIL_UNSOL_RESPONSE_*
+ * @param data is pointer to data defined for that RIL_UNSOL_RESPONSE_*
+ *     "data" is owned by caller, and should not be modified or freed by callee
+ * @param datalen the length of data in byte
+ */
+
+void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen);
+#endif
+
+/**
+ * Call user-specifed "callback" function on on the same thread that
+ * RIL_RequestFunc is called. If "relativeTime" is specified, then it specifies
+ * a relative time value at which the callback is invoked. If relativeTime is
+ * NULL or points to a 0-filled structure, the callback will be invoked as
+ * soon as possible
+ *
+ * @param callback user-specifed callback function
+ * @param param parameter list
+ * @param relativeTime a relative time value at which the callback is invoked
+ */
+
+void RIL_requestTimedCallback (RIL_TimedCallback callback,
+                               void *param, const struct timeval *relativeTime);
+
+#endif /* RIL_SHLIB */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ANDROID_RIL_H*/
diff --git a/rilsrc/include/telephony/ril_cdma_sms.h b/rilsrc/include/telephony/ril_cdma_sms.h
new file mode 100644
index 0000000..bcf6b30
--- /dev/null
+++ b/rilsrc/include/telephony/ril_cdma_sms.h
@@ -0,0 +1,806 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * ISSUES:
+ *
+ */
+
+/**
+ * TODO
+ *
+ *
+ */
+
+
+#ifndef ANDROID_RIL_CDMA_SMS_H
+#define ANDROID_RIL_CDMA_SMS_H 1
+
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Used by RIL_REQUEST_CDMA_SEND_SMS and RIL_UNSOL_RESPONSE_CDMA_NEW_SMS */
+
+#define RIL_CDMA_SMS_ADDRESS_MAX     36
+#define RIL_CDMA_SMS_SUBADDRESS_MAX  36
+#define RIL_CDMA_SMS_BEARER_DATA_MAX 255
+
+typedef enum {
+    RIL_CDMA_SMS_DIGIT_MODE_4_BIT = 0,     /* DTMF digits */
+    RIL_CDMA_SMS_DIGIT_MODE_8_BIT = 1,
+    RIL_CDMA_SMS_DIGIT_MODE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_DigitMode;
+
+typedef enum {
+    RIL_CDMA_SMS_NUMBER_MODE_NOT_DATA_NETWORK = 0,
+    RIL_CDMA_SMS_NUMBER_MODE_DATA_NETWORK     = 1,
+    RIL_CDMA_SMS_NUMBER_MODE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_NumberMode;
+
+typedef enum {
+    RIL_CDMA_SMS_NUMBER_TYPE_UNKNOWN                   = 0,
+    RIL_CDMA_SMS_NUMBER_TYPE_INTERNATIONAL_OR_DATA_IP  = 1,
+      /* INTERNATIONAL is used when number mode is not data network address.
+       * DATA_IP is used when the number mode is data network address
+       */
+    RIL_CDMA_SMS_NUMBER_TYPE_NATIONAL_OR_INTERNET_MAIL = 2,
+      /* NATIONAL is used when the number mode is not data network address.
+       * INTERNET_MAIL is used when the number mode is data network address.
+       * For INTERNET_MAIL, in the address data "digits", each byte contains
+       * an ASCII character. Examples are "x@y.com,a@b.com - ref TIA/EIA-637A 3.4.3.3
+       */
+    RIL_CDMA_SMS_NUMBER_TYPE_NETWORK                   = 3,
+    RIL_CDMA_SMS_NUMBER_TYPE_SUBSCRIBER                = 4,
+    RIL_CDMA_SMS_NUMBER_TYPE_ALPHANUMERIC              = 5,
+      /* GSM SMS: address value is GSM 7-bit chars */
+    RIL_CDMA_SMS_NUMBER_TYPE_ABBREVIATED               = 6,
+    RIL_CDMA_SMS_NUMBER_TYPE_RESERVED_7                = 7,
+    RIL_CDMA_SMS_NUMBER_TYPE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_NumberType;
+
+typedef enum {
+    RIL_CDMA_SMS_NUMBER_PLAN_UNKNOWN     = 0,
+    RIL_CDMA_SMS_NUMBER_PLAN_TELEPHONY   = 1,      /* CCITT E.164 and E.163, including ISDN plan */
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_2  = 2,
+    RIL_CDMA_SMS_NUMBER_PLAN_DATA        = 3,      /* CCITT X.121 */
+    RIL_CDMA_SMS_NUMBER_PLAN_TELEX       = 4,      /* CCITT F.69 */
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_5  = 5,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_6  = 6,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_7  = 7,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_8  = 8,
+    RIL_CDMA_SMS_NUMBER_PLAN_PRIVATE     = 9,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_10 = 10,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_11 = 11,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_12 = 12,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_13 = 13,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_14 = 14,
+    RIL_CDMA_SMS_NUMBER_PLAN_RESERVED_15 = 15,
+    RIL_CDMA_SMS_NUMBER_PLAN_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_NumberPlan;
+
+typedef struct {
+    RIL_CDMA_SMS_DigitMode digit_mode;
+      /* Indicates 4-bit or 8-bit */
+    RIL_CDMA_SMS_NumberMode number_mode;
+      /* Used only when digitMode is 8-bit */
+    RIL_CDMA_SMS_NumberType number_type;
+      /* Used only when digitMode is 8-bit.
+       * To specify an international address, use the following:
+       * digitMode = RIL_CDMA_SMS_DIGIT_MODE_8_BIT
+       * numberMode = RIL_CDMA_SMS_NOT_DATA_NETWORK
+       * numberType = RIL_CDMA_SMS_NUMBER_TYPE_INTERNATIONAL_OR_DATA_IP
+       * numberPlan = RIL_CDMA_SMS_NUMBER_PLAN_TELEPHONY
+       * numberOfDigits = number of digits
+       * digits = ASCII digits, e.g. '1', '2', '3'3, '4', and '5'
+       */
+    RIL_CDMA_SMS_NumberPlan number_plan;
+      /* Used only when digitMode is 8-bit */
+    unsigned char number_of_digits;
+    unsigned char digits[ RIL_CDMA_SMS_ADDRESS_MAX ];
+      /* Each byte in this array represnts a 40bit or 8-bit digit of address data */
+} RIL_CDMA_SMS_Address;
+
+typedef enum {
+    RIL_CDMA_SMS_SUBADDRESS_TYPE_NSAP           = 0,    /* CCITT X.213 or ISO 8348 AD2 */
+    RIL_CDMA_SMS_SUBADDRESS_TYPE_USER_SPECIFIED = 1,    /* e.g. X.25 */
+    RIL_CDMA_SMS_SUBADDRESS_TYPE_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_SubaddressType;
+
+typedef struct {
+    RIL_CDMA_SMS_SubaddressType subaddressType;
+    /* 1 means the last byte's lower 4 bits should be ignored */
+    unsigned char odd;
+    unsigned char number_of_digits;
+    /* Each byte respresents a 8-bit digit of subaddress data */
+    unsigned char digits[ RIL_CDMA_SMS_SUBADDRESS_MAX ];
+} RIL_CDMA_SMS_Subaddress;
+
+typedef struct {
+    int uTeleserviceID;
+    unsigned char bIsServicePresent;
+    int uServicecategory;
+    RIL_CDMA_SMS_Address sAddress;
+    RIL_CDMA_SMS_Subaddress sSubAddress;
+    int uBearerDataLen;
+    unsigned char aBearerData[ RIL_CDMA_SMS_BEARER_DATA_MAX ];
+} RIL_CDMA_SMS_Message;
+
+/* Used by RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE */
+
+typedef enum {
+    RIL_CDMA_SMS_NO_ERROR       = 0,
+    RIL_CDMA_SMS_ERROR          = 1,
+    RIL_CDMA_SMS_ERROR_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_ErrorClass;
+
+typedef struct {
+    RIL_CDMA_SMS_ErrorClass uErrorClass;
+    int uSMSCauseCode;  /* As defined in N.S00005, 6.5.2.125.
+                           Currently, only 35 (resource shortage) and
+                           39 (other terminal problem) are reported. */
+} RIL_CDMA_SMS_Ack;
+
+/* Used by RIL_REQUEST_CDMA_SMS_GET_BROADCAST_CONFIG and
+   RIL_REQUEST_CDMA_SMS_SET_BROADCAST_CONFIG */
+
+typedef struct {
+    int service_category;
+    int language;
+    unsigned char selected;
+} RIL_CDMA_BroadcastSmsConfigInfo;
+
+/* Used by RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM */
+
+typedef struct {
+    int status;     /* Status of message.  See TS 27.005 3.1, "<stat>": */
+                  /*      0 = "REC UNREAD"    */
+                  /*      1 = "REC READ"      */
+                  /*      2 = "STO UNSENT"    */
+                  /*      3 = "STO SENT"      */
+
+    RIL_CDMA_SMS_Message message;
+} RIL_CDMA_SMS_WriteArgs;
+
+
+/* Used by RIL_REQUEST_ENCODE_CDMA_SMS and RIL_REQUEST_DECODE_CDMA_SMS*/
+
+#define RIL_CDMA_SMS_UDH_MAX_SND_SIZE           128
+#define RIL_CDMA_SMS_UDH_EO_DATA_SEGMENT_MAX    131 /* 140 - 3 - 6 */
+#define RIL_CDMA_SMS_MAX_UD_HEADERS         7
+#define RIL_CDMA_SMS_USER_DATA_MAX     229
+#define RIL_CDMA_SMS_ADDRESS_MAX            36
+#define RIL_CDMA_SMS_UDH_LARGE_PIC_SIZE     128
+#define RIL_CDMA_SMS_UDH_SMALL_PIC_SIZE     32
+#define RIL_CDMA_SMS_UDH_VAR_PIC_SIZE       134
+#define RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS   4
+#define RIL_CDMA_SMS_UDH_LARGE_BITMAP_SIZE  32
+#define RIL_CDMA_SMS_UDH_SMALL_BITMAP_SIZE  8
+#define RIL_CDMA_SMS_UDH_OTHER_SIZE         226
+#define RIL_CDMA_SMS_IP_ADDRESS_SIZE        4
+
+/* ------------------- */
+/* ---- User Data ---- */
+/* ------------------- */
+typedef enum {
+    RIL_CDMA_SMS_UDH_CONCAT_8         = 0x00,
+    RIL_CDMA_SMS_UDH_SPECIAL_SM,
+    /* 02 - 03    Reserved */
+    RIL_CDMA_SMS_UDH_PORT_8           = 0x04,
+    RIL_CDMA_SMS_UDH_PORT_16,
+    RIL_CDMA_SMS_UDH_SMSC_CONTROL,
+    RIL_CDMA_SMS_UDH_SOURCE,
+    RIL_CDMA_SMS_UDH_CONCAT_16,
+    RIL_CDMA_SMS_UDH_WCMP,
+    RIL_CDMA_SMS_UDH_TEXT_FORMATING,
+    RIL_CDMA_SMS_UDH_PRE_DEF_SOUND,
+    RIL_CDMA_SMS_UDH_USER_DEF_SOUND,
+    RIL_CDMA_SMS_UDH_PRE_DEF_ANIM,
+    RIL_CDMA_SMS_UDH_LARGE_ANIM,
+    RIL_CDMA_SMS_UDH_SMALL_ANIM,
+    RIL_CDMA_SMS_UDH_LARGE_PICTURE,
+    RIL_CDMA_SMS_UDH_SMALL_PICTURE,
+    RIL_CDMA_SMS_UDH_VAR_PICTURE,
+
+    RIL_CDMA_SMS_UDH_USER_PROMPT      = 0x13,
+    RIL_CDMA_SMS_UDH_EXTENDED_OBJECT  = 0x14,
+
+    /* 15 - 1F    Reserved for future EMS */
+
+    RIL_CDMA_SMS_UDH_RFC822           = 0x20,
+
+    /*  21 - 6F    Reserved for future use */
+    /*  70 - 7f    Reserved for (U)SIM Toolkit Security Headers */
+    /*  80 - 9F    SME to SME specific use */
+    /*  A0 - BF    Reserved for future use */
+    /*  C0 - DF    SC specific use */
+    /*  E0 - FF    Reserved for future use */
+
+    RIL_CDMA_SMS_UDH_OTHER            = 0xFFFF, /* For unsupported or proprietary headers */
+    RIL_CDMA_SMS_UDH_ID_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+
+} RIL_CDMA_SMS_UdhId;
+
+typedef struct {
+    /*indicates the reference number for a particular concatenated short message. */
+    /*it is constant for every short message which makes up a particular concatenated short message*/
+    unsigned char       msg_ref;
+
+    /*indicates the total number of short messages within the concatenated short message.
+     The value shall start at 1 and remain constant for every
+     short message which makes up the concatenated short message.
+     if it is 0 then the receiving entity shall ignore the whole Information Element*/
+    unsigned char       total_sm;
+
+    /*
+     * it indicates the sequence number of a particular short message within the concatenated short
+     * message. The value shall start at 1 and increment by one for every short message sent
+     * within the concatenated short message. If the value is zero or the value is
+     * greater than the value in octet 2 then the receiving
+     * entity shall ignore the whole Information Element.
+     */
+    unsigned char      seq_num;
+} RIL_CDMA_SMS_UdhConcat8;
+
+/* GW message waiting actions
+*/
+typedef enum {
+    RIL_CDMA_SMS_GW_MSG_WAITING_NONE,
+    RIL_CDMA_SMS_GW_MSG_WAITING_DISCARD,
+    RIL_CDMA_SMS_GW_MSG_WAITING_STORE,
+    RIL_CDMA_SMS_GW_MSG_WAITING_NONE_1111,
+    RIL_CDMA_SMS_GW_MSG_WAITING_MAX32 = 0x10000000 /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_GWMsgWaiting;
+
+/* GW message waiting types
+*/
+typedef enum {
+    RIL_CDMA_SMS_GW_MSG_WAITING_VOICEMAIL,
+    RIL_CDMA_SMS_GW_MSG_WAITING_FAX,
+    RIL_CDMA_SMS_GW_MSG_WAITING_EMAIL,
+    RIL_CDMA_SMS_GW_MSG_WAITING_OTHER,
+    RIL_CDMA_SMS_GW_MSG_WAITING_KIND_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_GWMsgWaitingKind;
+
+typedef struct {
+    RIL_CDMA_SMS_GWMsgWaiting                 msg_waiting;
+    RIL_CDMA_SMS_GWMsgWaitingKind             msg_waiting_kind;
+
+    /*it indicates the number of messages of the type specified in Octet 1 waiting.*/
+    unsigned char                             message_count;
+} RIL_CDMA_SMS_UdhSpecialSM;
+
+typedef struct {
+    unsigned char  dest_port;
+    unsigned char  orig_port;
+} RIL_CDMA_SMS_UdhWap8;
+
+typedef struct {
+    unsigned short  dest_port;
+    unsigned short  orig_port;
+} RIL_CDMA_SMS_UdhWap16;
+
+typedef struct {
+    unsigned short      msg_ref;
+    unsigned char       total_sm;
+    unsigned char       seq_num;
+
+} RIL_CDMA_SMS_UdhConcat16;
+
+typedef enum {
+    RIL_CDMA_SMS_UDH_LEFT_ALIGNMENT = 0,
+    RIL_CDMA_SMS_UDH_CENTER_ALIGNMENT,
+    RIL_CDMA_SMS_UDH_RIGHT_ALIGNMENT,
+    RIL_CDMA_SMS_UDH_DEFAULT_ALIGNMENT,
+    RIL_CDMA_SMS_UDH_MAX_ALIGNMENT,
+    RIL_CDMA_SMS_UDH_ALIGNMENT_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_UdhAlignment;
+
+typedef enum {
+    RIL_CDMA_SMS_UDH_FONT_NORMAL = 0,
+    RIL_CDMA_SMS_UDH_FONT_LARGE,
+    RIL_CDMA_SMS_UDH_FONT_SMALL,
+    RIL_CDMA_SMS_UDH_FONT_RESERVED,
+    RIL_CDMA_SMS_UDH_FONT_MAX,
+    RIL_CDMA_SMS_UDH_FONT_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_UdhFontSize;
+
+typedef enum {
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BLACK          = 0x0,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_GREY      = 0x1,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_RED       = 0x2,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_YELLOW    = 0x3,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_GREEN     = 0x4,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_CYAN      = 0x5,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_BLUE      = 0x6,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_DARK_MAGENTA   = 0x7,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_GREY           = 0x8,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_WHITE          = 0x9,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_RED     = 0xA,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_YELLOW  = 0xB,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_GREEN   = 0xC,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_CYAN    = 0xD,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_BLUE    = 0xE,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_BRIGHT_MAGENTA = 0xF,
+    RIL_CDMA_SMS_UDH_TEXT_COLOR_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_UdhTextColor;
+
+typedef struct {
+    unsigned char              start_position;
+    unsigned char              text_formatting_length;
+    RIL_CDMA_SMS_UdhAlignment  alignment_type ;       /*bit 0 and  bit 1*/
+    RIL_CDMA_SMS_UdhFontSize   font_size ;            /*bit 3 and  bit 2*/
+    unsigned char              style_bold;            /*bit 4 */
+    unsigned char              style_italic;          /*bit 5  */
+    unsigned char              style_underlined;      /*bit 6 */
+    unsigned char              style_strikethrough;   /*bit 7 */
+
+    /* if FALSE, ignore the following color information */
+    unsigned char              is_color_present;
+    RIL_CDMA_SMS_UdhTextColor  text_color_foreground;
+    RIL_CDMA_SMS_UdhTextColor  text_color_background;
+
+} RIL_CDMA_SMS_UdhTextFormating;
+
+/* Predefined sound
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       snd_number;
+} RIL_CDMA_SMS_UdhPreDefSound;
+
+/* User Defined sound
+*/
+typedef struct {
+    unsigned char       data_length;
+    unsigned char       position;
+    unsigned char       user_def_sound[RIL_CDMA_SMS_UDH_MAX_SND_SIZE];
+} RIL_CDMA_SMS_UdhUserDefSound;
+
+/* Large picture
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       data[RIL_CDMA_SMS_UDH_LARGE_PIC_SIZE];
+} RIL_CDMA_SMS_UdhLargePictureData;
+
+/* Small picture
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       data[RIL_CDMA_SMS_UDH_SMALL_PIC_SIZE];
+} RIL_CDMA_SMS_UdhSmallPictureData;
+
+/* Variable length picture
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       width;    /* Number of pixels - Should be a mutliple of 8 */
+    unsigned char       height;
+    unsigned char       data[RIL_CDMA_SMS_UDH_VAR_PIC_SIZE];
+} RIL_CDMA_SMS_UdhVarPicture;
+
+/* Predefined animation
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       animation_number;
+} RIL_CDMA_SMS_UdhPreDefAnim;
+
+/* Large animation
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       data[RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS][RIL_CDMA_SMS_UDH_LARGE_BITMAP_SIZE];
+} RIL_CDMA_SMS_UdhLargeAnim;
+
+/* Small animation
+*/
+typedef struct {
+    unsigned char       position;
+    unsigned char       data[RIL_CDMA_SMS_UDH_ANIM_NUM_BITMAPS][RIL_CDMA_SMS_UDH_SMALL_BITMAP_SIZE];
+} RIL_CDMA_SMS_UdhSmallAnim;
+
+/* User Prompt Indicator UDH
+*/
+typedef struct {
+    unsigned char       number_of_objects;
+    /* Number of objects of the same kind that follow this header which will
+    ** be stitched together by the applications. For example, 5 small pictures
+    ** are to be stitched together horizontally, or 6 iMelody tones are to be
+    ** connected together with intermediate iMelody header and footer ignored.
+    ** Allowed objects to be stitched:
+    **   - Images (small, large, variable)
+    **   - User defined sounds
+    */
+} RIL_CDMA_SMS_UdhUserPrompt;
+
+typedef struct {
+    unsigned char         length;
+
+    unsigned char         data[RIL_CDMA_SMS_UDH_EO_DATA_SEGMENT_MAX];
+    /* RIL_CDMA_SMS_UDH_EO_VCARD: See http://www.imc.org/pdi/vcard-21.doc for payload */
+    /* RIL_CDMA_SMS_UDH_EO_VCALENDAR: See http://www.imc.org/pdi/vcal-10.doc */
+    /* Or: Unsupported/proprietary extended objects */
+
+} RIL_CDMA_SMS_UdhEoContent;
+
+/* Extended Object UDH
+*/
+/* Extended Object IDs/types
+*/
+typedef enum {
+    RIL_CDMA_SMS_UDH_EO_VCARD                   = 0x09,
+    RIL_CDMA_SMS_UDH_EO_VCALENDAR               = 0x0A,
+    RIL_CDMA_SMS_UDH_EO_MAX32 = 0x10000000   /* Force constant ENUM size in structures */
+} RIL_CDMA_SMS_UdhEoId;
+
+typedef struct {
+    /* Extended objects are to be used together with 16-bit concatenation
+    ** UDH. The max number of segments supported for E.O. is 8 at least.
+    */
+    RIL_CDMA_SMS_UdhEoContent    content;
+
+    unsigned char                                 first_segment;
+    /* The following fields are only present in the first segment of a
+    ** concatenated SMS message.
+    */
+   unsigned char                                   reference;
+    /* Identify those extended object segments which should be linked together
+    */
+   unsigned short                                  length;
+    /* Length of the whole extended object data
+    */
+    unsigned char                                   control;
+    RIL_CDMA_SMS_UdhEoId                    type;
+    unsigned short                                  position;
+    /* Absolute position of the E.O. in the whole text after concatenation,
+    ** starting from 1.
+    */
+} RIL_CDMA_SMS_UdhEo;
+
+typedef struct {
+    RIL_CDMA_SMS_UdhId  header_id;
+    unsigned char               header_length;
+    unsigned char              data[RIL_CDMA_SMS_UDH_OTHER_SIZE];
+} RIL_CDMA_SMS_UdhOther;
+
+typedef struct {
+    unsigned char        header_length;
+} RIL_CDMA_SMS_UdhRfc822;
+
+typedef struct {
+    RIL_CDMA_SMS_UdhId                header_id;
+
+    union {
+        RIL_CDMA_SMS_UdhConcat8             concat_8;       // 00
+
+        RIL_CDMA_SMS_UdhSpecialSM           special_sm;     // 01
+        RIL_CDMA_SMS_UdhWap8                wap_8;          // 04
+        RIL_CDMA_SMS_UdhWap16               wap_16;         // 05
+        RIL_CDMA_SMS_UdhConcat16            concat_16;      // 08
+        RIL_CDMA_SMS_UdhTextFormating       text_formating; // 0a
+        RIL_CDMA_SMS_UdhPreDefSound         pre_def_sound;  // 0b
+        RIL_CDMA_SMS_UdhUserDefSound        user_def_sound; // 0c
+        RIL_CDMA_SMS_UdhPreDefAnim          pre_def_anim;   // 0d
+        RIL_CDMA_SMS_UdhLargeAnim           large_anim;     // 0e
+        RIL_CDMA_SMS_UdhSmallAnim           small_anim;     // 0f
+        RIL_CDMA_SMS_UdhLargePictureData    large_picture;  // 10
+        RIL_CDMA_SMS_UdhSmallPictureData    small_picture;  // 11
+        RIL_CDMA_SMS_UdhVarPicture          var_picture;    // 12
+
+        RIL_CDMA_SMS_UdhUserPrompt          user_prompt;    // 13
+        RIL_CDMA_SMS_UdhEo                  eo;             // 14
+
+        RIL_CDMA_SMS_UdhRfc822              rfc822;         // 20
+        RIL_CDMA_SMS_UdhOther               other;
+
+    }u;
+} RIL_CDMA_SMS_Udh;
+
+/* ----------------------------- */
+/* -- User data encoding type -- */
+/* ----------------------------- */
+typedef enum {
+    RIL_CDMA_SMS_ENCODING_OCTET        = 0,    /* 8-bit */
+    RIL_CDMA_SMS_ENCODING_IS91EP,              /* varies */
+    RIL_CDMA_SMS_ENCODING_ASCII,               /* 7-bit */
+    RIL_CDMA_SMS_ENCODING_IA5,                 /* 7-bit */
+    RIL_CDMA_SMS_ENCODING_UNICODE,             /* 16-bit */
+    RIL_CDMA_SMS_ENCODING_SHIFT_JIS,           /* 8 or 16-bit */
+    RIL_CDMA_SMS_ENCODING_KOREAN,              /* 8 or 16-bit */
+    RIL_CDMA_SMS_ENCODING_LATIN_HEBREW,        /* 8-bit */
+    RIL_CDMA_SMS_ENCODING_LATIN,               /* 8-bit */
+    RIL_CDMA_SMS_ENCODING_GSM_7_BIT_DEFAULT,   /* 7-bit */
+    RIL_CDMA_SMS_ENCODING_MAX32        = 0x10000000
+
+} RIL_CDMA_SMS_UserDataEncoding;
+
+/* ------------------------ */
+/* -- IS-91 EP data type -- */
+/* ------------------------ */
+typedef enum {
+    RIL_CDMA_SMS_IS91EP_VOICE_MAIL         = 0x82,
+    RIL_CDMA_SMS_IS91EP_SHORT_MESSAGE_FULL = 0x83,
+    RIL_CDMA_SMS_IS91EP_CLI_ORDER          = 0x84,
+    RIL_CDMA_SMS_IS91EP_SHORT_MESSAGE      = 0x85,
+    RIL_CDMA_SMS_IS91EP_MAX32              = 0x10000000
+
+} RIL_CDMA_SMS_IS91EPType;
+
+typedef struct {
+    /* NOTE: If message_id.udh_present == TRUE:
+    **       'num_headers' is the number of User Data Headers (UDHs),
+    **       and 'headers' include all those headers.
+    */
+    unsigned char                              num_headers;
+    RIL_CDMA_SMS_Udh                     headers[RIL_CDMA_SMS_MAX_UD_HEADERS];
+
+    RIL_CDMA_SMS_UserDataEncoding      encoding;
+    RIL_CDMA_SMS_IS91EPType             is91ep_type;
+
+    /*----------------------------------------------------------------------
+     'data_len' indicates the valid number of bytes in the 'data' array.
+
+     'padding_bits' (0-7) indicates how many bits in the last byte of 'data'
+     are invalid bits. This parameter is only used for Mobile-Originated
+     messages. There is no way for the API to tell how many padding bits
+     exist in the received message. Instead, the application can find out how
+     many padding bits exist in the user data when decoding the user data.
+
+     'data' has the raw bits of the user data field of the SMS message.
+     The client software should decode the raw user data according to its
+     supported encoding types and languages.
+
+     EXCEPTION 1: CMT-91 user data raw bits are first translated into BD fields
+     (e.g. num_messages, callback, etc.) The translated user data field in
+     VMN and Short Message is in the form of ASCII characters, each occupying
+     a byte in the resulted 'data'.
+
+     EXCEPTION 2: GSM 7-bit Default characters are decoded so that each byte
+     has one 7-bit GSM character.
+
+     'number_of_digits' is the number of digits/characters (7, 8, 16, or
+     whatever bits) in the raw user data, which can be used by the client
+     when decoding the user data according to the encoding type and language.
+    -------------------------------------------------------------------------*/
+    unsigned char                                data_len;
+    unsigned char                                padding_bits;
+    unsigned char                                data[ RIL_CDMA_SMS_USER_DATA_MAX ];
+    unsigned char                                number_of_digits;
+
+} RIL_CDMA_SMS_CdmaUserData;
+
+/* -------------------- */
+/* ---- Message Id ---- */
+/* -------------------- */
+typedef enum {
+    RIL_CDMA_SMS_BD_TYPE_RESERVED_0     = 0,
+    RIL_CDMA_SMS_BD_TYPE_DELIVER,       /* MT only */
+    RIL_CDMA_SMS_BD_TYPE_SUBMIT,        /* MO only */
+    RIL_CDMA_SMS_BD_TYPE_CANCELLATION,  /* MO only */
+    RIL_CDMA_SMS_BD_TYPE_DELIVERY_ACK,  /* MT only */
+    RIL_CDMA_SMS_BD_TYPE_USER_ACK,      /* MT & MO */
+    RIL_CDMA_SMS_BD_TYPE_READ_ACK,      /* MT & MO */
+    RIL_CDMA_SMS_BD_TYPE_MAX32          = 0x10000000
+
+} RIL_CDMA_SMS_BdMessageType;
+
+typedef unsigned int  RIL_CDMA_SMS_MessageNumber;
+
+typedef struct {
+    RIL_CDMA_SMS_BdMessageType   type;
+    RIL_CDMA_SMS_MessageNumber      id_number;
+    unsigned char                      udh_present;
+    /* NOTE: if FEATURE_SMS_UDH is not defined,
+    ** udh_present should be ignored.
+    */
+} RIL_CDMA_SMS_MessageId;
+
+typedef unsigned char           RIL_CDMA_SMS_UserResponse;
+
+/* ------------------- */
+/* ---- Timestamp ---- */
+/* ------------------- */
+typedef struct {
+    /* If 'year' is between 96 and 99, the actual year is 1900 + 'year';
+       if 'year' is between 00 and 95, the actual year is 2000 + 'year'.
+       NOTE: Each field has two BCD digits and byte arrangement is <MSB, ... ,LSB>
+    */
+    unsigned char      year;        /* 0x00-0x99 */
+    unsigned char      month;       /* 0x01-0x12 */
+    unsigned char      day;         /* 0x01-0x31 */
+    unsigned char      hour;        /* 0x00-0x23 */
+    unsigned char      minute;      /* 0x00-0x59 */
+    unsigned char      second;      /* 0x00-0x59 */
+    signed char      timezone;    /* +/-, [-48,+48] number of 15 minutes - GW only */
+} RIL_CDMA_SMS_Timestamp;
+
+/* ------------------ */
+/* ---- Priority ---- */
+/* ------------------ */
+typedef enum {
+    RIL_CDMA_SMS_PRIORITY_NORMAL      = 0,
+    RIL_CDMA_SMS_PRIORITY_INTERACTIVE,
+    RIL_CDMA_SMS_PRIORITY_URGENT,
+    RIL_CDMA_SMS_PRIORITY_EMERGENCY,
+    RIL_CDMA_SMS_PRIORITY_MAX32       = 0x10000000
+
+} RIL_CDMA_SMS_Priority;
+
+/* ----------------- */
+/* ---- Privacy ---- */
+/* ----------------- */
+typedef enum {
+    RIL_CDMA_SMS_PRIVACY_NORMAL      = 0,
+    RIL_CDMA_SMS_PRIVACY_RESTRICTED,
+    RIL_CDMA_SMS_PRIVACY_CONFIDENTIAL,
+    RIL_CDMA_SMS_PRIVACY_SECRET,
+    RIL_CDMA_SMS_PRIVACY_MAX32       = 0x10000000
+
+} RIL_CDMA_SMS_Privacy;
+
+/* ---------------------- */
+/* ---- Reply option ---- */
+/* ---------------------- */
+typedef struct {
+    /* whether user ack is requested
+    */
+    unsigned char          user_ack_requested;
+
+    /* whether delivery ack is requested.
+       Should be FALSE for incoming messages.
+    */
+    unsigned char          delivery_ack_requested;
+
+    /* Message originator requests the receiving phone to send back a READ_ACK
+    ** message automatically when the user reads the received message.
+    */
+    unsigned char          read_ack_requested;
+
+} RIL_CDMA_SMS_ReplyOption;
+
+typedef enum {
+    RIL_CDMA_SMS_ALERT_MODE_DEFAULT         = 0,
+    RIL_CDMA_SMS_ALERT_MODE_LOW_PRIORITY    = 1,
+    RIL_CDMA_SMS_ALERT_MODE_MEDIUM_PRIORITY = 2,
+    RIL_CDMA_SMS_ALERT_MODE_HIGH_PRIORITY   = 3,
+
+    /* For pre-IS637A implementations, alert_mode only has values of True/False:
+    */
+    RIL_CDMA_SMS_ALERT_MODE_OFF   = 0,
+    RIL_CDMA_SMS_ALERT_MODE_ON    = 1
+
+} RIL_CDMA_SMS_AlertMode;
+
+/* ------------------ */
+/* ---- Language ---- */
+/* ------------------ */
+typedef enum {
+    RIL_CDMA_SMS_LANGUAGE_UNSPECIFIED = 0,
+    RIL_CDMA_SMS_LANGUAGE_ENGLISH,
+    RIL_CDMA_SMS_LANGUAGE_FRENCH,
+    RIL_CDMA_SMS_LANGUAGE_SPANISH,
+    RIL_CDMA_SMS_LANGUAGE_JAPANESE,
+    RIL_CDMA_SMS_LANGUAGE_KOREAN,
+    RIL_CDMA_SMS_LANGUAGE_CHINESE,
+    RIL_CDMA_SMS_LANGUAGE_HEBREW,
+    RIL_CDMA_SMS_LANGUAGE_MAX32       = 0x10000000
+
+} RIL_CDMA_SMS_Language;
+
+/* ---------------------------------- */
+/* ---------- Display Mode ---------- */
+/* ---------------------------------- */
+typedef enum {
+    RIL_CDMA_SMS_DISPLAY_MODE_IMMEDIATE   = 0,
+    RIL_CDMA_SMS_DISPLAY_MODE_DEFAULT     = 1,
+    RIL_CDMA_SMS_DISPLAY_MODE_USER_INVOKE = 2,
+    RIL_CDMA_SMS_DISPLAY_MODE_RESERVED    = 3
+} RIL_CDMA_SMS_DisplayMode;
+
+/* IS-637B parameters/fields
+*/
+
+/* ---------------------------------- */
+/* ---------- Delivery Status ------- */
+/* ---------------------------------- */
+typedef enum {
+    RIL_CDMA_SMS_DELIVERY_STATUS_ACCEPTED              = 0,    /* ERROR_CLASS_NONE */
+    RIL_CDMA_SMS_DELIVERY_STATUS_DEPOSITED_TO_INTERNET = 1,    /* ERROR_CLASS_NONE */
+    RIL_CDMA_SMS_DELIVERY_STATUS_DELIVERED             = 2,    /* ERROR_CLASS_NONE */
+    RIL_CDMA_SMS_DELIVERY_STATUS_CANCELLED             = 3,    /* ERROR_CLASS_NONE */
+
+    RIL_CDMA_SMS_DELIVERY_STATUS_NETWORK_CONGESTION  = 4,    /* ERROR_CLASS_TEMP & PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_NETWORK_ERROR       = 5,    /* ERROR_CLASS_TEMP & PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_CANCEL_FAILED       = 6,    /* ERROR_CLASS_PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_BLOCKED_DESTINATION = 7,    /* ERROR_CLASS_PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_TEXT_TOO_LONG       = 8,    /* ERROR_CLASS_PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_DUPLICATE_MESSAGE   = 9,    /* ERROR_CLASS_PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_INVALID_DESTINATION = 10,   /* ERROR_CLASS_PERM */
+    RIL_CDMA_SMS_DELIVERY_STATUS_MESSAGE_EXPIRED     = 13,   /* ERROR_CLASS_PERM */
+
+    RIL_CDMA_SMS_DELIVERY_STATUS_UNKNOWN_ERROR       = 0x1F  /* ERROR_CLASS_PERM */
+
+    /* All the other values are reserved */
+
+} RIL_CDMA_SMS_DeliveryStatusE;
+
+typedef struct {
+    RIL_CDMA_SMS_ErrorClass       error_class;
+    RIL_CDMA_SMS_DeliveryStatusE   status;
+} RIL_CDMA_SMS_DeliveryStatus;
+
+typedef struct {
+    unsigned char               address[RIL_CDMA_SMS_IP_ADDRESS_SIZE];
+    unsigned char             is_valid;
+} RIL_CDMA_SMS_IpAddress;
+
+/* This special parameter captures any unrecognized/proprietary parameters
+*/
+typedef struct {
+    unsigned char                         input_other_len;
+    unsigned char                         desired_other_len; /* used during decoding */
+    unsigned char                         * other_data;
+} RIL_CDMA_SMS_OtherParm;
+
+typedef struct {
+    /* the mask indicates which fields are present in this message */
+    unsigned int                        mask;
+
+    RIL_CDMA_SMS_MessageId         message_id;
+    RIL_CDMA_SMS_CdmaUserData     user_data;
+    RIL_CDMA_SMS_UserResponse        user_response;
+    RIL_CDMA_SMS_Timestamp          mc_time;
+    RIL_CDMA_SMS_Timestamp          validity_absolute;
+    RIL_CDMA_SMS_Timestamp          validity_relative;
+    RIL_CDMA_SMS_Timestamp          deferred_absolute;
+    RIL_CDMA_SMS_Timestamp          deferred_relative;
+    RIL_CDMA_SMS_Priority           priority;
+    RIL_CDMA_SMS_Privacy            privacy;
+    RIL_CDMA_SMS_ReplyOption       reply_option;
+    unsigned char                         num_messages;  /* the actual value; not BCDs */
+    RIL_CDMA_SMS_AlertMode         alert_mode;
+     /* For pre-IS-637A implementations, alert_mode is either Off or On. */
+    RIL_CDMA_SMS_Language           language;
+    RIL_CDMA_SMS_Address            callback;
+    RIL_CDMA_SMS_DisplayMode       display_mode;
+
+    RIL_CDMA_SMS_DeliveryStatus    delivery_status;
+    unsigned int                        deposit_index;
+
+    RIL_CDMA_SMS_IpAddress         ip_address;
+    unsigned char                         rsn_no_notify;
+
+    /* See function comments of wms_ts_decode() and
+    ** wms_ts_decode_cdma_bd_with_other() for details regarding 'other' parameters
+    */
+    RIL_CDMA_SMS_OtherParm         other;
+
+} RIL_CDMA_SMS_ClientBd;
+
+typedef struct {
+    unsigned char length;   /* length, in bytes, of the encoded SMS message */
+    unsigned char * data;   /* the encoded SMS message (max 255 bytes) */
+} RIL_CDMA_Encoded_SMS;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ANDROID_RIL_CDMA_SMS_H*/
diff --git a/rilsrc/include/telephony/ril_msim.h b/rilsrc/include/telephony/ril_msim.h
new file mode 100644
index 0000000..5c0b8c5
--- /dev/null
+++ b/rilsrc/include/telephony/ril_msim.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef ANDROID_RIL_MSIM_H
+#define ANDROID_RIL_MSIM_H 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+  RIL_UICC_SUBSCRIPTION_DEACTIVATE = 0,
+  RIL_UICC_SUBSCRIPTION_ACTIVATE = 1
+} RIL_UiccSubActStatus;
+
+typedef enum {
+  RIL_SUBSCRIPTION_1 = 0,
+  RIL_SUBSCRIPTION_2 = 1,
+  RIL_SUBSCRIPTION_3 = 2
+} RIL_SubscriptionType;
+
+typedef struct {
+  int   slot;                        /* 0, 1, ... etc. */
+  int   app_index;                   /* array subscriptor from applications[RIL_CARD_MAX_APPS] in
+                                        RIL_REQUEST_GET_SIM_STATUS */
+  RIL_SubscriptionType  sub_type;    /* Indicates subscription 1 or subscription 2 */
+  RIL_UiccSubActStatus  act_status;
+} RIL_SelectUiccSub;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*ANDROID_RIL_MSIM_H*/
diff --git a/rilsrc/include/telephony/ril_nv_items.h b/rilsrc/include/telephony/ril_nv_items.h
new file mode 100644
index 0000000..748ea07
--- /dev/null
+++ b/rilsrc/include/telephony/ril_nv_items.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_RIL_NV_ITEMS_H
+#define ANDROID_RIL_NV_ITEMS_H 1
+
+#include <stdlib.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Must match the values in RadioNVItems.java in frameworks/opt/telephony. */
+typedef enum {
+
+    // CDMA radio and account information (items 1-10)
+    RIL_NV_CDMA_MEID = 1,                   // CDMA MEID (hex)
+    RIL_NV_CDMA_MIN = 2,                    // CDMA MIN (MSID)
+    RIL_NV_CDMA_MDN = 3,                    // CDMA MDN
+    RIL_NV_CDMA_ACCOLC = 4,                 // CDMA access overload control
+
+    // Carrier device provisioning (items 11-30)
+    RIL_NV_DEVICE_MSL = 11,                 // device MSL
+    RIL_NV_RTN_RECONDITIONED_STATUS = 12,   // RTN reconditioned status
+    RIL_NV_RTN_ACTIVATION_DATE = 13,        // RTN activation date
+    RIL_NV_RTN_LIFE_TIMER = 14,             // RTN life timer
+    RIL_NV_RTN_LIFE_CALLS = 15,             // RTN life calls
+    RIL_NV_RTN_LIFE_DATA_TX = 16,           // RTN life data TX
+    RIL_NV_RTN_LIFE_DATA_RX = 17,           // RTN life data RX
+    RIL_NV_OMADM_HFA_LEVEL = 18,            // HFA in progress
+
+    // Mobile IP profile information (items 31-50)
+    RIL_NV_MIP_PROFILE_NAI = 31,            // NAI realm
+    RIL_NV_MIP_PROFILE_HOME_ADDRESS = 32,   // MIP home address
+    RIL_NV_MIP_PROFILE_AAA_AUTH = 33,       // AAA auth
+    RIL_NV_MIP_PROFILE_HA_AUTH = 34,        // HA auth
+    RIL_NV_MIP_PROFILE_PRI_HA_ADDR = 35,    // primary HA address
+    RIL_NV_MIP_PROFILE_SEC_HA_ADDR = 36,    // secondary HA address
+    RIL_NV_MIP_PROFILE_REV_TUN_PREF = 37,   // reverse TUN preference
+    RIL_NV_MIP_PROFILE_HA_SPI = 38,         // HA SPI
+    RIL_NV_MIP_PROFILE_AAA_SPI = 39,        // AAA SPI
+    RIL_NV_MIP_PROFILE_MN_HA_SS = 40,       // HA shared secret
+    RIL_NV_MIP_PROFILE_MN_AAA_SS = 41,      // AAA shared secret
+
+    // CDMA network and band config (items 51-70)
+    RIL_NV_CDMA_PRL_VERSION = 51,           // CDMA PRL version
+    RIL_NV_CDMA_BC10 = 52,                  // CDMA band class 10
+    RIL_NV_CDMA_BC14 = 53,                  // CDMA band class 14
+    RIL_NV_CDMA_SO68 = 54,                  // CDMA SO68
+    RIL_NV_CDMA_SO73_COP0 = 55,             // CDMA SO73 COP0
+    RIL_NV_CDMA_SO73_COP1TO7 = 56,          // CDMA SO73 COP1-7
+    RIL_NV_CDMA_1X_ADVANCED_ENABLED = 57,   // CDMA 1X Advanced enabled
+    RIL_NV_CDMA_EHRPD_ENABLED = 58,         // CDMA eHRPD enabled
+    RIL_NV_CDMA_EHRPD_FORCED = 59,          // CDMA eHRPD forced
+
+    // LTE network and band config (items 71-90)
+    RIL_NV_LTE_BAND_ENABLE_25 = 71,         // LTE band 25 enable
+    RIL_NV_LTE_BAND_ENABLE_26 = 72,         // LTE band 26 enable
+    RIL_NV_LTE_BAND_ENABLE_41 = 73,         // LTE band 41 enable
+
+    RIL_NV_LTE_SCAN_PRIORITY_25 = 74,       // LTE band 25 scan priority
+    RIL_NV_LTE_SCAN_PRIORITY_26 = 75,       // LTE band 26 scan priority
+    RIL_NV_LTE_SCAN_PRIORITY_41 = 76,       // LTE band 41 scan priority
+
+    RIL_NV_LTE_HIDDEN_BAND_PRIORITY_25 = 77,    // LTE hidden band 25 priority
+    RIL_NV_LTE_HIDDEN_BAND_PRIORITY_26 = 78,    // LTE hidden band 26 priority
+    RIL_NV_LTE_HIDDEN_BAND_PRIORITY_41 = 79,    // LTE hidden band 41 priority
+
+} RIL_NV_Item;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ANDROID_RIL_NV_ITEMS_H */
diff --git a/rilsrc/libril/Android.mk b/rilsrc/libril/Android.mk
new file mode 100644
index 0000000..5fe80dc
--- /dev/null
+++ b/rilsrc/libril/Android.mk
@@ -0,0 +1,62 @@
+# Copyright 2006 The Android Open Source Project
+ifeq ($(BOARD_PROVIDES_LIBRIL),true)
+
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    ril.cpp \
+    ril_event.cpp\
+    RilSocket.cpp \
+    RilSapSocket.cpp \
+
+LOCAL_SHARED_LIBRARIES := \
+    liblog \
+    libutils \
+    libbinder \
+    libcutils \
+    libhardware_legacy \
+    librilutils \
+
+LOCAL_STATIC_LIBRARIES := \
+    libprotobuf-c-nano-enable_malloc \
+
+#LOCAL_CFLAGS := -DANDROID_MULTI_SIM -DDSDA_RILD1
+
+ifeq ($(SIM_COUNT), 2)
+    LOCAL_CFLAGS += -DANDROID_SIM_COUNT_2
+endif
+
+LOCAL_C_INCLUDES += external/nanopb-c
+LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
+LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/../include
+
+LOCAL_MODULE:= libril
+LOCAL_CLANG := true
+LOCAL_SANITIZE := integer
+
+include $(BUILD_SHARED_LIBRARY)
+
+
+# For RdoServD which needs a static library
+# =========================================
+ifneq ($(ANDROID_BIONIC_TRANSITION),)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    ril.cpp
+
+LOCAL_STATIC_LIBRARIES := \
+    libutils_static \
+    libcutils \
+    librilutils_static \
+    libprotobuf-c-nano-enable_malloc
+
+LOCAL_CFLAGS :=
+
+LOCAL_MODULE:= libril_static
+
+include $(BUILD_STATIC_LIBRARY)
+endif # ANDROID_BIONIC_TRANSITION
+
+endif # BOARD_PROVIDES_LIBRIL
\ No newline at end of file
diff --git a/rilsrc/libril/MODULE_LICENSE_APACHE2 b/rilsrc/libril/MODULE_LICENSE_APACHE2
new file mode 100644
index 0000000..e69de29
diff --git a/rilsrc/libril/NOTICE b/rilsrc/libril/NOTICE
new file mode 100644
index 0000000..c5b1efa
--- /dev/null
+++ b/rilsrc/libril/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2005-2008, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/rilsrc/libril/RilSapSocket.cpp b/rilsrc/libril/RilSapSocket.cpp
new file mode 100644
index 0000000..33eabb5
--- /dev/null
+++ b/rilsrc/libril/RilSapSocket.cpp
@@ -0,0 +1,514 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#define __STDC_LIMIT_MACROS
+#include <stdint.h>
+#define RIL_SHLIB
+#include "telephony/ril.h"
+#include "RilSapSocket.h"
+#include "pb_decode.h"
+#include "pb_encode.h"
+#undef LOG_TAG
+#define LOG_TAG "RIL_UIM_SOCKET"
+#include <utils/Log.h>
+#include <arpa/inet.h>
+#include <errno.h>
+
+static RilSapSocket::RilSapSocketList *head = NULL;
+
+void ril_sap_on_request_complete (
+        RIL_Token t, RIL_Errno e,
+        void *response, size_t responselen
+);
+
+void ril_sap_on_unsolicited_response (
+        int unsolResponse, const void *data,
+        size_t datalen
+);
+extern "C" void
+RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
+        const struct timeval *relativeTime);
+
+struct RIL_Env RilSapSocket::uimRilEnv = {
+        .OnRequestComplete = RilSapSocket::sOnRequestComplete,
+        .OnUnsolicitedResponse = RilSapSocket::sOnUnsolicitedResponse,
+        .RequestTimedCallback = RIL_requestTimedCallback
+};
+
+void RilSapSocket::sOnRequestComplete (RIL_Token t,
+        RIL_Errno e,
+        void *response,
+        size_t responselen) {
+    RilSapSocket *sap_socket;
+    SapSocketRequest *request = (SapSocketRequest*) t;
+
+    RLOGD("Socket id:%d", request->socketId);
+
+    sap_socket = getSocketById(request->socketId);
+
+    if (sap_socket) {
+        sap_socket->onRequestComplete(t,e,response,responselen);
+    } else {
+        RLOGE("Invalid socket id");
+        if (request->curr->payload) {
+            free(request->curr->payload);
+        }
+        free(request->curr);
+        free(request);
+    }
+}
+
+#if defined(ANDROID_MULTI_SIM)
+void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
+        const void *data,
+        size_t datalen,
+        RIL_SOCKET_ID socketId) {
+    RilSapSocket *sap_socket = getSocketById(socketId);
+    if (sap_socket) {
+        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
+    }
+}
+#else
+void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
+       const void *data,
+       size_t datalen) {
+    RilSapSocket *sap_socket = getSocketById(RIL_SOCKET_1);
+    sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
+}
+#endif
+
+void RilSapSocket::printList() {
+    RilSapSocketList *current = head;
+    RLOGD("Printing socket list");
+    while(NULL != current) {
+        RLOGD("SocketName:%s",current->socket->name);
+        RLOGD("Socket id:%d",current->socket->id);
+        current = current->next;
+    }
+}
+
+RilSapSocket *RilSapSocket::getSocketById(RIL_SOCKET_ID socketId) {
+    RilSapSocket *sap_socket;
+    RilSapSocketList *current = head;
+
+    RLOGD("Entered getSocketById");
+    printList();
+
+    while(NULL != current) {
+        if(socketId == current->socket->id) {
+            sap_socket = current->socket;
+            return sap_socket;
+        }
+        current = current->next;
+    }
+    return NULL;
+}
+
+void RilSapSocket::initSapSocket(const char *socketName,
+        RIL_RadioFunctions *uimFuncs) {
+
+    if (strcmp(socketName, "sap_uim_socket1") == 0) {
+        if(!SocketExists(socketName)) {
+            addSocketToList(socketName, RIL_SOCKET_1, uimFuncs);
+        }
+    }
+
+#if (SIM_COUNT >= 2)
+    if (strcmp(socketName, "sap_uim_socket2") == 0) {
+        if(!SocketExists(socketName)) {
+            addSocketToList(socketName, RIL_SOCKET_2, uimFuncs);
+        }
+    }
+#endif
+
+#if (SIM_COUNT >= 3)
+    if (strcmp(socketName, "sap_uim_socket3") == 0) {
+        if(!SocketExists(socketName)) {
+            addSocketToList(socketName, RIL_SOCKET_3, uimFuncs);
+        }
+    }
+#endif
+
+#if (SIM_COUNT >= 4)
+    if (strcmp(socketName, "sap_uim_socket4") == 0) {
+        if(!SocketExists(socketName)) {
+            addSocketToList(socketName, RIL_SOCKET_4, uimFuncs);
+        }
+    }
+#endif
+}
+
+void RilSapSocket::addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
+        RIL_RadioFunctions *uimFuncs) {
+    RilSapSocket* socket = NULL;
+    RilSapSocketList *current;
+
+    if(!SocketExists(socketName)) {
+        socket = new RilSapSocket(socketName, socketid, uimFuncs);
+        RilSapSocketList* listItem = (RilSapSocketList*)malloc(sizeof(RilSapSocketList));
+        if (!listItem) {
+            RLOGE("addSocketToList: OOM");
+            return;
+        }
+        listItem->socket = socket;
+        listItem->next = NULL;
+
+        RLOGD("Adding socket with id: %d", socket->id);
+
+        if(NULL == head) {
+            head = listItem;
+            head->next = NULL;
+        }
+        else {
+            current = head;
+            while(NULL != current->next) {
+                current = current->next;
+            }
+            current->next = listItem;
+        }
+        socket->socketInit();
+    }
+}
+
+bool RilSapSocket::SocketExists(const char *socketName) {
+    RilSapSocketList* current = head;
+
+    while(NULL != current) {
+        if(strcmp(current->socket->name, socketName) == 0) {
+            return true;
+        }
+        current = current->next;
+    }
+    return false;
+}
+
+void* RilSapSocket::processRequestsLoop(void) {
+    RLOGI("UIM_SOCKET:Request loop started");
+
+    while(true) {
+        SapSocketRequest *req = dispatchQueue.dequeue();
+
+        RLOGI("New request from the dispatch Queue");
+
+        if (req != NULL) {
+            dispatchRequest(req->curr);
+            free(req);
+        } else {
+            RLOGE("Fetched null buffer from queue!");
+        }
+    }
+    return NULL;
+}
+
+RilSapSocket::RilSapSocket(const char *socketName,
+        RIL_SOCKET_ID socketId,
+        RIL_RadioFunctions *inputUimFuncs):
+        RilSocket(socketName, socketId) {
+    if (inputUimFuncs) {
+        uimFuncs = inputUimFuncs;
+    }
+}
+
+#define BYTES_PER_LINE 16
+
+#define NIBBLE_TO_HEX(n) ({ \
+  uint8_t __n = (uint8_t) n & 0x0f; \
+  __nibble >= 10 ? 'A' + __n - 10: '0' + __n; \
+})
+
+#define HEX_HIGH(b) ({ \
+  uint8_t __b = (uint8_t) b; \
+  uint8_t __nibble = (__b >> 4) & 0x0f; \
+  NIBBLE_TO_HEX(__nibble); \
+})
+
+#define HEX_LOW(b) ({ \
+  uint8_t __b = (uint8_t) b; \
+  uint8_t __nibble = __b & 0x0f; \
+  NIBBLE_TO_HEX(__nibble); \
+})
+
+void log_hex(const char *who, const uint8_t *buffer, int length) {
+    char out[80];
+    int source = 0;
+    int dest = 0;
+    int dest_len = sizeof(out);
+    int per_line = 0;
+
+    do {
+        dest += sprintf(out, "%8.8s [%8.8x] ", who, source);
+        for(; source < length && dest_len - dest > 3 && per_line < BYTES_PER_LINE; source++,
+        per_line ++) {
+            out[dest++] = HEX_HIGH(buffer[source]);
+            out[dest++] = HEX_LOW(buffer[source]);
+            out[dest++] = ' ';
+        }
+        if (dest < dest_len && (per_line == BYTES_PER_LINE || source >= length)) {
+            out[dest++] = 0;
+            per_line = 0;
+            dest = 0;
+            RLOGD("%s\n", out);
+        }
+    } while(source < length && dest < dest_len);
+}
+
+void RilSapSocket::dispatchRequest(MsgHeader *req) {
+    // SapSocketRequest will be deallocated in onRequestComplete()
+    SapSocketRequest* currRequest=(SapSocketRequest*)malloc(sizeof(SapSocketRequest));
+    if (!currRequest) {
+        RLOGE("dispatchRequest: OOM");
+        // Free MsgHeader allocated in pushRecord()
+        free(req);
+        return;
+    }
+    currRequest->token = req->token;
+    currRequest->curr = req;
+    currRequest->p_next = NULL;
+    currRequest->socketId = id;
+
+    pendingResponseQueue.enqueue(currRequest);
+
+    if (uimFuncs) {
+        RLOGI("[%d] > SAP REQUEST type: %d. id: %d. error: %d",
+        req->token,
+        req->type,
+        req->id,
+        req->error );
+
+#if defined(ANDROID_MULTI_SIM)
+        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest, id);
+#else
+        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest);
+#endif
+    }
+}
+
+void RilSapSocket::onRequestComplete(RIL_Token t, RIL_Errno e, void *response,
+        size_t response_len) {
+    SapSocketRequest* request= (SapSocketRequest*)t;
+    MsgHeader *hdr = request->curr;
+
+    MsgHeader rsp;
+    rsp.token = request->curr->token;
+    rsp.type = MsgType_RESPONSE;
+    rsp.id = request->curr->id;
+    rsp.error = (Error)e;
+    rsp.payload = (pb_bytes_array_t *)calloc(1, sizeof(pb_bytes_array_t) + response_len);
+    if (!rsp.payload) {
+        RLOGE("onRequestComplete: OOM");
+    } else {
+        if (response && response_len > 0) {
+            memcpy(rsp.payload->bytes, response, response_len);
+            rsp.payload->size = response_len;
+        } else {
+            rsp.payload->size = 0;
+        }
+
+        RLOGE("Token:%d, MessageId:%d", hdr->token, hdr->id);
+
+        sendResponse(&rsp);
+        free(rsp.payload);
+    }
+
+    // Deallocate SapSocketRequest
+    if(!pendingResponseQueue.checkAndDequeue(hdr->id, hdr->token)) {
+        RLOGE("Token:%d, MessageId:%d", hdr->token, hdr->id);
+        RLOGE ("RilSapSocket::onRequestComplete: invalid Token or Message Id");
+    }
+
+    // Deallocate MsgHeader
+    free(hdr);
+}
+
+void RilSapSocket::sendResponse(MsgHeader* hdr) {
+    size_t encoded_size = 0;
+    uint32_t written_size;
+    size_t buffer_size = 0;
+    pb_ostream_t ostream;
+    bool success = false;
+
+    pthread_mutex_lock(&write_lock);
+
+    if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,
+        hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {
+        buffer_size = encoded_size + sizeof(uint32_t);
+        uint8_t* buffer = (uint8_t*)malloc(buffer_size);
+        if (!buffer) {
+            RLOGE("sendResponse: OOM");
+            pthread_mutex_unlock(&write_lock);
+            return;
+        }
+        written_size = htonl((uint32_t) encoded_size);
+        ostream = pb_ostream_from_buffer(buffer, buffer_size);
+        pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
+        success = pb_encode(&ostream, MsgHeader_fields, hdr);
+
+        if (success) {
+            RLOGD("Size: %zu (0x%zx) Size as written: 0x%x", encoded_size,
+                    encoded_size, written_size);
+            log_hex("onRequestComplete", &buffer[sizeof(written_size)], encoded_size);
+            RLOGI("[%d] < SAP RESPONSE type: %d. id: %d. error: %d",
+        hdr->token, hdr->type, hdr->id,hdr->error );
+
+            if ( 0 != blockingWrite_helper(commandFd, buffer, buffer_size)) {
+                RLOGE("Error %d while writing to fd", errno);
+            } else {
+                RLOGD("Write successful");
+            }
+        } else {
+            RLOGE("Error while encoding response of type %d id %d buffer_size: %zu: %s.",
+                    hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));
+        }
+        free(buffer);
+    } else {
+        RLOGE("Not sending response type %d: encoded_size: %zu. commandFd: %d. encoded size result:\
+                %d", hdr->type, encoded_size, commandFd, success);
+    }
+
+    pthread_mutex_unlock(&write_lock);
+}
+
+void RilSapSocket::onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen) {
+    if (data && datalen > 0) {
+        pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
+                sizeof(pb_bytes_array_t) + datalen);
+        if (!payload) {
+            RLOGE("onUnsolicitedResponse: OOM");
+            return;
+        }
+        memcpy(payload->bytes, data, datalen);
+        payload->size = datalen;
+        MsgHeader rsp;
+        rsp.payload = payload;
+        rsp.type = MsgType_UNSOL_RESPONSE;
+        rsp.id = (MsgId)unsolResponse;
+        rsp.error = Error_RIL_E_SUCCESS;
+        sendResponse(&rsp);
+        free(payload);
+    }
+}
+
+void RilSapSocket::pushRecord(void *p_record, size_t recordlen) {
+    pb_istream_t stream = pb_istream_from_buffer((uint8_t *)p_record, recordlen);
+    // MsgHeader will be deallocated in onRequestComplete()
+    MsgHeader *reqHeader = (MsgHeader *)malloc(sizeof (MsgHeader));
+    if (!reqHeader) {
+        RLOGE("pushRecord: OOM");
+        return;
+    }
+    memset(reqHeader, 0, sizeof(MsgHeader));
+
+    log_hex("BtSapTest-Payload", (const uint8_t*)p_record, recordlen);
+
+    if (!pb_decode(&stream, MsgHeader_fields, reqHeader) ) {
+        RLOGE("Error decoding protobuf buffer : %s", PB_GET_ERROR(&stream));
+        free(reqHeader);
+    } else {
+        // SapSocketRequest will be deallocated in processRequestsLoop()
+        SapSocketRequest *recv = (SapSocketRequest*)malloc(sizeof(SapSocketRequest));
+        if (!recv) {
+            RLOGE("pushRecord: OOM");
+            free(reqHeader);
+            return;
+        }
+        recv->token = reqHeader->token;
+        recv->curr = reqHeader;
+        recv->socketId = id;
+
+        dispatchQueue.enqueue(recv);
+    }
+}
+
+void RilSapSocket::sendDisconnect() {
+    size_t encoded_size = 0;
+    uint32_t written_size;
+    size_t buffer_size = 0;
+    pb_ostream_t ostream;
+    bool success = false;
+
+    RIL_SIM_SAP_DISCONNECT_REQ disconnectReq;
+
+   if ((success = pb_get_encoded_size(&encoded_size, RIL_SIM_SAP_DISCONNECT_REQ_fields,
+        &disconnectReq)) && encoded_size <= INT32_MAX) {
+        buffer_size = encoded_size + sizeof(uint32_t);
+        uint8_t* buffer = (uint8_t*)malloc(buffer_size);
+        if (!buffer) {
+            RLOGE("sendDisconnect: OOM");
+            return;
+        }
+        written_size = htonl((uint32_t) encoded_size);
+        ostream = pb_ostream_from_buffer(buffer, buffer_size);
+        pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
+        success = pb_encode(&ostream, RIL_SIM_SAP_DISCONNECT_REQ_fields, buffer);
+
+        if(success) {
+            // Buffer will be deallocated in sOnRequestComplete()
+            pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
+                    sizeof(pb_bytes_array_t) + written_size);
+            if (!payload) {
+                RLOGE("sendDisconnect: OOM");
+                return;
+            }
+            memcpy(payload->bytes, buffer, written_size);
+            payload->size = written_size;
+            // MsgHeader will be deallocated in sOnRequestComplete()
+            MsgHeader *hdr = (MsgHeader *)malloc(sizeof(MsgHeader));
+            if (!hdr) {
+                RLOGE("sendDisconnect: OOM");
+                free(payload);
+                return;
+            }
+            hdr->payload = payload;
+            hdr->type = MsgType_REQUEST;
+            hdr->id = MsgId_RIL_SIM_SAP_DISCONNECT;
+            hdr->error = Error_RIL_E_SUCCESS;
+            dispatchDisconnect(hdr);
+        }
+        else {
+            RLOGE("Encode failed in send disconnect!");
+        }
+        free(buffer);
+    }
+}
+
+void RilSapSocket::dispatchDisconnect(MsgHeader *req) {
+    // SapSocketRequest will be deallocated in sOnRequestComplete()
+    SapSocketRequest* currRequest=(SapSocketRequest*)malloc(sizeof(SapSocketRequest));
+    if (!currRequest) {
+        RLOGE("dispatchDisconnect: OOM");
+        // Free memory allocated in sendDisconnect
+        free(req->payload);
+        free(req);
+        return;
+    }
+    currRequest->token = -1;
+    currRequest->curr = req;
+    currRequest->p_next = NULL;
+    currRequest->socketId = (RIL_SOCKET_ID)99;
+
+    RLOGD("Sending disconnect on command close!");
+
+#if defined(ANDROID_MULTI_SIM)
+    uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest, id);
+#else
+    uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest);
+#endif
+}
+
+void RilSapSocket::onCommandsSocketClosed() {
+    sendDisconnect();
+    RLOGE("Socket command closed");
+}
diff --git a/rilsrc/libril/RilSapSocket.h b/rilsrc/libril/RilSapSocket.h
new file mode 100644
index 0000000..75c3965
--- /dev/null
+++ b/rilsrc/libril/RilSapSocket.h
@@ -0,0 +1,256 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef RIL_UIM_SOCKET_H_INCLUDED
+#define RIL_UIM_SOCKET_H_INCLUDED
+#define RIL_SHLIB
+#include "telephony/ril.h"
+#include "RilSocket.h"
+#include <hardware/ril/librilutils/proto/sap-api.pb.h>
+
+/**
+ * RilSapSocket is a derived class, derived from the RilSocket abstract
+ * class, representing sockets for communication between bluetooth SAP module and
+ * the ril daemon.
+ * <p>
+ * This class performs the following functions :
+ * <ul>
+ *     <li>Initialize the socket.
+ *     <li>Process the requests coming on the socket.
+ *     <li>Provide handlers for Unsolicited and request responses.
+ *     <li>Request and pending response queue handling.
+ * </ul>
+ */
+class RilSapSocket : public RilSocket {
+    /**
+     * Function pointer to the ril initialization funtion.
+     *
+     * @param Ril environment variable with place request and
+     *        response handlers and timeout handler.
+     *
+     * @param Number of arguements for the initialization function.
+     *
+     * @param Arguements to the initialization function used to
+     *        generate instance id of the ril daemon.
+     *
+     * @return Radio functions with handlers for onRequest, onStateRequest,
+     *         supports, onCancel and getVersion.
+     */
+    RIL_RadioFunctions *(*UimInit)(const struct RIL_Env *, int argc, char **argv);
+
+    /**
+     * Place holder for the radio functions returned by the initialization
+     * function. Currenty only onRequest handler is being used.
+     */
+    RIL_RadioFunctions* uimFuncs;
+
+    /**
+     * Wrapper struct for handling the requests in the queue.
+     */
+    typedef struct SapSocketRequest {
+        int token;
+        MsgHeader* curr;
+        struct SapSocketRequest* p_next;
+        RIL_SOCKET_ID socketId;
+    } SapSocketRequest;
+
+    /**
+     * Queue for requests that are pending dispatch.
+     */
+    Ril_queue<SapSocketRequest> dispatchQueue;
+
+    /**
+     * Queue for requests that are dispatched but are pending response
+     */
+    Ril_queue<SapSocketRequest> pendingResponseQueue;
+
+    public:
+        /**
+         * Initialize the socket and add the socket to the list.
+         *
+         * @param Name of the socket.
+         * @param Radio functions to be used by the socket.
+         */
+        static void initSapSocket(const char *socketName,
+        RIL_RadioFunctions *uimFuncs);
+
+        /**
+         * Ril envoronment variable that holds the request and
+         * unsol response handlers.
+         */
+        static struct RIL_Env uimRilEnv;
+
+        /**
+         * Function to print the socket list.
+         */
+        static void printList();
+
+        /**
+         * Clean up method to be called on command close.
+         */
+        void onCommandsSocketClosed(void);
+
+        /**
+         * Datatype to handle the socket list.
+         */
+        typedef struct RilSapSocketList {
+            RilSapSocket* socket;
+            RilSapSocketList *next;
+        } RilSapSocketList;
+
+    protected:
+        /**
+         * Process each record read from the socket and
+         * push a new request created from that record to
+         * the dispatch request queue.
+         *
+         * @param The record data.
+         * @param The record length.
+         */
+        void pushRecord(void *record, size_t recordlen);
+
+        /**
+         * Socket handler to be called when a request has
+         * been completed.
+         *
+         * @param Token associated with the request.
+         * @param Error, if any, while processing the request.
+         * @param The response payload.
+         * @param Response payload length.
+         */
+        void onRequestComplete(RIL_Token t,RIL_Errno e,
+        void *response, size_t response_len);
+
+        /**
+         * Socket handler to be called when there is an
+         * unsolicited response.
+         *
+         * @param Message id.
+         * @param Response data.
+         * @param Response data length.
+         */
+        void onUnsolicitedResponse(int unsolResponse,
+        void *data, size_t datalen);
+
+        /**
+         * Class method to get the socket from the socket list.
+         *
+         * @param Socket id.
+         * @return the sap socket.
+         */
+        static RilSapSocket* getSocketById(RIL_SOCKET_ID socketId);
+
+        /**
+         * Method to send response to SAP. It does an atomic write operation on the
+         * socket.
+         *
+         * @param the response header with the payload.
+         */
+        void sendResponse(MsgHeader *hdr);
+
+        /**
+         * A loop for processing the requests in the request dispatch queue.
+         */
+        void *processRequestsLoop(void);
+
+        /**
+         * Class method to add the sap socket to the list of sockets.
+         * Does nothing if the socket is already present in the list.
+         * Otherwise, calls the constructor of the parent class(To startlistening)
+         * and add socket to the socket list.
+         */
+        static void addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
+        RIL_RadioFunctions *uimFuncs);
+
+        /**
+         * Check if a socket of the given name exists in the socket list.
+         *
+         * @param Socket name.
+         * @return true if exists, false otherwise.
+         */
+        static bool SocketExists(const char *socketName);
+
+        /**
+         * Send a clean up SAP DISCONNECT if the socket disconnects before doing a SAP
+         * disconnect.
+         */
+        void sendDisconnect(void);
+
+        /**
+         * Dispatch the clean up disconnect request.
+         */
+        void dispatchDisconnect(MsgHeader *req);
+
+
+    private:
+        /**
+         * Constructor.
+         *
+         * @param Socket name.
+         * @param Socket id.
+         * @param Radio functions.
+         */
+        RilSapSocket(const char *socketName,
+        RIL_SOCKET_ID socketId,
+        RIL_RadioFunctions *inputUimFuncs);
+
+        /**
+         * Dispatches the request to the lower layers.
+         * It calls the on request function.
+         *
+         * @param The request message.
+         */
+        void dispatchRequest(MsgHeader *request);
+
+        /**
+         * Class method that selects the socket on which the onRequestComplete
+         * is called.
+         *
+         * @param Token associated with the request.
+         * @param Error, if any, while processing the request.
+         * @param The response payload.
+         * @param Response payload length.
+         */
+        static void sOnRequestComplete(RIL_Token t,
+        RIL_Errno e, void *response, size_t responselen);
+
+#if defined(ANDROID_MULTI_SIM)
+        /**
+         * Class method that selects the socket on which the onUnsolicitedResponse
+         * is called.
+         *
+         * @param Message id.
+         * @param Response data.
+         * @param Response data length.
+         * @param Socket id.
+         */
+        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
+        size_t datalen, RIL_SOCKET_ID socket_id);
+#else
+        /**
+         * Class method that selects the socket on which the onUnsolicitedResponse
+         * is called.
+         *
+         * @param Message id.
+         * @param Response data.
+         * @param Response data length.
+         */
+        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
+        size_t datalen);
+#endif
+};
+
+#endif /*RIL_UIM_SOCKET_H_INCLUDED*/
diff --git a/rilsrc/libril/RilSocket.cpp b/rilsrc/libril/RilSocket.cpp
new file mode 100644
index 0000000..a002d94
--- /dev/null
+++ b/rilsrc/libril/RilSocket.cpp
@@ -0,0 +1,177 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+extern "C"
+void *ril_socket_process_requests_loop(void *arg);
+
+#include "RilSocket.h"
+#include <cutils/sockets.h>
+#include <utils/Log.h>
+#include <assert.h>
+#define SOCKET_LISTEN_BACKLOG 0
+
+int RilSocket::socketInit(void) {
+    int ret;
+
+    listenCb = &RilSocket::sSocketListener;
+    commandCb = &RilSocket::sSocketRequestsHandler;
+    listenFd = android_get_control_socket(name);
+
+    //Start listening
+    ret = listen(listenFd, SOCKET_LISTEN_BACKLOG);
+
+    if (ret < 0) {
+        RLOGE("Failed to listen on %s socket '%d': %s",
+        name, listenFd, strerror(errno));
+        return ret;
+    }
+    //Add listen event to the event loop
+    ril_event_set(&listenEvent, listenFd, false, listenCb, this);
+    rilEventAddWakeup_helper(&listenEvent);
+    return ret;
+}
+
+void RilSocket::sSocketListener(int fd, short flags, void *param) {
+    RilSocket *theSocket = (RilSocket *) param;
+    MySocketListenParam listenParam;
+    listenParam.socket = theSocket;
+    listenParam.sListenParam.type = RIL_SAP_SOCKET;
+
+    listenCallback_helper(fd, flags, (void*)&listenParam);
+}
+
+void RilSocket::onNewCommandConnect() {
+    pthread_attr_t attr;
+    PthreadPtr pptr = ril_socket_process_requests_loop;
+    int result;
+
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    //Start socket request processing loop thread
+    result = pthread_create(&socketThreadId, &attr, pptr, this);
+    if(result < 0) {
+        RLOGE("pthread_create failed with result:%d",result);
+    }
+
+    RLOGE("New socket command connected and socket request thread started");
+}
+
+void RilSocket::sSocketRequestsHandler(int fd, short flags, void *param) {
+    socketClient *sc = (socketClient *) param;
+    RilSocket *theSocket = sc->socketPtr;
+    RecordStream *rs = sc->rs;
+
+    theSocket->socketRequestsHandler(fd, flags, rs);
+}
+
+void RilSocket::socketRequestsHandler(int fd, short flags, RecordStream *p_rs) {
+    int ret;
+    assert(fd == commandFd);
+    void *p_record;
+    size_t recordlen;
+
+    for (;;) {
+        /* loop until EAGAIN/EINTR, end of stream, or other error */
+        ret = record_stream_get_next(p_rs, &p_record, &recordlen);
+
+        if (ret == 0 && p_record == NULL) {
+            /* end-of-stream */
+            break;
+        } else if (ret < 0) {
+            break;
+        } else if (ret == 0) {
+            pushRecord(p_record, recordlen);
+        }
+    }
+
+    if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
+        /* fatal error or end-of-stream */
+        if (ret != 0) {
+            RLOGE("error on reading command socket errno:%d\n", errno);
+        } else {
+            RLOGW("EOS.  Closing command socket.");
+        }
+
+        close(commandFd);
+        commandFd = -1;
+
+        ril_event_del(&callbackEvent);
+
+        record_stream_free(p_rs);
+
+        /* start listening for new connections again */
+
+        rilEventAddWakeup_helper(&listenEvent);
+
+        onCommandsSocketClosed();
+    }
+}
+
+void RilSocket::setListenFd(int fd) {
+    listenFd = fd;
+}
+
+void RilSocket::setCommandFd(int fd) {
+    commandFd = fd;
+}
+
+int RilSocket::getListenFd(void) {
+    return listenFd;
+}
+
+int RilSocket::getCommandFd(void) {
+    return commandFd;
+}
+
+void RilSocket::setListenCb(ril_event_cb cb) {
+    listenCb = cb;
+}
+
+void RilSocket::setCommandCb(ril_event_cb cb) {
+    commandCb = cb;
+}
+
+ril_event_cb RilSocket::getListenCb(void) {
+    return listenCb;
+}
+
+ril_event_cb RilSocket::getCommandCb(void) {
+    return commandCb;
+}
+
+void RilSocket::setListenEvent(ril_event event) {
+    listenEvent = event;
+}
+
+void RilSocket::setCallbackEvent(ril_event event) {
+    callbackEvent = event;
+}
+
+ril_event* RilSocket::getListenEvent(void)  {
+    return &listenEvent;
+}
+
+ril_event* RilSocket::getCallbackEvent(void) {
+    return &callbackEvent;
+}
+
+extern "C"
+void *ril_socket_process_requests_loop(void *arg) {
+    RilSocket *socket = (RilSocket *)arg;
+    socket->processRequestsLoop();
+    return NULL;
+}
diff --git a/rilsrc/libril/RilSocket.h b/rilsrc/libril/RilSocket.h
new file mode 100644
index 0000000..619401a
--- /dev/null
+++ b/rilsrc/libril/RilSocket.h
@@ -0,0 +1,272 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef RIL_SOCKET_H_INCLUDED
+#define RIL_SOCKET_H_INCLUDED
+#include <libril/ril_ex.h>
+#include "rilSocketQueue.h"
+#include <ril_event.h>
+
+using namespace std;
+
+extern "C" void *ril_socket_process_requests_loop(void *arg);
+
+/**
+ * Abstract socket class representing sockets in rild.
+ * <p>
+ * This class performs the following functions :
+ * <ul>
+ *     <li> Start socket listen.
+ *     <li> Handle socket listen and command callbacks.
+ * </ul>
+ */
+class RilSocket {
+    protected:
+
+        /**
+         * Socket name.
+         */
+        const char* name;
+
+        /**
+         * Socket id.
+         */
+        RIL_SOCKET_ID id;
+
+       /**
+        * Listen socket file descriptor.
+        */
+        int listenFd = -1;
+
+       /**
+        * Commands socket file descriptor.
+        */
+        int commandFd = -1;
+
+       /**
+        * Socket request loop thread id.
+        */
+        pthread_t socketThreadId;
+
+       /**
+        * Listen event callack. Callback called when the other ends does accept.
+        */
+        ril_event_cb listenCb;
+
+       /**
+        * Commands event callack.Callback called when there are requests from the other side.
+        */
+        ril_event_cb commandCb;
+
+        /**
+         * Listen event to be added to eventloop after socket listen.
+         */
+        struct ril_event listenEvent;
+
+        /**
+         * Commands event to be added to eventloop after accept.
+         */
+        struct ril_event callbackEvent;
+
+        /**
+         * Static socket listen handler. Chooses the socket to call the listen callback
+         * from ril.cpp.
+         *
+         * @param Listen fd.
+         * @param flags.
+         * @param Parameter for the listen handler.
+         */
+        static void sSocketListener(int fd, short flags, void *param);
+
+        /**
+         * Static socket request handler. Chooses the socket to call the request handler on.
+         *
+         * @param Commands fd.
+         * @param flags.
+         * @param Parameter for the request handler.
+         */
+        static void sSocketRequestsHandler(int fd, short flags, void *param);
+
+        /**
+         * Process record from the record stream and push the requests onto the queue.
+         *
+         * @param record data.
+         * @param record length.
+         */
+        virtual void pushRecord(void *record, size_t recordlen) = 0;
+
+        /**
+         * Socket lock for writing data on the socket.
+         */
+        pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER;
+
+        /**
+         * The loop to process the incoming requests.
+         */
+        virtual void *processRequestsLoop(void) = 0;
+
+    private:
+        friend void *::ril_socket_process_requests_loop(void *arg);
+
+    public:
+
+        /**
+         * Constructor.
+         *
+         * @param Socket name.
+         * @param Socket id.
+         */
+        RilSocket(const char* socketName, RIL_SOCKET_ID socketId) {
+            name = socketName;
+            id = socketId;
+        }
+
+        /**
+         * Clean up function on commands socket close.
+         */
+        virtual void onCommandsSocketClosed(void) = 0;
+
+        /**
+         * Function called on new commands socket connect. Request loop thread is started here.
+         */
+        void onNewCommandConnect(void);
+
+        /**
+         * Set listen socket fd.
+         *
+         * @param Input fd.
+         */
+        void setListenFd(int listenFd);
+
+        /**
+         * Set commands socket fd.
+         *
+         * @param Input fd.
+         */
+        void setCommandFd(int commandFd);
+
+        /**
+         * Get listen socket fd.
+         *
+         * @return Listen fd.
+         */
+        int getListenFd(void);
+
+        /**
+         * Get commands socket fd.
+         *
+         * @return Commands fd.
+         */
+        int getCommandFd(void);
+
+        /**
+         * Set listen event callback.
+         *
+         * @param Input event callback.
+         */
+        void setListenCb(ril_event_cb listenCb);
+
+        /**
+         * Set command event callback.
+         *
+         * @param Input event callback.
+         */
+        void setCommandCb(ril_event_cb commandCb);
+
+        /**
+         * Get listen event callback.
+         *
+         * @return Listen event callback.
+         */
+        ril_event_cb getListenCb(void);
+
+        /**
+         * Gey command event callback.
+         *
+         * @return Command event callback.
+         */
+        ril_event_cb getCommandCb(void);
+
+        /**
+         * Set listen event.
+         *
+         * @param Input event.
+         */
+        void setListenEvent(ril_event listenEvent);
+
+        /**
+         * Set command callback event.
+         *
+         * @param Input event.
+         */
+        void setCallbackEvent(ril_event commandEvent);
+
+        /**
+         * Get listen event.
+         *
+         * @return Listen event.
+         */
+        ril_event* getListenEvent(void);
+
+        /**
+         * Get commands callback event.
+         *
+         * @return Commands callback event.
+         */
+        ril_event* getCallbackEvent(void);
+
+        virtual ~RilSocket(){}
+
+    protected:
+
+        /**
+         * Start listening on the socket and add the socket listen callback event.
+         *
+         * @return Result of the socket listen.
+         */
+        int socketInit(void);
+
+        /**
+         * Socket request handler
+         *
+         * @param Commands fd.
+         * @param flags.
+         * @param Record stream.
+         */
+        void socketRequestsHandler(int fd, short flags, RecordStream *rs);
+};
+
+class socketClient {
+    public:
+        RilSocket *socketPtr;
+        RecordStream *rs;
+
+        socketClient(RilSocket *socketPtr, RecordStream *rs) {
+            this->socketPtr = socketPtr;
+            this->rs = rs;
+        }
+};
+
+typedef struct MySocketListenParam {
+    SocketListenParam sListenParam;
+    RilSocket *socket;
+} MySocketListenParam;
+
+typedef void* (RilSocket::*RilSocketFuncPtr)(void);
+typedef void (RilSocket::*RilSocketEventPtr)(int fd,short flags, void *param);
+typedef void* (*PthreadPtr)(void*);
+
+#endif
diff --git a/rilsrc/libril/ril.cpp b/rilsrc/libril/ril.cpp
new file mode 100644
index 0000000..d7744c0
--- /dev/null
+++ b/rilsrc/libril/ril.cpp
@@ -0,0 +1,5871 @@
+/* //device/libs/telephony/ril.cpp
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "RILC"
+
+#include <hardware_legacy/power.h>
+#include <telephony/ril.h>
+#include <telephony/ril_cdma_sms.h>
+#include <cutils/sockets.h>
+#include <cutils/jstring.h>
+#include <telephony/record_stream.h>
+#include <utils/Log.h>
+#include <utils/SystemClock.h>
+#include <pthread.h>
+#include <binder/Parcel.h>
+#include <cutils/jstring.h>
+#include <sys/types.h>
+#include <sys/limits.h>
+#include <sys/system_properties.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <time.h>
+#include <errno.h>
+#include <assert.h>
+#include <ctype.h>
+#include <sys/un.h>
+#include <assert.h>
+#include <netinet/in.h>
+#include <cutils/properties.h>
+#include <RilSapSocket.h>
+
+extern "C" void
+RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);
+
+extern "C" void
+RIL_onRequestAck(RIL_Token t);
+namespace android {
+
+#define PHONE_PROCESS "radio"
+#define BLUETOOTH_PROCESS "bluetooth"
+
+#define SOCKET_NAME_RIL "rild"
+#define SOCKET2_NAME_RIL "rild2"
+#define SOCKET3_NAME_RIL "rild3"
+#define SOCKET4_NAME_RIL "rild4"
+
+#define SOCKET_NAME_RIL_DEBUG "rild-debug"
+
+#define ANDROID_WAKE_LOCK_NAME "radio-interface"
+
+#define ANDROID_WAKE_LOCK_SECS 0
+#define ANDROID_WAKE_LOCK_USECS 200000
+
+#define PROPERTY_RIL_IMPL "gsm.version.ril-impl"
+
+// match with constant in RIL.java
+#define MAX_COMMAND_BYTES (8 * 1024)
+
+// Basically: memset buffers that the client library
+// shouldn't be using anymore in an attempt to find
+// memory usage issues sooner.
+#define MEMSET_FREED 1
+
+#define NUM_ELEMS(a)     (sizeof (a) / sizeof (a)[0])
+
+#define MIN(a,b) ((a)<(b) ? (a) : (b))
+
+/* Constants for response types */
+#define RESPONSE_SOLICITED 0
+#define RESPONSE_UNSOLICITED 1
+#define RESPONSE_SOLICITED_ACK 2
+#define RESPONSE_SOLICITED_ACK_EXP 3
+#define RESPONSE_UNSOLICITED_ACK_EXP 4
+
+/* Negative values for private RIL errno's */
+#define RIL_ERRNO_INVALID_RESPONSE -1
+#define RIL_ERRNO_NO_MEMORY -12
+
+// request, response, and unsolicited msg print macro
+#define PRINTBUF_SIZE 8096
+
+// Enable verbose logging
+#define VDBG 0
+
+// Enable RILC log
+#define RILC_LOG 0
+
+#if RILC_LOG
+    #define startRequest           sprintf(printBuf, "(")
+    #define closeRequest           sprintf(printBuf, "%s)", printBuf)
+    #define printRequest(token, req)           \
+            RLOGD("[%04d]> %s %s", token, requestToString(req), printBuf)
+
+    #define startResponse           sprintf(printBuf, "%s {", printBuf)
+    #define closeResponse           sprintf(printBuf, "%s}", printBuf)
+    #define printResponse           RLOGD("%s", printBuf)
+
+    #define clearPrintBuf           printBuf[0] = 0
+    #define removeLastChar          printBuf[strlen(printBuf)-1] = 0
+    #define appendPrintBuf(x...)    snprintf(printBuf, PRINTBUF_SIZE, x)
+#else
+    #define startRequest
+    #define closeRequest
+    #define printRequest(token, req)
+    #define startResponse
+    #define closeResponse
+    #define printResponse
+    #define clearPrintBuf
+    #define removeLastChar
+    #define appendPrintBuf(x...)
+#endif
+
+enum WakeType {DONT_WAKE, WAKE_PARTIAL};
+
+typedef struct {
+    int requestNumber;
+    void (*dispatchFunction) (Parcel &p, struct RequestInfo *pRI);
+    int(*responseFunction) (Parcel &p, void *response, size_t responselen);
+} CommandInfo;
+
+typedef struct {
+    int requestNumber;
+    int (*responseFunction) (Parcel &p, void *response, size_t responselen);
+    WakeType wakeType;
+} UnsolResponseInfo;
+
+typedef struct RequestInfo {
+    int32_t token;      //this is not RIL_Token
+    CommandInfo *pCI;
+    struct RequestInfo *p_next;
+    char cancelled;
+    char local;         // responses to local commands do not go back to command process
+    RIL_SOCKET_ID socket_id;
+    int wasAckSent;    // Indicates whether an ack was sent earlier
+} RequestInfo;
+
+typedef struct UserCallbackInfo {
+    RIL_TimedCallback p_callback;
+    void *userParam;
+    struct ril_event event;
+    struct UserCallbackInfo *p_next;
+} UserCallbackInfo;
+
+extern "C" const char * requestToString(int request);
+extern "C" const char * failCauseToString(RIL_Errno);
+extern "C" const char * callStateToString(RIL_CallState);
+extern "C" const char * radioStateToString(RIL_RadioState);
+extern "C" const char * rilSocketIdToString(RIL_SOCKET_ID socket_id);
+
+extern "C"
+char rild[MAX_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL;
+/*******************************************************************/
+
+RIL_RadioFunctions s_callbacks = {0, NULL, NULL, NULL, NULL, NULL};
+static int s_registerCalled = 0;
+
+static pthread_t s_tid_dispatch;
+static pthread_t s_tid_reader;
+static int s_started = 0;
+
+static int s_fdDebug = -1;
+static int s_fdDebug_socket2 = -1;
+
+static int s_fdWakeupRead;
+static int s_fdWakeupWrite;
+
+int s_wakelock_count = 0;
+
+static struct ril_event s_commands_event;
+static struct ril_event s_wakeupfd_event;
+static struct ril_event s_listen_event;
+static SocketListenParam s_ril_param_socket;
+
+static pthread_mutex_t s_pendingRequestsMutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t s_writeMutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t s_wakeLockCountMutex = PTHREAD_MUTEX_INITIALIZER;
+static RequestInfo *s_pendingRequests = NULL;
+
+#if (SIM_COUNT >= 2)
+static struct ril_event s_commands_event_socket2;
+static struct ril_event s_listen_event_socket2;
+static SocketListenParam s_ril_param_socket2;
+
+static pthread_mutex_t s_pendingRequestsMutex_socket2  = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t s_writeMutex_socket2            = PTHREAD_MUTEX_INITIALIZER;
+static RequestInfo *s_pendingRequests_socket2          = NULL;
+#endif
+
+#if (SIM_COUNT >= 3)
+static struct ril_event s_commands_event_socket3;
+static struct ril_event s_listen_event_socket3;
+static SocketListenParam s_ril_param_socket3;
+
+static pthread_mutex_t s_pendingRequestsMutex_socket3  = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t s_writeMutex_socket3            = PTHREAD_MUTEX_INITIALIZER;
+static RequestInfo *s_pendingRequests_socket3          = NULL;
+#endif
+
+#if (SIM_COUNT >= 4)
+static struct ril_event s_commands_event_socket4;
+static struct ril_event s_listen_event_socket4;
+static SocketListenParam s_ril_param_socket4;
+
+static pthread_mutex_t s_pendingRequestsMutex_socket4  = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t s_writeMutex_socket4            = PTHREAD_MUTEX_INITIALIZER;
+static RequestInfo *s_pendingRequests_socket4          = NULL;
+#endif
+
+static struct ril_event s_wake_timeout_event;
+static struct ril_event s_debug_event;
+
+
+static const struct timeval TIMEVAL_WAKE_TIMEOUT = {ANDROID_WAKE_LOCK_SECS,ANDROID_WAKE_LOCK_USECS};
+
+
+static pthread_mutex_t s_startupMutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_startupCond = PTHREAD_COND_INITIALIZER;
+
+static pthread_mutex_t s_dispatchMutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t s_dispatchCond = PTHREAD_COND_INITIALIZER;
+
+static RequestInfo *s_toDispatchHead = NULL;
+static RequestInfo *s_toDispatchTail = NULL;
+
+static UserCallbackInfo *s_last_wake_timeout_info = NULL;
+
+static void *s_lastNITZTimeData = NULL;
+static size_t s_lastNITZTimeDataSize;
+
+#if RILC_LOG
+    static char printBuf[PRINTBUF_SIZE];
+#endif
+
+/*******************************************************************/
+static int sendResponse (Parcel &p, RIL_SOCKET_ID socket_id);
+
+static void dispatchVoid (Parcel& p, RequestInfo *pRI);
+static void dispatchString (Parcel& p, RequestInfo *pRI);
+static void dispatchStrings (Parcel& p, RequestInfo *pRI);
+static void dispatchInts (Parcel& p, RequestInfo *pRI);
+static void dispatchDial (Parcel& p, RequestInfo *pRI);
+static void dispatchSIM_IO (Parcel& p, RequestInfo *pRI);
+static void dispatchSIM_APDU (Parcel& p, RequestInfo *pRI);
+static void dispatchCallForward(Parcel& p, RequestInfo *pRI);
+static void dispatchRaw(Parcel& p, RequestInfo *pRI);
+static void dispatchSmsWrite (Parcel &p, RequestInfo *pRI);
+static void dispatchDataCall (Parcel& p, RequestInfo *pRI);
+static void dispatchVoiceRadioTech (Parcel& p, RequestInfo *pRI);
+static void dispatchSetInitialAttachApn (Parcel& p, RequestInfo *pRI);
+static void dispatchCdmaSubscriptionSource (Parcel& p, RequestInfo *pRI);
+
+static void dispatchCdmaSms(Parcel &p, RequestInfo *pRI);
+static void dispatchImsSms(Parcel &p, RequestInfo *pRI);
+static void dispatchImsCdmaSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef);
+static void dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef);
+static void dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI);
+static void dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI);
+static void dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI);
+static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI);
+static void dispatchNVReadItem(Parcel &p, RequestInfo *pRI);
+static void dispatchNVWriteItem(Parcel &p, RequestInfo *pRI);
+static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI);
+static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI);
+static void dispatchDataProfile(Parcel &p, RequestInfo *pRI);
+static void dispatchRadioCapability(Parcel &p, RequestInfo *pRI);
+static void dispatchCarrierRestrictions(Parcel &p, RequestInfo *pRI);
+static int responseInts(Parcel &p, void *response, size_t responselen);
+static int responseFailCause(Parcel &p, void *response, size_t responselen);
+static int responseStrings(Parcel &p, void *response, size_t responselen);
+static int responseString(Parcel &p, void *response, size_t responselen);
+static int responseVoid(Parcel &p, void *response, size_t responselen);
+static int responseCallList(Parcel &p, void *response, size_t responselen);
+static int responseSMS(Parcel &p, void *response, size_t responselen);
+static int responseSIM_IO(Parcel &p, void *response, size_t responselen);
+static int responseCallForwards(Parcel &p, void *response, size_t responselen);
+static int responseDataCallList(Parcel &p, void *response, size_t responselen);
+static int responseSetupDataCall(Parcel &p, void *response, size_t responselen);
+static int responseRaw(Parcel &p, void *response, size_t responselen);
+static int responseSsn(Parcel &p, void *response, size_t responselen);
+static int responseSimStatus(Parcel &p, void *response, size_t responselen);
+static int responseGsmBrSmsCnf(Parcel &p, void *response, size_t responselen);
+static int responseCdmaBrSmsCnf(Parcel &p, void *response, size_t responselen);
+static int responseCdmaSms(Parcel &p, void *response, size_t responselen);
+static int responseCellList(Parcel &p, void *response, size_t responselen);
+static int responseCdmaInformationRecords(Parcel &p,void *response, size_t responselen);
+static int responseRilSignalStrength(Parcel &p,void *response, size_t responselen);
+static int responseCallRing(Parcel &p, void *response, size_t responselen);
+static int responseCdmaSignalInfoRecord(Parcel &p,void *response, size_t responselen);
+static int responseCdmaCallWaiting(Parcel &p,void *response, size_t responselen);
+static int responseSimRefresh(Parcel &p, void *response, size_t responselen);
+static int responseCellInfoList(Parcel &p, void *response, size_t responselen);
+static int responseHardwareConfig(Parcel &p, void *response, size_t responselen);
+static int responseDcRtInfo(Parcel &p, void *response, size_t responselen);
+static int responseRadioCapability(Parcel &p, void *response, size_t responselen);
+static int responseSSData(Parcel &p, void *response, size_t responselen);
+static int responseLceStatus(Parcel &p, void *response, size_t responselen);
+static int responseLceData(Parcel &p, void *response, size_t responselen);
+static int responseActivityData(Parcel &p, void *response, size_t responselen);
+static int responseCarrierRestrictions(Parcel &p, void *response, size_t responselen);
+static int responsePcoData(Parcel &p, void *response, size_t responselen);
+
+static int decodeVoiceRadioTechnology (RIL_RadioState radioState);
+static int decodeCdmaSubscriptionSource (RIL_RadioState radioState);
+static RIL_RadioState processRadioState(RIL_RadioState newRadioState);
+static void grabPartialWakeLock();
+static void releaseWakeLock();
+static void wakeTimeoutCallback(void *);
+
+static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType);
+
+static bool isDebuggable();
+
+#ifdef RIL_SHLIB
+#if defined(ANDROID_MULTI_SIM)
+extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen, RIL_SOCKET_ID socket_id);
+#else
+extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen);
+#endif
+#endif
+
+#if defined(ANDROID_MULTI_SIM)
+#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c), (d))
+#define CALL_ONREQUEST(a, b, c, d, e) s_callbacks.onRequest((a), (b), (c), (d), (e))
+#define CALL_ONSTATEREQUEST(a) s_callbacks.onStateRequest(a)
+#else
+#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c))
+#define CALL_ONREQUEST(a, b, c, d, e) s_callbacks.onRequest((a), (b), (c), (d))
+#define CALL_ONSTATEREQUEST(a) s_callbacks.onStateRequest()
+#endif
+
+static UserCallbackInfo * internalRequestTimedCallback
+    (RIL_TimedCallback callback, void *param,
+        const struct timeval *relativeTime);
+
+/** Index == requestNumber */
+static CommandInfo s_commands[] = {
+#include "ril_commands.h"
+};
+
+static UnsolResponseInfo s_unsolResponses[] = {
+#include "ril_unsol_commands.h"
+};
+
+/* For older RILs that do not support new commands RIL_REQUEST_VOICE_RADIO_TECH and
+   RIL_UNSOL_VOICE_RADIO_TECH_CHANGED messages, decode the voice radio tech from
+   radio state message and store it. Every time there is a change in Radio State
+   check to see if voice radio tech changes and notify telephony
+ */
+int voiceRadioTech = -1;
+
+/* For older RILs that do not support new commands RIL_REQUEST_GET_CDMA_SUBSCRIPTION_SOURCE
+   and RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED messages, decode the subscription
+   source from radio state and store it. Every time there is a change in Radio State
+   check to see if subscription source changed and notify telephony
+ */
+int cdmaSubscriptionSource = -1;
+
+/* For older RILs that do not send RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, decode the
+   SIM/RUIM state from radio state and store it. Every time there is a change in Radio State,
+   check to see if SIM/RUIM status changed and notify telephony
+ */
+int simRuimStatus = -1;
+
+static char * RIL_getRilSocketName() {
+    return rild;
+}
+
+extern "C"
+void RIL_setRilSocketName(const char * s) {
+    strncpy(rild, s, MAX_SOCKET_NAME_LENGTH);
+}
+
+static char *
+strdupReadString(Parcel &p) {
+    size_t stringlen;
+    const char16_t *s16;
+
+    s16 = p.readString16Inplace(&stringlen);
+
+    return strndup16to8(s16, stringlen);
+}
+
+static status_t
+readStringFromParcelInplace(Parcel &p, char *str, size_t maxLen) {
+    size_t s16Len;
+    const char16_t *s16;
+
+    s16 = p.readString16Inplace(&s16Len);
+    if (s16 == NULL) {
+        return NO_MEMORY;
+    }
+    size_t strLen = strnlen16to8(s16, s16Len);
+    if ((strLen + 1) > maxLen) {
+        return NO_MEMORY;
+    }
+    if (strncpy16to8(str, s16, strLen) == NULL) {
+        return NO_MEMORY;
+    } else {
+        return NO_ERROR;
+    }
+}
+
+static void writeStringToParcel(Parcel &p, const char *s) {
+    char16_t *s16;
+    size_t s16_len;
+    s16 = strdup8to16(s, &s16_len);
+    p.writeString16(s16, s16_len);
+    free(s16);
+}
+
+
+static void
+memsetString (char *s) {
+    if (s != NULL) {
+        memset (s, 0, strlen(s));
+    }
+}
+
+void   nullParcelReleaseFunction (const uint8_t* data, size_t dataSize,
+                                    const size_t* objects, size_t objectsSize,
+                                        void* cookie) {
+    // do nothing -- the data reference lives longer than the Parcel object
+}
+
+/**
+ * To be called from dispatch thread
+ * Issue a single local request, ensuring that the response
+ * is not sent back up to the command process
+ */
+static void
+issueLocalRequest(int request, void *data, int len, RIL_SOCKET_ID socket_id) {
+    RequestInfo *pRI;
+    int ret;
+    /* Hook for current context */
+    /* pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
+    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
+    /* pendingRequestsHook refer to &s_pendingRequests */
+    RequestInfo**    pendingRequestsHook = &s_pendingRequests;
+
+#if (SIM_COUNT == 2)
+    if (socket_id == RIL_SOCKET_2) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
+        pendingRequestsHook = &s_pendingRequests_socket2;
+    }
+#endif
+
+    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
+    if (pRI == NULL) {
+        RLOGE("Memory allocation failed for request %s", requestToString(request));
+        return;
+    }
+
+    pRI->local = 1;
+    pRI->token = 0xffffffff;        // token is not used in this context
+    pRI->pCI = &(s_commands[request]);
+    pRI->socket_id = socket_id;
+
+    ret = pthread_mutex_lock(pendingRequestsMutexHook);
+    assert (ret == 0);
+
+    pRI->p_next = *pendingRequestsHook;
+    *pendingRequestsHook = pRI;
+
+    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
+    assert (ret == 0);
+
+    RLOGD("C[locl]> %s", requestToString(request));
+
+    CALL_ONREQUEST(request, data, len, pRI, pRI->socket_id);
+}
+
+
+
+static int
+processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) {
+    Parcel p;
+    status_t status;
+    int32_t request;
+    int32_t token;
+    RequestInfo *pRI;
+    int ret;
+    /* Hook for current context */
+    /* pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
+    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
+    /* pendingRequestsHook refer to &s_pendingRequests */
+    RequestInfo**    pendingRequestsHook = &s_pendingRequests;
+
+    p.setData((uint8_t *) buffer, buflen);
+
+    // status checked at end
+    status = p.readInt32(&request);
+    status = p.readInt32 (&token);
+
+#if (SIM_COUNT >= 2)
+    if (socket_id == RIL_SOCKET_2) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
+        pendingRequestsHook = &s_pendingRequests_socket2;
+    }
+#if (SIM_COUNT >= 3)
+    else if (socket_id == RIL_SOCKET_3) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
+        pendingRequestsHook = &s_pendingRequests_socket3;
+    }
+#endif
+#if (SIM_COUNT >= 4)
+    else if (socket_id == RIL_SOCKET_4) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
+        pendingRequestsHook = &s_pendingRequests_socket4;
+    }
+#endif
+#endif
+
+    if (status != NO_ERROR) {
+        RLOGE("invalid request block");
+        return 0;
+    }
+
+    // Received an Ack for the previous result sent to RIL.java,
+    // so release wakelock and exit
+    if (request == RIL_RESPONSE_ACKNOWLEDGEMENT) {
+        releaseWakeLock();
+        return 0;
+    }
+
+    if (request < 1 || request >= (int32_t)NUM_ELEMS(s_commands)) {
+        Parcel pErr;
+        RLOGE("unsupported request code %d token %d", request, token);
+        // FIXME this should perhaps return a response
+        pErr.writeInt32 (RESPONSE_SOLICITED);
+        pErr.writeInt32 (token);
+        pErr.writeInt32 (RIL_E_GENERIC_FAILURE);
+
+        sendResponse(pErr, socket_id);
+        return 0;
+    }
+
+    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
+    if (pRI == NULL) {
+        RLOGE("Memory allocation failed for request %s", requestToString(request));
+        return 0;
+    }
+
+    pRI->token = token;
+    pRI->pCI = &(s_commands[request]);
+    pRI->socket_id = socket_id;
+
+    ret = pthread_mutex_lock(pendingRequestsMutexHook);
+    assert (ret == 0);
+
+    pRI->p_next = *pendingRequestsHook;
+    *pendingRequestsHook = pRI;
+
+    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
+    assert (ret == 0);
+
+/*    sLastDispatchedToken = token; */
+
+    pRI->pCI->dispatchFunction(p, pRI);
+
+    return 0;
+}
+
+static void
+invalidCommandBlock (RequestInfo *pRI) {
+    RLOGE("invalid command block for token %d request %s",
+                pRI->token, requestToString(pRI->pCI->requestNumber));
+}
+
+/** Callee expects NULL */
+static void
+dispatchVoid (Parcel& p, RequestInfo *pRI) {
+    clearPrintBuf;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+    CALL_ONREQUEST(pRI->pCI->requestNumber, NULL, 0, pRI, pRI->socket_id);
+}
+
+/** Callee expects const char * */
+static void
+dispatchString (Parcel& p, RequestInfo *pRI) {
+    status_t status;
+    size_t datalen;
+    size_t stringlen;
+    char *string8 = NULL;
+
+    string8 = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("%s%s", printBuf, string8);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, string8,
+                       sizeof(char *), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(string8);
+#endif
+
+    free(string8);
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/** Callee expects const char ** */
+static void
+dispatchStrings (Parcel &p, RequestInfo *pRI) {
+    int32_t countStrings;
+    status_t status;
+    size_t datalen;
+    char **pStrings;
+
+    status = p.readInt32 (&countStrings);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    startRequest;
+    if (countStrings == 0) {
+        // just some non-null pointer
+        pStrings = (char **)calloc(1, sizeof(char *));
+        if (pStrings == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            closeRequest;
+            return;
+        }
+
+        datalen = 0;
+    } else if (countStrings < 0) {
+        pStrings = NULL;
+        datalen = 0;
+    } else {
+        datalen = sizeof(char *) * countStrings;
+
+        pStrings = (char **)calloc(countStrings, sizeof(char *));
+        if (pStrings == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            closeRequest;
+            return;
+        }
+
+        for (int i = 0 ; i < countStrings ; i++) {
+            pStrings[i] = strdupReadString(p);
+            appendPrintBuf("%s%s,", printBuf, pStrings[i]);
+        }
+    }
+    removeLastChar;
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, pStrings, datalen, pRI, pRI->socket_id);
+
+    if (pStrings != NULL) {
+        for (int i = 0 ; i < countStrings ; i++) {
+#ifdef MEMSET_FREED
+            memsetString (pStrings[i]);
+#endif
+            free(pStrings[i]);
+        }
+
+#ifdef MEMSET_FREED
+        memset(pStrings, 0, datalen);
+#endif
+        free(pStrings);
+    }
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/** Callee expects const int * */
+static void
+dispatchInts (Parcel &p, RequestInfo *pRI) {
+    int32_t count;
+    status_t status;
+    size_t datalen;
+    int *pInts;
+
+    status = p.readInt32 (&count);
+
+    if (status != NO_ERROR || count <= 0) {
+        goto invalid;
+    }
+
+    datalen = sizeof(int) * count;
+    pInts = (int *)calloc(count, sizeof(int));
+    if (pInts == NULL) {
+        RLOGE("Memory allocation failed for request %s", requestToString(pRI->pCI->requestNumber));
+        return;
+    }
+
+    startRequest;
+    for (int i = 0 ; i < count ; i++) {
+        int32_t t;
+
+        status = p.readInt32(&t);
+        pInts[i] = (int)t;
+        appendPrintBuf("%s%d,", printBuf, t);
+
+        if (status != NO_ERROR) {
+            free(pInts);
+            goto invalid;
+        }
+   }
+   removeLastChar;
+   closeRequest;
+   printRequest(pRI->token, pRI->pCI->requestNumber);
+
+   CALL_ONREQUEST(pRI->pCI->requestNumber, const_cast<int *>(pInts),
+                       datalen, pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(pInts, 0, datalen);
+#endif
+    free(pInts);
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+
+/**
+ * Callee expects const RIL_SMS_WriteArgs *
+ * Payload is:
+ *   int32_t status
+ *   String pdu
+ */
+static void
+dispatchSmsWrite (Parcel &p, RequestInfo *pRI) {
+    RIL_SMS_WriteArgs args;
+    int32_t t;
+    status_t status;
+
+    RLOGD("dispatchSmsWrite");
+    memset (&args, 0, sizeof(args));
+
+    status = p.readInt32(&t);
+    args.status = (int)t;
+
+    args.pdu = strdupReadString(p);
+
+    if (status != NO_ERROR || args.pdu == NULL) {
+        goto invalid;
+    }
+
+    args.smsc = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("%s%d,%s,smsc=%s", printBuf, args.status,
+        (char*)args.pdu,  (char*)args.smsc);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &args, sizeof(args), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString (args.pdu);
+#endif
+
+    free (args.pdu);
+
+#ifdef MEMSET_FREED
+    memset(&args, 0, sizeof(args));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/**
+ * Callee expects const RIL_Dial *
+ * Payload is:
+ *   String address
+ *   int32_t clir
+ */
+static void
+dispatchDial (Parcel &p, RequestInfo *pRI) {
+    RIL_Dial dial;
+    RIL_UUS_Info uusInfo;
+    int32_t sizeOfDial;
+    int32_t t;
+    int32_t uusPresent;
+    status_t status;
+
+    RLOGD("dispatchDial");
+    memset (&dial, 0, sizeof(dial));
+
+    dial.address = strdupReadString(p);
+
+    status = p.readInt32(&t);
+    dial.clir = (int)t;
+
+    if (status != NO_ERROR || dial.address == NULL) {
+        goto invalid;
+    }
+
+    if (s_callbacks.version < 3) { // Remove when partners upgrade to version 3
+        uusPresent = 0;
+        sizeOfDial = sizeof(dial) - sizeof(RIL_UUS_Info *);
+    } else {
+        status = p.readInt32(&uusPresent);
+
+        if (status != NO_ERROR) {
+            goto invalid;
+        }
+
+        if (uusPresent == 0) {
+            dial.uusInfo = NULL;
+        } else {
+            int32_t len;
+
+            memset(&uusInfo, 0, sizeof(RIL_UUS_Info));
+
+            status = p.readInt32(&t);
+            uusInfo.uusType = (RIL_UUS_Type) t;
+
+            status = p.readInt32(&t);
+            uusInfo.uusDcs = (RIL_UUS_DCS) t;
+
+            status = p.readInt32(&len);
+            if (status != NO_ERROR) {
+                goto invalid;
+            }
+
+            // The java code writes -1 for null arrays
+            if (((int) len) == -1) {
+                uusInfo.uusData = NULL;
+                len = 0;
+            } else {
+                uusInfo.uusData = (char*) p.readInplace(len);
+            }
+
+            uusInfo.uusLength = len;
+            dial.uusInfo = &uusInfo;
+        }
+        sizeOfDial = sizeof(dial);
+    }
+
+    startRequest;
+    appendPrintBuf("%snum=%s,clir=%d", printBuf, dial.address, dial.clir);
+    if (uusPresent) {
+        appendPrintBuf("%s,uusType=%d,uusDcs=%d,uusLen=%d", printBuf,
+                dial.uusInfo->uusType, dial.uusInfo->uusDcs,
+                dial.uusInfo->uusLength);
+    }
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &dial, sizeOfDial, pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString (dial.address);
+#endif
+
+    free (dial.address);
+
+#ifdef MEMSET_FREED
+    memset(&uusInfo, 0, sizeof(RIL_UUS_Info));
+    memset(&dial, 0, sizeof(dial));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/**
+ * Callee expects const RIL_SIM_IO *
+ * Payload is:
+ *   int32_t command
+ *   int32_t fileid
+ *   String path
+ *   int32_t p1, p2, p3
+ *   String data
+ *   String pin2
+ *   String aidPtr
+ */
+static void
+dispatchSIM_IO (Parcel &p, RequestInfo *pRI) {
+    union RIL_SIM_IO {
+        RIL_SIM_IO_v6 v6;
+        RIL_SIM_IO_v5 v5;
+    } simIO;
+
+    int32_t t;
+    int size;
+    status_t status;
+
+#if VDBG
+    RLOGD("dispatchSIM_IO");
+#endif
+    memset (&simIO, 0, sizeof(simIO));
+
+    // note we only check status at the end
+
+    status = p.readInt32(&t);
+    simIO.v6.command = (int)t;
+
+    status = p.readInt32(&t);
+    simIO.v6.fileid = (int)t;
+
+    simIO.v6.path = strdupReadString(p);
+
+    status = p.readInt32(&t);
+    simIO.v6.p1 = (int)t;
+
+    status = p.readInt32(&t);
+    simIO.v6.p2 = (int)t;
+
+    status = p.readInt32(&t);
+    simIO.v6.p3 = (int)t;
+
+    simIO.v6.data = strdupReadString(p);
+    simIO.v6.pin2 = strdupReadString(p);
+    simIO.v6.aidPtr = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("%scmd=0x%X,efid=0x%X,path=%s,%d,%d,%d,%s,pin2=%s,aid=%s", printBuf,
+        simIO.v6.command, simIO.v6.fileid, (char*)simIO.v6.path,
+        simIO.v6.p1, simIO.v6.p2, simIO.v6.p3,
+        (char*)simIO.v6.data,  (char*)simIO.v6.pin2, simIO.v6.aidPtr);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    size = (s_callbacks.version < 6) ? sizeof(simIO.v5) : sizeof(simIO.v6);
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &simIO, size, pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString (simIO.v6.path);
+    memsetString (simIO.v6.data);
+    memsetString (simIO.v6.pin2);
+    memsetString (simIO.v6.aidPtr);
+#endif
+
+    free (simIO.v6.path);
+    free (simIO.v6.data);
+    free (simIO.v6.pin2);
+    free (simIO.v6.aidPtr);
+
+#ifdef MEMSET_FREED
+    memset(&simIO, 0, sizeof(simIO));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/**
+ * Callee expects const RIL_SIM_APDU *
+ * Payload is:
+ *   int32_t sessionid
+ *   int32_t cla
+ *   int32_t instruction
+ *   int32_t p1, p2, p3
+ *   String data
+ */
+static void
+dispatchSIM_APDU (Parcel &p, RequestInfo *pRI) {
+    int32_t t;
+    status_t status;
+    RIL_SIM_APDU apdu;
+
+#if VDBG
+    RLOGD("dispatchSIM_APDU");
+#endif
+    memset (&apdu, 0, sizeof(RIL_SIM_APDU));
+
+    // Note we only check status at the end. Any single failure leads to
+    // subsequent reads filing.
+    status = p.readInt32(&t);
+    apdu.sessionid = (int)t;
+
+    status = p.readInt32(&t);
+    apdu.cla = (int)t;
+
+    status = p.readInt32(&t);
+    apdu.instruction = (int)t;
+
+    status = p.readInt32(&t);
+    apdu.p1 = (int)t;
+
+    status = p.readInt32(&t);
+    apdu.p2 = (int)t;
+
+    status = p.readInt32(&t);
+    apdu.p3 = (int)t;
+
+    apdu.data = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("%ssessionid=%d,cla=%d,ins=%d,p1=%d,p2=%d,p3=%d,data=%s",
+        printBuf, apdu.sessionid, apdu.cla, apdu.instruction, apdu.p1, apdu.p2,
+        apdu.p3, (char*)apdu.data);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &apdu, sizeof(RIL_SIM_APDU), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(apdu.data);
+#endif
+    free(apdu.data);
+
+#ifdef MEMSET_FREED
+    memset(&apdu, 0, sizeof(RIL_SIM_APDU));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+
+/**
+ * Callee expects const RIL_CallForwardInfo *
+ * Payload is:
+ *  int32_t status/action
+ *  int32_t reason
+ *  int32_t serviceCode
+ *  int32_t toa
+ *  String number  (0 length -> null)
+ *  int32_t timeSeconds
+ */
+static void
+dispatchCallForward(Parcel &p, RequestInfo *pRI) {
+    RIL_CallForwardInfo cff;
+    int32_t t;
+    status_t status;
+
+    RLOGD("dispatchCallForward");
+    memset (&cff, 0, sizeof(cff));
+
+    // note we only check status at the end
+
+    status = p.readInt32(&t);
+    cff.status = (int)t;
+
+    status = p.readInt32(&t);
+    cff.reason = (int)t;
+
+    status = p.readInt32(&t);
+    cff.serviceClass = (int)t;
+
+    status = p.readInt32(&t);
+    cff.toa = (int)t;
+
+    cff.number = strdupReadString(p);
+
+    status = p.readInt32(&t);
+    cff.timeSeconds = (int)t;
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    // special case: number 0-length fields is null
+
+    if (cff.number != NULL && strlen (cff.number) == 0) {
+        cff.number = NULL;
+    }
+
+    startRequest;
+    appendPrintBuf("%sstat=%d,reason=%d,serv=%d,toa=%d,%s,tout=%d", printBuf,
+        cff.status, cff.reason, cff.serviceClass, cff.toa,
+        (char*)cff.number, cff.timeSeconds);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &cff, sizeof(cff), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(cff.number);
+#endif
+
+    free (cff.number);
+
+#ifdef MEMSET_FREED
+    memset(&cff, 0, sizeof(cff));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+
+static void
+dispatchRaw(Parcel &p, RequestInfo *pRI) {
+    int32_t len;
+    status_t status;
+    const void *data;
+
+    status = p.readInt32(&len);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    // The java code writes -1 for null arrays
+    if (((int)len) == -1) {
+        data = NULL;
+        len = 0;
+    }
+
+    data = p.readInplace(len);
+
+    startRequest;
+    appendPrintBuf("%sraw_size=%d", printBuf, len);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, const_cast<void *>(data), len, pRI, pRI->socket_id);
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static status_t
+constructCdmaSms(Parcel &p, RequestInfo *pRI, RIL_CDMA_SMS_Message& rcsm) {
+    int32_t  t;
+    uint8_t ut;
+    status_t status;
+    int32_t digitCount;
+    int digitLimit;
+
+    memset(&rcsm, 0, sizeof(rcsm));
+
+    status = p.readInt32(&t);
+    rcsm.uTeleserviceID = (int) t;
+
+    status = p.read(&ut,sizeof(ut));
+    rcsm.bIsServicePresent = (uint8_t) ut;
+
+    status = p.readInt32(&t);
+    rcsm.uServicecategory = (int) t;
+
+    status = p.readInt32(&t);
+    rcsm.sAddress.digit_mode = (RIL_CDMA_SMS_DigitMode) t;
+
+    status = p.readInt32(&t);
+    rcsm.sAddress.number_mode = (RIL_CDMA_SMS_NumberMode) t;
+
+    status = p.readInt32(&t);
+    rcsm.sAddress.number_type = (RIL_CDMA_SMS_NumberType) t;
+
+    status = p.readInt32(&t);
+    rcsm.sAddress.number_plan = (RIL_CDMA_SMS_NumberPlan) t;
+
+    status = p.read(&ut,sizeof(ut));
+    rcsm.sAddress.number_of_digits= (uint8_t) ut;
+
+    digitLimit= MIN((rcsm.sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&ut,sizeof(ut));
+        rcsm.sAddress.digits[digitCount] = (uint8_t) ut;
+    }
+
+    status = p.readInt32(&t);
+    rcsm.sSubAddress.subaddressType = (RIL_CDMA_SMS_SubaddressType) t;
+
+    status = p.read(&ut,sizeof(ut));
+    rcsm.sSubAddress.odd = (uint8_t) ut;
+
+    status = p.read(&ut,sizeof(ut));
+    rcsm.sSubAddress.number_of_digits = (uint8_t) ut;
+
+    digitLimit= MIN((rcsm.sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&ut,sizeof(ut));
+        rcsm.sSubAddress.digits[digitCount] = (uint8_t) ut;
+    }
+
+    status = p.readInt32(&t);
+    rcsm.uBearerDataLen = (int) t;
+
+    digitLimit= MIN((rcsm.uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&ut, sizeof(ut));
+        rcsm.aBearerData[digitCount] = (uint8_t) ut;
+    }
+
+    if (status != NO_ERROR) {
+        return status;
+    }
+
+    startRequest;
+    appendPrintBuf("%suTeleserviceID=%d, bIsServicePresent=%d, uServicecategory=%d, \
+            sAddress.digit_mode=%d, sAddress.Number_mode=%d, sAddress.number_type=%d, ",
+            printBuf, rcsm.uTeleserviceID,rcsm.bIsServicePresent,rcsm.uServicecategory,
+            rcsm.sAddress.digit_mode, rcsm.sAddress.number_mode,rcsm.sAddress.number_type);
+    closeRequest;
+
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    return status;
+}
+
+static void
+dispatchCdmaSms(Parcel &p, RequestInfo *pRI) {
+    RIL_CDMA_SMS_Message rcsm;
+
+    RLOGD("dispatchCdmaSms");
+    if (NO_ERROR != constructCdmaSms(p, pRI, rcsm)) {
+        goto invalid;
+    }
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm),pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&rcsm, 0, sizeof(rcsm));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchImsCdmaSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef) {
+    RIL_IMS_SMS_Message rism;
+    RIL_CDMA_SMS_Message rcsm;
+
+    RLOGD("dispatchImsCdmaSms: retry=%d, messageRef=%d", retry, messageRef);
+
+    if (NO_ERROR != constructCdmaSms(p, pRI, rcsm)) {
+        goto invalid;
+    }
+    memset(&rism, 0, sizeof(rism));
+    rism.tech = RADIO_TECH_3GPP2;
+    rism.retry = retry;
+    rism.messageRef = messageRef;
+    rism.message.cdmaMessage = &rcsm;
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &rism,
+            sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
+            +sizeof(rcsm),pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&rcsm, 0, sizeof(rcsm));
+    memset(&rism, 0, sizeof(rism));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef) {
+    RIL_IMS_SMS_Message rism;
+    int32_t countStrings;
+    status_t status;
+    size_t datalen;
+    char **pStrings;
+    RLOGD("dispatchImsGsmSms: retry=%d, messageRef=%d", retry, messageRef);
+
+    status = p.readInt32 (&countStrings);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    memset(&rism, 0, sizeof(rism));
+    rism.tech = RADIO_TECH_3GPP;
+    rism.retry = retry;
+    rism.messageRef = messageRef;
+
+    startRequest;
+    appendPrintBuf("%stech=%d, retry=%d, messageRef=%d, ", printBuf,
+                    (int)rism.tech, (int)rism.retry, rism.messageRef);
+    if (countStrings == 0) {
+        // just some non-null pointer
+        pStrings = (char **)calloc(1, sizeof(char *));
+        if (pStrings == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            closeRequest;
+            return;
+        }
+
+        datalen = 0;
+    } else if (countStrings < 0) {
+        pStrings = NULL;
+        datalen = 0;
+    } else {
+        if ((size_t)countStrings > (INT_MAX/sizeof(char *))) {
+            RLOGE("Invalid value of countStrings: \n");
+            closeRequest;
+            return;
+        }
+        datalen = sizeof(char *) * countStrings;
+
+        pStrings = (char **)calloc(countStrings, sizeof(char *));
+        if (pStrings == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            closeRequest;
+            return;
+        }
+
+        for (int i = 0 ; i < countStrings ; i++) {
+            pStrings[i] = strdupReadString(p);
+            appendPrintBuf("%s%s,", printBuf, pStrings[i]);
+        }
+    }
+    removeLastChar;
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    rism.message.gsmMessage = pStrings;
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &rism,
+            sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
+            +datalen, pRI, pRI->socket_id);
+
+    if (pStrings != NULL) {
+        for (int i = 0 ; i < countStrings ; i++) {
+#ifdef MEMSET_FREED
+            memsetString (pStrings[i]);
+#endif
+            free(pStrings[i]);
+        }
+
+#ifdef MEMSET_FREED
+        memset(pStrings, 0, datalen);
+#endif
+        free(pStrings);
+    }
+
+#ifdef MEMSET_FREED
+    memset(&rism, 0, sizeof(rism));
+#endif
+    return;
+invalid:
+    ALOGE("dispatchImsGsmSms invalid block");
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchImsSms(Parcel &p, RequestInfo *pRI) {
+    int32_t  t;
+    status_t status = p.readInt32(&t);
+    RIL_RadioTechnologyFamily format;
+    uint8_t retry;
+    int32_t messageRef;
+
+    RLOGD("dispatchImsSms");
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    format = (RIL_RadioTechnologyFamily) t;
+
+    // read retry field
+    status = p.read(&retry,sizeof(retry));
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    // read messageRef field
+    status = p.read(&messageRef,sizeof(messageRef));
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    if (RADIO_TECH_3GPP == format) {
+        dispatchImsGsmSms(p, pRI, retry, messageRef);
+    } else if (RADIO_TECH_3GPP2 == format) {
+        dispatchImsCdmaSms(p, pRI, retry, messageRef);
+    } else {
+        ALOGE("requestImsSendSMS invalid format value =%d", format);
+    }
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
+    RIL_CDMA_SMS_Ack rcsa;
+    int32_t  t;
+    status_t status;
+    int32_t digitCount;
+
+    RLOGD("dispatchCdmaSmsAck");
+    memset(&rcsa, 0, sizeof(rcsa));
+
+    status = p.readInt32(&t);
+    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
+
+    status = p.readInt32(&t);
+    rcsa.uSMSCauseCode = (int) t;
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    startRequest;
+    appendPrintBuf("%suErrorClass=%d, uTLStatus=%d, ",
+            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
+    closeRequest;
+
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&rcsa, 0, sizeof(rcsa));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI) {
+    int32_t t;
+    status_t status;
+    int32_t num;
+
+    status = p.readInt32(&num);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    {
+        RIL_GSM_BroadcastSmsConfigInfo gsmBci[num];
+        RIL_GSM_BroadcastSmsConfigInfo *gsmBciPtrs[num];
+
+        startRequest;
+        for (int i = 0 ; i < num ; i++ ) {
+            gsmBciPtrs[i] = &gsmBci[i];
+
+            status = p.readInt32(&t);
+            gsmBci[i].fromServiceId = (int) t;
+
+            status = p.readInt32(&t);
+            gsmBci[i].toServiceId = (int) t;
+
+            status = p.readInt32(&t);
+            gsmBci[i].fromCodeScheme = (int) t;
+
+            status = p.readInt32(&t);
+            gsmBci[i].toCodeScheme = (int) t;
+
+            status = p.readInt32(&t);
+            gsmBci[i].selected = (uint8_t) t;
+
+            appendPrintBuf("%s [%d: fromServiceId=%d, toServiceId =%d, \
+                  fromCodeScheme=%d, toCodeScheme=%d, selected =%d]", printBuf, i,
+                  gsmBci[i].fromServiceId, gsmBci[i].toServiceId,
+                  gsmBci[i].fromCodeScheme, gsmBci[i].toCodeScheme,
+                  gsmBci[i].selected);
+        }
+        closeRequest;
+
+        if (status != NO_ERROR) {
+            goto invalid;
+        }
+
+        CALL_ONREQUEST(pRI->pCI->requestNumber,
+                              gsmBciPtrs,
+                              num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *),
+                              pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+        memset(gsmBci, 0, num * sizeof(RIL_GSM_BroadcastSmsConfigInfo));
+        memset(gsmBciPtrs, 0, num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *));
+#endif
+    }
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void
+dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI) {
+    int32_t t;
+    status_t status;
+    int32_t num;
+
+    status = p.readInt32(&num);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    {
+        RIL_CDMA_BroadcastSmsConfigInfo cdmaBci[num];
+        RIL_CDMA_BroadcastSmsConfigInfo *cdmaBciPtrs[num];
+
+        startRequest;
+        for (int i = 0 ; i < num ; i++ ) {
+            cdmaBciPtrs[i] = &cdmaBci[i];
+
+            status = p.readInt32(&t);
+            cdmaBci[i].service_category = (int) t;
+
+            status = p.readInt32(&t);
+            cdmaBci[i].language = (int) t;
+
+            status = p.readInt32(&t);
+            cdmaBci[i].selected = (uint8_t) t;
+
+            appendPrintBuf("%s [%d: service_category=%d, language =%d, \
+                  entries.bSelected =%d]", printBuf, i, cdmaBci[i].service_category,
+                  cdmaBci[i].language, cdmaBci[i].selected);
+        }
+        closeRequest;
+
+        if (status != NO_ERROR) {
+            goto invalid;
+        }
+
+        CALL_ONREQUEST(pRI->pCI->requestNumber,
+                              cdmaBciPtrs,
+                              num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *),
+                              pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+        memset(cdmaBci, 0, num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo));
+        memset(cdmaBciPtrs, 0, num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *));
+#endif
+    }
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI) {
+    RIL_CDMA_SMS_WriteArgs rcsw;
+    int32_t  t;
+    uint32_t ut;
+    uint8_t  uct;
+    status_t status;
+    int32_t  digitCount;
+    int32_t  digitLimit;
+
+    memset(&rcsw, 0, sizeof(rcsw));
+
+    status = p.readInt32(&t);
+    rcsw.status = t;
+
+    status = p.readInt32(&t);
+    rcsw.message.uTeleserviceID = (int) t;
+
+    status = p.read(&uct,sizeof(uct));
+    rcsw.message.bIsServicePresent = (uint8_t) uct;
+
+    status = p.readInt32(&t);
+    rcsw.message.uServicecategory = (int) t;
+
+    status = p.readInt32(&t);
+    rcsw.message.sAddress.digit_mode = (RIL_CDMA_SMS_DigitMode) t;
+
+    status = p.readInt32(&t);
+    rcsw.message.sAddress.number_mode = (RIL_CDMA_SMS_NumberMode) t;
+
+    status = p.readInt32(&t);
+    rcsw.message.sAddress.number_type = (RIL_CDMA_SMS_NumberType) t;
+
+    status = p.readInt32(&t);
+    rcsw.message.sAddress.number_plan = (RIL_CDMA_SMS_NumberPlan) t;
+
+    status = p.read(&uct,sizeof(uct));
+    rcsw.message.sAddress.number_of_digits = (uint8_t) uct;
+
+    digitLimit = MIN((rcsw.message.sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
+
+    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&uct,sizeof(uct));
+        rcsw.message.sAddress.digits[digitCount] = (uint8_t) uct;
+    }
+
+    status = p.readInt32(&t);
+    rcsw.message.sSubAddress.subaddressType = (RIL_CDMA_SMS_SubaddressType) t;
+
+    status = p.read(&uct,sizeof(uct));
+    rcsw.message.sSubAddress.odd = (uint8_t) uct;
+
+    status = p.read(&uct,sizeof(uct));
+    rcsw.message.sSubAddress.number_of_digits = (uint8_t) uct;
+
+    digitLimit = MIN((rcsw.message.sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
+
+    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&uct,sizeof(uct));
+        rcsw.message.sSubAddress.digits[digitCount] = (uint8_t) uct;
+    }
+
+    status = p.readInt32(&t);
+    rcsw.message.uBearerDataLen = (int) t;
+
+    digitLimit = MIN((rcsw.message.uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
+
+    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
+        status = p.read(&uct, sizeof(uct));
+        rcsw.message.aBearerData[digitCount] = (uint8_t) uct;
+    }
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    startRequest;
+    appendPrintBuf("%sstatus=%d, message.uTeleserviceID=%d, message.bIsServicePresent=%d, \
+            message.uServicecategory=%d, message.sAddress.digit_mode=%d, \
+            message.sAddress.number_mode=%d, \
+            message.sAddress.number_type=%d, ",
+            printBuf, rcsw.status, rcsw.message.uTeleserviceID, rcsw.message.bIsServicePresent,
+            rcsw.message.uServicecategory, rcsw.message.sAddress.digit_mode,
+            rcsw.message.sAddress.number_mode,
+            rcsw.message.sAddress.number_type);
+    closeRequest;
+
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsw, sizeof(rcsw),pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&rcsw, 0, sizeof(rcsw));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+
+}
+
+// For backwards compatibility in RIL_REQUEST_SETUP_DATA_CALL.
+// Version 4 of the RIL interface adds a new PDP type parameter to support
+// IPv6 and dual-stack PDP contexts. When dealing with a previous version of
+// RIL, remove the parameter from the request.
+static void dispatchDataCall(Parcel& p, RequestInfo *pRI) {
+    // In RIL v3, REQUEST_SETUP_DATA_CALL takes 6 parameters.
+    const int numParamsRilV3 = 6;
+
+    // The first bytes of the RIL parcel contain the request number and the
+    // serial number - see processCommandBuffer(). Copy them over too.
+    int pos = p.dataPosition();
+
+    int numParams = p.readInt32();
+    if (s_callbacks.version < 4 && numParams > numParamsRilV3) {
+      Parcel p2;
+      p2.appendFrom(&p, 0, pos);
+      p2.writeInt32(numParamsRilV3);
+      for(int i = 0; i < numParamsRilV3; i++) {
+        p2.writeString16(p.readString16());
+      }
+      p2.setDataPosition(pos);
+      dispatchStrings(p2, pRI);
+    } else {
+      p.setDataPosition(pos);
+      dispatchStrings(p, pRI);
+    }
+}
+
+// For backwards compatibility with RILs that dont support RIL_REQUEST_VOICE_RADIO_TECH.
+// When all RILs handle this request, this function can be removed and
+// the request can be sent directly to the RIL using dispatchVoid.
+static void dispatchVoiceRadioTech(Parcel& p, RequestInfo *pRI) {
+    RIL_RadioState state = CALL_ONSTATEREQUEST((RIL_SOCKET_ID)pRI->socket_id);
+
+    if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
+        RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+    }
+
+    // RILs that support RADIO_STATE_ON should support this request.
+    if (RADIO_STATE_ON == state) {
+        dispatchVoid(p, pRI);
+        return;
+    }
+
+    // For Older RILs, that do not support RADIO_STATE_ON, assume that they
+    // will not support this new request either and decode Voice Radio Technology
+    // from Radio State
+    voiceRadioTech = decodeVoiceRadioTechnology(state);
+
+    if (voiceRadioTech < 0)
+        RIL_onRequestComplete(pRI, RIL_E_GENERIC_FAILURE, NULL, 0);
+    else
+        RIL_onRequestComplete(pRI, RIL_E_SUCCESS, &voiceRadioTech, sizeof(int));
+}
+
+// For backwards compatibility in RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:.
+// When all RILs handle this request, this function can be removed and
+// the request can be sent directly to the RIL using dispatchVoid.
+static void dispatchCdmaSubscriptionSource(Parcel& p, RequestInfo *pRI) {
+    RIL_RadioState state = CALL_ONSTATEREQUEST((RIL_SOCKET_ID)pRI->socket_id);
+
+    if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
+        RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
+    }
+
+    // RILs that support RADIO_STATE_ON should support this request.
+    if (RADIO_STATE_ON == state) {
+        dispatchVoid(p, pRI);
+        return;
+    }
+
+    // For Older RILs, that do not support RADIO_STATE_ON, assume that they
+    // will not support this new request either and decode CDMA Subscription Source
+    // from Radio State
+    cdmaSubscriptionSource = decodeCdmaSubscriptionSource(state);
+
+    if (cdmaSubscriptionSource < 0)
+        RIL_onRequestComplete(pRI, RIL_E_GENERIC_FAILURE, NULL, 0);
+    else
+        RIL_onRequestComplete(pRI, RIL_E_SUCCESS, &cdmaSubscriptionSource, sizeof(int));
+}
+
+static void dispatchSetInitialAttachApn(Parcel &p, RequestInfo *pRI)
+{
+    RIL_InitialAttachApn pf;
+    int32_t  t;
+    status_t status;
+
+    memset(&pf, 0, sizeof(pf));
+
+    pf.apn = strdupReadString(p);
+    pf.protocol = strdupReadString(p);
+
+    status = p.readInt32(&t);
+    pf.authtype = (int) t;
+
+    pf.username = strdupReadString(p);
+    pf.password = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("%sapn=%s, protocol=%s, authtype=%d, username=%s, password=%s",
+            printBuf, pf.apn, pf.protocol, pf.authtype, pf.username, pf.password);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(pf.apn);
+    memsetString(pf.protocol);
+    memsetString(pf.username);
+    memsetString(pf.password);
+#endif
+
+    free(pf.apn);
+    free(pf.protocol);
+    free(pf.username);
+    free(pf.password);
+
+#ifdef MEMSET_FREED
+    memset(&pf, 0, sizeof(pf));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchNVReadItem(Parcel &p, RequestInfo *pRI) {
+    RIL_NV_ReadItem nvri;
+    int32_t  t;
+    status_t status;
+
+    memset(&nvri, 0, sizeof(nvri));
+
+    status = p.readInt32(&t);
+    nvri.itemID = (RIL_NV_Item) t;
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    startRequest;
+    appendPrintBuf("%snvri.itemID=%d, ", printBuf, nvri.itemID);
+    closeRequest;
+
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvri, sizeof(nvri), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&nvri, 0, sizeof(nvri));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchNVWriteItem(Parcel &p, RequestInfo *pRI) {
+    RIL_NV_WriteItem nvwi;
+    int32_t  t;
+    status_t status;
+
+    memset(&nvwi, 0, sizeof(nvwi));
+
+    status = p.readInt32(&t);
+    nvwi.itemID = (RIL_NV_Item) t;
+
+    nvwi.value = strdupReadString(p);
+
+    if (status != NO_ERROR || nvwi.value == NULL) {
+        goto invalid;
+    }
+
+    startRequest;
+    appendPrintBuf("%snvwi.itemID=%d, value=%s, ", printBuf, nvwi.itemID,
+            nvwi.value);
+    closeRequest;
+
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvwi, sizeof(nvwi), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(nvwi.value);
+#endif
+
+    free(nvwi.value);
+
+#ifdef MEMSET_FREED
+    memset(&nvwi, 0, sizeof(nvwi));
+#endif
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+
+static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI) {
+    RIL_SelectUiccSub uicc_sub;
+    status_t status;
+    int32_t  t;
+    memset(&uicc_sub, 0, sizeof(uicc_sub));
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    uicc_sub.slot = (int) t;
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    uicc_sub.app_index = (int) t;
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    uicc_sub.sub_type = (RIL_SubscriptionType) t;
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    uicc_sub.act_status = (RIL_UiccSubActStatus) t;
+
+    startRequest;
+    appendPrintBuf("slot=%d, app_index=%d, act_status = %d", uicc_sub.slot, uicc_sub.app_index,
+            uicc_sub.act_status);
+    RLOGD("dispatchUiccSubscription, slot=%d, app_index=%d, act_status = %d", uicc_sub.slot,
+            uicc_sub.app_index, uicc_sub.act_status);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &uicc_sub, sizeof(uicc_sub), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memset(&uicc_sub, 0, sizeof(uicc_sub));
+#endif
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
+{
+    RIL_SimAuthentication pf;
+    int32_t  t;
+    status_t status;
+
+    memset(&pf, 0, sizeof(pf));
+
+    status = p.readInt32(&t);
+    pf.authContext = (int) t;
+    pf.authData = strdupReadString(p);
+    pf.aid = strdupReadString(p);
+
+    startRequest;
+    appendPrintBuf("authContext=%s, authData=%s, aid=%s", pf.authContext, pf.authData, pf.aid);
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+    memsetString(pf.authData);
+    memsetString(pf.aid);
+#endif
+
+    free(pf.authData);
+    free(pf.aid);
+
+#ifdef MEMSET_FREED
+    memset(&pf, 0, sizeof(pf));
+#endif
+
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchDataProfile(Parcel &p, RequestInfo *pRI) {
+    int32_t t;
+    status_t status;
+    int32_t num;
+
+    status = p.readInt32(&num);
+    if (status != NO_ERROR || num < 0) {
+        goto invalid;
+    }
+
+    {
+        RIL_DataProfileInfo *dataProfiles =
+                (RIL_DataProfileInfo *)calloc(num, sizeof(RIL_DataProfileInfo));
+        if (dataProfiles == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            return;
+        }
+        RIL_DataProfileInfo **dataProfilePtrs =
+                (RIL_DataProfileInfo **)calloc(num, sizeof(RIL_DataProfileInfo *));
+        if (dataProfilePtrs == NULL) {
+            RLOGE("Memory allocation failed for request %s",
+                    requestToString(pRI->pCI->requestNumber));
+            free(dataProfiles);
+            return;
+        }
+
+        startRequest;
+        for (int i = 0 ; i < num ; i++ ) {
+            dataProfilePtrs[i] = &dataProfiles[i];
+
+            status = p.readInt32(&t);
+            dataProfiles[i].profileId = (int) t;
+
+            dataProfiles[i].apn = strdupReadString(p);
+            dataProfiles[i].protocol = strdupReadString(p);
+            status = p.readInt32(&t);
+            dataProfiles[i].authType = (int) t;
+
+            dataProfiles[i].user = strdupReadString(p);
+            dataProfiles[i].password = strdupReadString(p);
+
+            status = p.readInt32(&t);
+            dataProfiles[i].type = (int) t;
+
+            status = p.readInt32(&t);
+            dataProfiles[i].maxConnsTime = (int) t;
+            status = p.readInt32(&t);
+            dataProfiles[i].maxConns = (int) t;
+            status = p.readInt32(&t);
+            dataProfiles[i].waitTime = (int) t;
+
+            status = p.readInt32(&t);
+            dataProfiles[i].enabled = (int) t;
+
+            appendPrintBuf("%s [%d: profileId=%d, apn =%s, protocol =%s, authType =%d, \
+                  user =%s, password =%s, type =%d, maxConnsTime =%d, maxConns =%d, \
+                  waitTime =%d, enabled =%d]", printBuf, i, dataProfiles[i].profileId,
+                  dataProfiles[i].apn, dataProfiles[i].protocol, dataProfiles[i].authType,
+                  dataProfiles[i].user, dataProfiles[i].password, dataProfiles[i].type,
+                  dataProfiles[i].maxConnsTime, dataProfiles[i].maxConns,
+                  dataProfiles[i].waitTime, dataProfiles[i].enabled);
+        }
+        closeRequest;
+        printRequest(pRI->token, pRI->pCI->requestNumber);
+
+        if (status != NO_ERROR) {
+            free(dataProfiles);
+            free(dataProfilePtrs);
+            goto invalid;
+        }
+        CALL_ONREQUEST(pRI->pCI->requestNumber,
+                              dataProfilePtrs,
+                              num * sizeof(RIL_DataProfileInfo *),
+                              pRI, pRI->socket_id);
+
+#ifdef MEMSET_FREED
+        memset(dataProfiles, 0, num * sizeof(RIL_DataProfileInfo));
+        memset(dataProfilePtrs, 0, num * sizeof(RIL_DataProfileInfo *));
+#endif
+        free(dataProfiles);
+        free(dataProfilePtrs);
+    }
+
+    return;
+
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+static void dispatchRadioCapability(Parcel &p, RequestInfo *pRI){
+    RIL_RadioCapability rc;
+    int32_t t;
+    status_t status;
+
+    memset (&rc, 0, sizeof(RIL_RadioCapability));
+
+    status = p.readInt32(&t);
+    rc.version = (int)t;
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    status = p.readInt32(&t);
+    rc.session= (int)t;
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    status = p.readInt32(&t);
+    rc.phase= (int)t;
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    status = p.readInt32(&t);
+    rc.rat = (int)t;
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    status = readStringFromParcelInplace(p, rc.logicalModemUuid, sizeof(rc.logicalModemUuid));
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    status = p.readInt32(&t);
+    rc.status = (int)t;
+
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+
+    startRequest;
+    appendPrintBuf("%s [version:%d, session:%d, phase:%d, rat:%d, \
+            logicalModemUuid:%s, status:%d", printBuf, rc.version, rc.session,
+            rc.phase, rc.rat, rc.logicalModemUuid, rc.session);
+
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber,
+                &rc,
+                sizeof(RIL_RadioCapability),
+                pRI, pRI->socket_id);
+    return;
+invalid:
+    invalidCommandBlock(pRI);
+    return;
+}
+
+/**
+ * Callee expects const RIL_CarrierRestrictions *
+ */
+static void dispatchCarrierRestrictions(Parcel &p, RequestInfo *pRI) {
+    RIL_CarrierRestrictions cr;
+    RIL_Carrier * allowed_carriers = NULL;
+    RIL_Carrier * excluded_carriers = NULL;
+    int32_t t;
+    status_t status;
+
+    memset(&cr, 0, sizeof(RIL_CarrierRestrictions));
+
+    if (s_callbacks.version < 14) {
+        RLOGE("Unsuppoted RIL version %d, min version expected %d",
+              s_callbacks.version, 14);
+        RIL_onRequestComplete(pRI, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
+        return;
+    }
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    allowed_carriers = (RIL_Carrier *)calloc(t, sizeof(RIL_Carrier));
+    if (allowed_carriers == NULL) {
+        RLOGE("Memory allocation failed for request %s", requestToString(pRI->pCI->requestNumber));
+        goto exit;
+    }
+    cr.len_allowed_carriers = t;
+    cr.allowed_carriers = allowed_carriers;
+
+    status = p.readInt32(&t);
+    if (status != NO_ERROR) {
+        goto invalid;
+    }
+    excluded_carriers = (RIL_Carrier *)calloc(t, sizeof(RIL_Carrier));
+    if (excluded_carriers == NULL) {
+        RLOGE("Memory allocation failed for request %s", requestToString(pRI->pCI->requestNumber));
+        goto exit;
+    }
+    cr.len_excluded_carriers = t;
+    cr.excluded_carriers = excluded_carriers;
+
+    startRequest;
+    appendPrintBuf("%s len_allowed_carriers:%d, len_excluded_carriers:%d,",
+                   printBuf, cr.len_allowed_carriers, cr.len_excluded_carriers);
+
+    appendPrintBuf("%s allowed_carriers:", printBuf);
+    for (int32_t i = 0; i < cr.len_allowed_carriers; i++) {
+        RIL_Carrier *p_cr = allowed_carriers + i;
+        p_cr->mcc = strdupReadString(p);
+        p_cr->mnc = strdupReadString(p);
+        status = p.readInt32(&t);
+        p_cr->match_type = static_cast<RIL_CarrierMatchType>(t);
+        if (status != NO_ERROR) {
+            goto invalid;
+        }
+        p_cr->match_data = strdupReadString(p);
+        appendPrintBuf("%s [%d mcc:%s, mnc:%s, match_type:%d, match_data:%s],",
+                       printBuf, i, p_cr->mcc, p_cr->mnc, p_cr->match_type, p_cr->match_data);
+    }
+
+    for (int32_t i = 0; i < cr.len_excluded_carriers; i++) {
+        RIL_Carrier *p_cr = excluded_carriers + i;
+        p_cr->mcc = strdupReadString(p);
+        p_cr->mnc = strdupReadString(p);
+        status = p.readInt32(&t);
+        p_cr->match_type = static_cast<RIL_CarrierMatchType>(t);
+        if (status != NO_ERROR) {
+            goto invalid;
+        }
+        p_cr->match_data = strdupReadString(p);
+        appendPrintBuf("%s [%d mcc:%s, mnc:%s, match_type:%d, match_data:%s],",
+                       printBuf, i, p_cr->mcc, p_cr->mnc, p_cr->match_type, p_cr->match_data);
+    }
+
+    closeRequest;
+    printRequest(pRI->token, pRI->pCI->requestNumber);
+
+    CALL_ONREQUEST(pRI->pCI->requestNumber,
+                &cr,
+                sizeof(RIL_CarrierRestrictions),
+                pRI, pRI->socket_id);
+
+    goto exit;
+
+invalid:
+    invalidCommandBlock(pRI);
+    RIL_onRequestComplete(pRI, RIL_E_INVALID_ARGUMENTS, NULL, 0);
+exit:
+    if (allowed_carriers != NULL) {
+        free(allowed_carriers);
+    }
+    if (excluded_carriers != NULL) {
+        free(excluded_carriers);
+    }
+    return;
+}
+
+static int
+blockingWrite(int fd, const void *buffer, size_t len) {
+    size_t writeOffset = 0;
+    const uint8_t *toWrite;
+
+    toWrite = (const uint8_t *)buffer;
+
+    while (writeOffset < len) {
+        ssize_t written;
+        do {
+            written = write (fd, toWrite + writeOffset,
+                                len - writeOffset);
+        } while (written < 0 && ((errno == EINTR) || (errno == EAGAIN)));
+
+        if (written >= 0) {
+            writeOffset += written;
+        } else {   // written < 0
+            RLOGE ("RIL Response: unexpected error on write errno:%d", errno);
+            close(fd);
+            return -1;
+        }
+    }
+#if VDBG
+    RLOGE("RIL Response bytes written:%d", writeOffset);
+#endif
+    return 0;
+}
+
+static int
+sendResponseRaw (const void *data, size_t dataSize, RIL_SOCKET_ID socket_id) {
+    int fd = s_ril_param_socket.fdCommand;
+    int ret;
+    uint32_t header;
+    pthread_mutex_t * writeMutexHook = &s_writeMutex;
+
+#if VDBG
+    RLOGE("Send Response to %s", rilSocketIdToString(socket_id));
+#endif
+
+#if (SIM_COUNT >= 2)
+    if (socket_id == RIL_SOCKET_2) {
+        fd = s_ril_param_socket2.fdCommand;
+        writeMutexHook = &s_writeMutex_socket2;
+    }
+#if (SIM_COUNT >= 3)
+    else if (socket_id == RIL_SOCKET_3) {
+        fd = s_ril_param_socket3.fdCommand;
+        writeMutexHook = &s_writeMutex_socket3;
+    }
+#endif
+#if (SIM_COUNT >= 4)
+    else if (socket_id == RIL_SOCKET_4) {
+        fd = s_ril_param_socket4.fdCommand;
+        writeMutexHook = &s_writeMutex_socket4;
+    }
+#endif
+#endif
+    if (fd < 0) {
+        return -1;
+    }
+
+    if (dataSize > MAX_COMMAND_BYTES) {
+        RLOGE("RIL: packet larger than %u (%u)",
+                MAX_COMMAND_BYTES, (unsigned int )dataSize);
+
+        return -1;
+    }
+
+    pthread_mutex_lock(writeMutexHook);
+
+    header = htonl(dataSize);
+
+    ret = blockingWrite(fd, (void *)&header, sizeof(header));
+
+    if (ret < 0) {
+        pthread_mutex_unlock(writeMutexHook);
+        return ret;
+    }
+
+    ret = blockingWrite(fd, data, dataSize);
+
+    if (ret < 0) {
+        pthread_mutex_unlock(writeMutexHook);
+        return ret;
+    }
+
+    pthread_mutex_unlock(writeMutexHook);
+
+    return 0;
+}
+
+static int
+sendResponse (Parcel &p, RIL_SOCKET_ID socket_id) {
+    printResponse;
+    return sendResponseRaw(p.data(), p.dataSize(), socket_id);
+}
+
+/** response is an int* pointing to an array of ints */
+
+static int
+responseInts(Parcel &p, void *response, size_t responselen) {
+    int numInts;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+    if (responselen % sizeof(int) != 0) {
+        RLOGE("responseInts: invalid response length %d expected multiple of %d\n",
+            (int)responselen, (int)sizeof(int));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    int *p_int = (int *) response;
+
+    numInts = responselen / sizeof(int);
+    p.writeInt32 (numInts);
+
+    /* each int*/
+    startResponse;
+    for (int i = 0 ; i < numInts ; i++) {
+        appendPrintBuf("%s%d,", printBuf, p_int[i]);
+        p.writeInt32(p_int[i]);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+// Response is an int or RIL_LastCallFailCauseInfo.
+// Currently, only Shamu plans to use RIL_LastCallFailCauseInfo.
+// TODO(yjl): Let all implementations use RIL_LastCallFailCauseInfo.
+static int responseFailCause(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen == sizeof(int)) {
+      startResponse;
+      int *p_int = (int *) response;
+      appendPrintBuf("%s%d,", printBuf, p_int[0]);
+      p.writeInt32(p_int[0]);
+      removeLastChar;
+      closeResponse;
+    } else if (responselen == sizeof(RIL_LastCallFailCauseInfo)) {
+      startResponse;
+      RIL_LastCallFailCauseInfo *p_fail_cause_info = (RIL_LastCallFailCauseInfo *) response;
+      appendPrintBuf("%s[cause_code=%d,vendor_cause=%s]", printBuf, p_fail_cause_info->cause_code,
+                     p_fail_cause_info->vendor_cause);
+      p.writeInt32(p_fail_cause_info->cause_code);
+      writeStringToParcel(p, p_fail_cause_info->vendor_cause);
+      removeLastChar;
+      closeResponse;
+    } else {
+      RLOGE("responseFailCause: invalid response length %d expected an int or "
+            "RIL_LastCallFailCauseInfo", (int)responselen);
+      return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    return 0;
+}
+
+/** response is a char **, pointing to an array of char *'s
+    The parcel will begin with the version */
+static int responseStringsWithVersion(int version, Parcel &p, void *response, size_t responselen) {
+    p.writeInt32(version);
+    return responseStrings(p, response, responselen);
+}
+
+/** response is a char **, pointing to an array of char *'s */
+static int responseStrings(Parcel &p, void *response, size_t responselen) {
+    int numStrings;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+    if (responselen % sizeof(char *) != 0) {
+        RLOGE("responseStrings: invalid response length %d expected multiple of %d\n",
+            (int)responselen, (int)sizeof(char *));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (response == NULL) {
+        p.writeInt32 (0);
+    } else {
+        char **p_cur = (char **) response;
+
+        numStrings = responselen / sizeof(char *);
+        p.writeInt32 (numStrings);
+
+        /* each string*/
+        startResponse;
+        for (int i = 0 ; i < numStrings ; i++) {
+            appendPrintBuf("%s%s,", printBuf, (char*)p_cur[i]);
+            writeStringToParcel (p, p_cur[i]);
+        }
+        removeLastChar;
+        closeResponse;
+    }
+    return 0;
+}
+
+
+/**
+ * NULL strings are accepted
+ * FIXME currently ignores responselen
+ */
+static int responseString(Parcel &p, void *response, size_t responselen) {
+    /* one string only */
+    startResponse;
+    appendPrintBuf("%s%s", printBuf, (char*)response);
+    closeResponse;
+
+    writeStringToParcel(p, (const char *)response);
+
+    return 0;
+}
+
+static int responseVoid(Parcel &p, void *response, size_t responselen) {
+    startResponse;
+    removeLastChar;
+    return 0;
+}
+
+static int responseCallList(Parcel &p, void *response, size_t responselen) {
+    int num;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof (RIL_Call *) != 0) {
+        RLOGE("responseCallList: invalid response length %d expected multiple of %d\n",
+            (int)responselen, (int)sizeof (RIL_Call *));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+    /* number of call info's */
+    num = responselen / sizeof(RIL_Call *);
+    p.writeInt32(num);
+
+    for (int i = 0 ; i < num ; i++) {
+        RIL_Call *p_cur = ((RIL_Call **) response)[i];
+        /* each call info */
+        p.writeInt32(p_cur->state);
+        p.writeInt32(p_cur->index);
+        p.writeInt32(p_cur->toa);
+        p.writeInt32(p_cur->isMpty);
+        p.writeInt32(p_cur->isMT);
+        p.writeInt32(p_cur->als);
+        p.writeInt32(p_cur->isVoice);
+        p.writeInt32(p_cur->isVoicePrivacy);
+        writeStringToParcel(p, p_cur->number);
+        p.writeInt32(p_cur->numberPresentation);
+        writeStringToParcel(p, p_cur->name);
+        p.writeInt32(p_cur->namePresentation);
+        // Remove when partners upgrade to version 3
+        if ((s_callbacks.version < 3) || (p_cur->uusInfo == NULL || p_cur->uusInfo->uusData == NULL)) {
+            p.writeInt32(0); /* UUS Information is absent */
+        } else {
+            RIL_UUS_Info *uusInfo = p_cur->uusInfo;
+            p.writeInt32(1); /* UUS Information is present */
+            p.writeInt32(uusInfo->uusType);
+            p.writeInt32(uusInfo->uusDcs);
+            p.writeInt32(uusInfo->uusLength);
+            p.write(uusInfo->uusData, uusInfo->uusLength);
+        }
+        appendPrintBuf("%s[id=%d,%s,toa=%d,",
+            printBuf,
+            p_cur->index,
+            callStateToString(p_cur->state),
+            p_cur->toa);
+        appendPrintBuf("%s%s,%s,als=%d,%s,%s,",
+            printBuf,
+            (p_cur->isMpty)?"conf":"norm",
+            (p_cur->isMT)?"mt":"mo",
+            p_cur->als,
+            (p_cur->isVoice)?"voc":"nonvoc",
+            (p_cur->isVoicePrivacy)?"evp":"noevp");
+        appendPrintBuf("%s%s,cli=%d,name='%s',%d]",
+            printBuf,
+            p_cur->number,
+            p_cur->numberPresentation,
+            p_cur->name,
+            p_cur->namePresentation);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseSMS(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof (RIL_SMS_Response) ) {
+        RLOGE("invalid response length %d expected %d",
+                (int)responselen, (int)sizeof (RIL_SMS_Response));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_SMS_Response *p_cur = (RIL_SMS_Response *) response;
+
+    p.writeInt32(p_cur->messageRef);
+    writeStringToParcel(p, p_cur->ackPDU);
+    p.writeInt32(p_cur->errorCode);
+
+    startResponse;
+    appendPrintBuf("%s%d,%s,%d", printBuf, p_cur->messageRef,
+        (char*)p_cur->ackPDU, p_cur->errorCode);
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDataCallListV4(Parcel &p, void *response, size_t responselen)
+{
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_Data_Call_Response_v4) != 0) {
+        RLOGE("responseDataCallListV4: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v4));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    // Write version
+    p.writeInt32(4);
+
+    int num = responselen / sizeof(RIL_Data_Call_Response_v4);
+    p.writeInt32(num);
+
+    RIL_Data_Call_Response_v4 *p_cur = (RIL_Data_Call_Response_v4 *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32(p_cur[i].cid);
+        p.writeInt32(p_cur[i].active);
+        writeStringToParcel(p, p_cur[i].type);
+        // apn is not used, so don't send.
+        writeStringToParcel(p, p_cur[i].address);
+        appendPrintBuf("%s[cid=%d,%s,%s,%s],", printBuf,
+            p_cur[i].cid,
+            (p_cur[i].active==0)?"down":"up",
+            (char*)p_cur[i].type,
+            (char*)p_cur[i].address);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDataCallListV6(Parcel &p, void *response, size_t responselen)
+{
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_Data_Call_Response_v6) != 0) {
+        RLOGE("responseDataCallListV6: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v6));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    // Write version
+    p.writeInt32(6);
+
+    int num = responselen / sizeof(RIL_Data_Call_Response_v6);
+    p.writeInt32(num);
+
+    RIL_Data_Call_Response_v6 *p_cur = (RIL_Data_Call_Response_v6 *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32((int)p_cur[i].status);
+        p.writeInt32(p_cur[i].suggestedRetryTime);
+        p.writeInt32(p_cur[i].cid);
+        p.writeInt32(p_cur[i].active);
+        writeStringToParcel(p, p_cur[i].type);
+        writeStringToParcel(p, p_cur[i].ifname);
+        writeStringToParcel(p, p_cur[i].addresses);
+        writeStringToParcel(p, p_cur[i].dnses);
+        writeStringToParcel(p, p_cur[i].gateways);
+        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s],", printBuf,
+            p_cur[i].status,
+            p_cur[i].suggestedRetryTime,
+            p_cur[i].cid,
+            (p_cur[i].active==0)?"down":"up",
+            (char*)p_cur[i].type,
+            (char*)p_cur[i].ifname,
+            (char*)p_cur[i].addresses,
+            (char*)p_cur[i].dnses,
+            (char*)p_cur[i].gateways);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDataCallListV9(Parcel &p, void *response, size_t responselen)
+{
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_Data_Call_Response_v9) != 0) {
+        RLOGE("responseDataCallListV9: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v9));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    // Write version
+    p.writeInt32(10);
+
+    int num = responselen / sizeof(RIL_Data_Call_Response_v9);
+    p.writeInt32(num);
+
+    RIL_Data_Call_Response_v9 *p_cur = (RIL_Data_Call_Response_v9 *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32((int)p_cur[i].status);
+        p.writeInt32(p_cur[i].suggestedRetryTime);
+        p.writeInt32(p_cur[i].cid);
+        p.writeInt32(p_cur[i].active);
+        writeStringToParcel(p, p_cur[i].type);
+        writeStringToParcel(p, p_cur[i].ifname);
+        writeStringToParcel(p, p_cur[i].addresses);
+        writeStringToParcel(p, p_cur[i].dnses);
+        writeStringToParcel(p, p_cur[i].gateways);
+        writeStringToParcel(p, p_cur[i].pcscf);
+        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s,%s],", printBuf,
+            p_cur[i].status,
+            p_cur[i].suggestedRetryTime,
+            p_cur[i].cid,
+            (p_cur[i].active==0)?"down":"up",
+            (char*)p_cur[i].type,
+            (char*)p_cur[i].ifname,
+            (char*)p_cur[i].addresses,
+            (char*)p_cur[i].dnses,
+            (char*)p_cur[i].gateways,
+            (char*)p_cur[i].pcscf);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDataCallListV11(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+                RLOGE("invalid response: NULL");
+                return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_Data_Call_Response_v11) != 0) {
+        RLOGE("invalid response length %d expected multiple of %d",
+        (int)responselen, (int)sizeof(RIL_Data_Call_Response_v11));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    // Write version
+    p.writeInt32(11);
+
+    int num = responselen / sizeof(RIL_Data_Call_Response_v11);
+    p.writeInt32(num);
+
+    RIL_Data_Call_Response_v11 *p_cur = (RIL_Data_Call_Response_v11 *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32((int)p_cur[i].status);
+        p.writeInt32(p_cur[i].suggestedRetryTime);
+        p.writeInt32(p_cur[i].cid);
+        p.writeInt32(p_cur[i].active);
+        writeStringToParcel(p, p_cur[i].type);
+        writeStringToParcel(p, p_cur[i].ifname);
+        writeStringToParcel(p, p_cur[i].addresses);
+        writeStringToParcel(p, p_cur[i].dnses);
+        writeStringToParcel(p, p_cur[i].gateways);
+        writeStringToParcel(p, p_cur[i].pcscf);
+        p.writeInt32(p_cur[i].mtu);
+        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s,%s,mtu=%d],", printBuf,
+        p_cur[i].status,
+        p_cur[i].suggestedRetryTime,
+        p_cur[i].cid,
+        (p_cur[i].active==0)?"down":"up",
+        (char*)p_cur[i].type,
+        (char*)p_cur[i].ifname,
+        (char*)p_cur[i].addresses,
+        (char*)p_cur[i].dnses,
+        (char*)p_cur[i].gateways,
+        (char*)p_cur[i].pcscf,
+        p_cur[i].mtu);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDataCallList(Parcel &p, void *response, size_t responselen)
+{
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (s_callbacks.version < 5) {
+            RLOGD("responseDataCallList: v4");
+            return responseDataCallListV4(p, response, responselen);
+        } else if (responselen % sizeof(RIL_Data_Call_Response_v6) == 0) {
+            return responseDataCallListV6(p, response, responselen);
+        } else if (responselen % sizeof(RIL_Data_Call_Response_v9) == 0) {
+            return responseDataCallListV9(p, response, responselen);
+        } else {
+            return responseDataCallListV11(p, response, responselen);
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_Data_Call_Response_v11) != 0) {
+            RLOGE("Data structure expected is RIL_Data_Call_Response_v11");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        return responseDataCallListV11(p, response, responselen);
+    }
+}
+
+static int responseSetupDataCall(Parcel &p, void *response, size_t responselen)
+{
+    if (s_callbacks.version < 5) {
+        return responseStringsWithVersion(s_callbacks.version, p, response, responselen);
+    } else {
+        return responseDataCallList(p, response, responselen);
+    }
+}
+
+static int responseRaw(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL with responselen != 0");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    // The java code reads -1 size as null byte array
+    if (response == NULL) {
+        p.writeInt32(-1);
+    } else {
+        p.writeInt32(responselen);
+        p.write(response, responselen);
+    }
+
+    return 0;
+}
+
+
+static int responseSIM_IO(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof (RIL_SIM_IO_Response) ) {
+        RLOGE("invalid response length was %d expected %d",
+                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_SIM_IO_Response *p_cur = (RIL_SIM_IO_Response *) response;
+    p.writeInt32(p_cur->sw1);
+    p.writeInt32(p_cur->sw2);
+    writeStringToParcel(p, p_cur->simResponse);
+
+    startResponse;
+    appendPrintBuf("%ssw1=0x%X,sw2=0x%X,%s", printBuf, p_cur->sw1, p_cur->sw2,
+        (char*)p_cur->simResponse);
+    closeResponse;
+
+
+    return 0;
+}
+
+static int responseCallForwards(Parcel &p, void *response, size_t responselen) {
+    int num;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_CallForwardInfo *) != 0) {
+        RLOGE("responseCallForwards: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_CallForwardInfo *));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    /* number of call info's */
+    num = responselen / sizeof(RIL_CallForwardInfo *);
+    p.writeInt32(num);
+
+    startResponse;
+    for (int i = 0 ; i < num ; i++) {
+        RIL_CallForwardInfo *p_cur = ((RIL_CallForwardInfo **) response)[i];
+
+        p.writeInt32(p_cur->status);
+        p.writeInt32(p_cur->reason);
+        p.writeInt32(p_cur->serviceClass);
+        p.writeInt32(p_cur->toa);
+        writeStringToParcel(p, p_cur->number);
+        p.writeInt32(p_cur->timeSeconds);
+        appendPrintBuf("%s[%s,reason=%d,cls=%d,toa=%d,%s,tout=%d],", printBuf,
+            (p_cur->status==1)?"enable":"disable",
+            p_cur->reason, p_cur->serviceClass, p_cur->toa,
+            (char*)p_cur->number,
+            p_cur->timeSeconds);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseSsn(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof(RIL_SuppSvcNotification)) {
+        RLOGE("invalid response length was %d expected %d",
+                (int)responselen, (int)sizeof (RIL_SuppSvcNotification));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_SuppSvcNotification *p_cur = (RIL_SuppSvcNotification *) response;
+    p.writeInt32(p_cur->notificationType);
+    p.writeInt32(p_cur->code);
+    p.writeInt32(p_cur->index);
+    p.writeInt32(p_cur->type);
+    writeStringToParcel(p, p_cur->number);
+
+    startResponse;
+    appendPrintBuf("%s%s,code=%d,id=%d,type=%d,%s", printBuf,
+        (p_cur->notificationType==0)?"mo":"mt",
+         p_cur->code, p_cur->index, p_cur->type,
+        (char*)p_cur->number);
+    closeResponse;
+
+    return 0;
+}
+
+static int responseCellList(Parcel &p, void *response, size_t responselen) {
+    int num;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof (RIL_NeighboringCell *) != 0) {
+        RLOGE("responseCellList: invalid response length %d expected multiple of %d\n",
+            (int)responselen, (int)sizeof (RIL_NeighboringCell *));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+    /* number of records */
+    num = responselen / sizeof(RIL_NeighboringCell *);
+    p.writeInt32(num);
+
+    for (int i = 0 ; i < num ; i++) {
+        RIL_NeighboringCell *p_cur = ((RIL_NeighboringCell **) response)[i];
+
+        p.writeInt32(p_cur->rssi);
+        writeStringToParcel (p, p_cur->cid);
+
+        appendPrintBuf("%s[cid=%s,rssi=%d],", printBuf,
+            p_cur->cid, p_cur->rssi);
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+/**
+ * Marshall the signalInfoRecord into the parcel if it exists.
+ */
+static void marshallSignalInfoRecord(Parcel &p,
+            RIL_CDMA_SignalInfoRecord &p_signalInfoRecord) {
+    p.writeInt32(p_signalInfoRecord.isPresent);
+    p.writeInt32(p_signalInfoRecord.signalType);
+    p.writeInt32(p_signalInfoRecord.alertPitch);
+    p.writeInt32(p_signalInfoRecord.signal);
+}
+
+static int responseCdmaInformationRecords(Parcel &p,
+            void *response, size_t responselen) {
+    int num;
+    char* string8 = NULL;
+    int buffer_lenght;
+    RIL_CDMA_InformationRecord *infoRec;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof (RIL_CDMA_InformationRecords)) {
+        RLOGE("responseCdmaInformationRecords: invalid response length %d expected multiple of %d\n",
+            (int)responselen, (int)sizeof (RIL_CDMA_InformationRecords *));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_CDMA_InformationRecords *p_cur =
+                             (RIL_CDMA_InformationRecords *) response;
+    num = MIN(p_cur->numberOfInfoRecs, RIL_CDMA_MAX_NUMBER_OF_INFO_RECS);
+
+    startResponse;
+    p.writeInt32(num);
+
+    for (int i = 0 ; i < num ; i++) {
+        infoRec = &p_cur->infoRec[i];
+        p.writeInt32(infoRec->name);
+        switch (infoRec->name) {
+            case RIL_CDMA_DISPLAY_INFO_REC:
+            case RIL_CDMA_EXTENDED_DISPLAY_INFO_REC:
+                if (infoRec->rec.display.alpha_len >
+                                         CDMA_ALPHA_INFO_BUFFER_LENGTH) {
+                    RLOGE("invalid display info response length %d \
+                          expected not more than %d\n",
+                         (int)infoRec->rec.display.alpha_len,
+                         CDMA_ALPHA_INFO_BUFFER_LENGTH);
+                    return RIL_ERRNO_INVALID_RESPONSE;
+                }
+                string8 = (char*) calloc(infoRec->rec.display.alpha_len + 1, sizeof(char));
+                if (string8 == NULL) {
+                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
+                    closeRequest;
+                    return RIL_ERRNO_NO_MEMORY;
+                }
+                for (int i = 0 ; i < infoRec->rec.display.alpha_len ; i++) {
+                    string8[i] = infoRec->rec.display.alpha_buf[i];
+                }
+                string8[(int)infoRec->rec.display.alpha_len] = '\0';
+                writeStringToParcel(p, (const char*)string8);
+                free(string8);
+                string8 = NULL;
+                break;
+            case RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC:
+            case RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC:
+            case RIL_CDMA_CONNECTED_NUMBER_INFO_REC:
+                if (infoRec->rec.number.len > CDMA_NUMBER_INFO_BUFFER_LENGTH) {
+                    RLOGE("invalid display info response length %d \
+                          expected not more than %d\n",
+                         (int)infoRec->rec.number.len,
+                         CDMA_NUMBER_INFO_BUFFER_LENGTH);
+                    return RIL_ERRNO_INVALID_RESPONSE;
+                }
+                string8 = (char*) calloc(infoRec->rec.number.len + 1, sizeof(char));
+                if (string8 == NULL) {
+                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
+                    closeRequest;
+                    return RIL_ERRNO_NO_MEMORY;
+                }
+                for (int i = 0 ; i < infoRec->rec.number.len; i++) {
+                    string8[i] = infoRec->rec.number.buf[i];
+                }
+                string8[(int)infoRec->rec.number.len] = '\0';
+                writeStringToParcel(p, (const char*)string8);
+                free(string8);
+                string8 = NULL;
+                p.writeInt32(infoRec->rec.number.number_type);
+                p.writeInt32(infoRec->rec.number.number_plan);
+                p.writeInt32(infoRec->rec.number.pi);
+                p.writeInt32(infoRec->rec.number.si);
+                break;
+            case RIL_CDMA_SIGNAL_INFO_REC:
+                p.writeInt32(infoRec->rec.signal.isPresent);
+                p.writeInt32(infoRec->rec.signal.signalType);
+                p.writeInt32(infoRec->rec.signal.alertPitch);
+                p.writeInt32(infoRec->rec.signal.signal);
+
+                appendPrintBuf("%sisPresent=%X, signalType=%X, \
+                                alertPitch=%X, signal=%X, ",
+                   printBuf, (int)infoRec->rec.signal.isPresent,
+                   (int)infoRec->rec.signal.signalType,
+                   (int)infoRec->rec.signal.alertPitch,
+                   (int)infoRec->rec.signal.signal);
+                removeLastChar;
+                break;
+            case RIL_CDMA_REDIRECTING_NUMBER_INFO_REC:
+                if (infoRec->rec.redir.redirectingNumber.len >
+                                              CDMA_NUMBER_INFO_BUFFER_LENGTH) {
+                    RLOGE("invalid display info response length %d \
+                          expected not more than %d\n",
+                         (int)infoRec->rec.redir.redirectingNumber.len,
+                         CDMA_NUMBER_INFO_BUFFER_LENGTH);
+                    return RIL_ERRNO_INVALID_RESPONSE;
+                }
+                string8 = (char*) calloc(infoRec->rec.redir.redirectingNumber.len + 1,
+                        sizeof(char));
+                if (string8 == NULL) {
+                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
+                    closeRequest;
+                    return RIL_ERRNO_NO_MEMORY;
+                }
+                for (int i = 0;
+                         i < infoRec->rec.redir.redirectingNumber.len;
+                         i++) {
+                    string8[i] = infoRec->rec.redir.redirectingNumber.buf[i];
+                }
+                string8[(int)infoRec->rec.redir.redirectingNumber.len] = '\0';
+                writeStringToParcel(p, (const char*)string8);
+                free(string8);
+                string8 = NULL;
+                p.writeInt32(infoRec->rec.redir.redirectingNumber.number_type);
+                p.writeInt32(infoRec->rec.redir.redirectingNumber.number_plan);
+                p.writeInt32(infoRec->rec.redir.redirectingNumber.pi);
+                p.writeInt32(infoRec->rec.redir.redirectingNumber.si);
+                p.writeInt32(infoRec->rec.redir.redirectingReason);
+                break;
+            case RIL_CDMA_LINE_CONTROL_INFO_REC:
+                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlPolarityIncluded);
+                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlToggle);
+                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlReverse);
+                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlPowerDenial);
+
+                appendPrintBuf("%slineCtrlPolarityIncluded=%d, \
+                                lineCtrlToggle=%d, lineCtrlReverse=%d, \
+                                lineCtrlPowerDenial=%d, ", printBuf,
+                       (int)infoRec->rec.lineCtrl.lineCtrlPolarityIncluded,
+                       (int)infoRec->rec.lineCtrl.lineCtrlToggle,
+                       (int)infoRec->rec.lineCtrl.lineCtrlReverse,
+                       (int)infoRec->rec.lineCtrl.lineCtrlPowerDenial);
+                removeLastChar;
+                break;
+            case RIL_CDMA_T53_CLIR_INFO_REC:
+                p.writeInt32((int)(infoRec->rec.clir.cause));
+
+                appendPrintBuf("%scause%d", printBuf, infoRec->rec.clir.cause);
+                removeLastChar;
+                break;
+            case RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC:
+                p.writeInt32(infoRec->rec.audioCtrl.upLink);
+                p.writeInt32(infoRec->rec.audioCtrl.downLink);
+
+                appendPrintBuf("%supLink=%d, downLink=%d, ", printBuf,
+                        infoRec->rec.audioCtrl.upLink,
+                        infoRec->rec.audioCtrl.downLink);
+                removeLastChar;
+                break;
+            case RIL_CDMA_T53_RELEASE_INFO_REC:
+                // TODO(Moto): See David Krause, he has the answer:)
+                RLOGE("RIL_CDMA_T53_RELEASE_INFO_REC: return INVALID_RESPONSE");
+                return RIL_ERRNO_INVALID_RESPONSE;
+            default:
+                RLOGE("Incorrect name value");
+                return RIL_ERRNO_INVALID_RESPONSE;
+        }
+    }
+    closeResponse;
+
+    return 0;
+}
+
+static void responseRilSignalStrengthV5(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
+    p.writeInt32(p_cur->GW_SignalStrength.signalStrength);
+    p.writeInt32(p_cur->GW_SignalStrength.bitErrorRate);
+    p.writeInt32(p_cur->CDMA_SignalStrength.dbm);
+    p.writeInt32(p_cur->CDMA_SignalStrength.ecio);
+    p.writeInt32(p_cur->EVDO_SignalStrength.dbm);
+    p.writeInt32(p_cur->EVDO_SignalStrength.ecio);
+    p.writeInt32(p_cur->EVDO_SignalStrength.signalNoiseRatio);
+}
+
+static void responseRilSignalStrengthV6Extra(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
+    /*
+     * Fixup LTE for backwards compatibility
+     */
+    // signalStrength: -1 -> 99
+    if (p_cur->LTE_SignalStrength.signalStrength == -1) {
+        p_cur->LTE_SignalStrength.signalStrength = 99;
+    }
+    // rsrp: -1 -> INT_MAX all other negative value to positive.
+    // So remap here
+    if (p_cur->LTE_SignalStrength.rsrp == -1) {
+        p_cur->LTE_SignalStrength.rsrp = INT_MAX;
+    } else if (p_cur->LTE_SignalStrength.rsrp < -1) {
+        p_cur->LTE_SignalStrength.rsrp = -p_cur->LTE_SignalStrength.rsrp;
+    }
+    // rsrq: -1 -> INT_MAX
+    if (p_cur->LTE_SignalStrength.rsrq == -1) {
+        p_cur->LTE_SignalStrength.rsrq = INT_MAX;
+    }
+    // Not remapping rssnr is already using INT_MAX
+
+    // cqi: -1 -> INT_MAX
+    if (p_cur->LTE_SignalStrength.cqi == -1) {
+        p_cur->LTE_SignalStrength.cqi = INT_MAX;
+    }
+
+    p.writeInt32(p_cur->LTE_SignalStrength.signalStrength);
+    p.writeInt32(p_cur->LTE_SignalStrength.rsrp);
+    p.writeInt32(p_cur->LTE_SignalStrength.rsrq);
+    p.writeInt32(p_cur->LTE_SignalStrength.rssnr);
+    p.writeInt32(p_cur->LTE_SignalStrength.cqi);
+}
+
+static void responseRilSignalStrengthV10(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
+    responseRilSignalStrengthV5(p, p_cur);
+    responseRilSignalStrengthV6Extra(p, p_cur);
+    p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
+}
+
+static int responseRilSignalStrength(Parcel &p,
+                    void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_SignalStrength_v10 *p_cur;
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (responselen >= sizeof (RIL_SignalStrength_v5)) {
+            p_cur = ((RIL_SignalStrength_v10 *) response);
+
+            responseRilSignalStrengthV5(p, p_cur);
+
+            if (responselen >= sizeof (RIL_SignalStrength_v6)) {
+                responseRilSignalStrengthV6Extra(p, p_cur);
+                if (responselen >= sizeof (RIL_SignalStrength_v10)) {
+                    p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
+                } else {
+                    p.writeInt32(INT_MAX);
+                }
+            } else {
+                p.writeInt32(99);
+                p.writeInt32(INT_MAX);
+                p.writeInt32(INT_MAX);
+                p.writeInt32(INT_MAX);
+                p.writeInt32(INT_MAX);
+                p.writeInt32(INT_MAX);
+            }
+        } else {
+            RLOGE("invalid response length");
+            return RIL_ERRNO_INVALID_RESPONSE;
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_SignalStrength_v10) != 0) {
+            RLOGE("Data structure expected is RIL_SignalStrength_v10");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        p_cur = ((RIL_SignalStrength_v10 *) response);
+        responseRilSignalStrengthV10(p, p_cur);
+    }
+    startResponse;
+    appendPrintBuf("%s[signalStrength=%d,bitErrorRate=%d,\
+            CDMA_SS.dbm=%d,CDMA_SSecio=%d,\
+            EVDO_SS.dbm=%d,EVDO_SS.ecio=%d,\
+            EVDO_SS.signalNoiseRatio=%d,\
+            LTE_SS.signalStrength=%d,LTE_SS.rsrp=%d,LTE_SS.rsrq=%d,\
+            LTE_SS.rssnr=%d,LTE_SS.cqi=%d,TDSCDMA_SS.rscp=%d]",
+            printBuf,
+            p_cur->GW_SignalStrength.signalStrength,
+            p_cur->GW_SignalStrength.bitErrorRate,
+            p_cur->CDMA_SignalStrength.dbm,
+            p_cur->CDMA_SignalStrength.ecio,
+            p_cur->EVDO_SignalStrength.dbm,
+            p_cur->EVDO_SignalStrength.ecio,
+            p_cur->EVDO_SignalStrength.signalNoiseRatio,
+            p_cur->LTE_SignalStrength.signalStrength,
+            p_cur->LTE_SignalStrength.rsrp,
+            p_cur->LTE_SignalStrength.rsrq,
+            p_cur->LTE_SignalStrength.rssnr,
+            p_cur->LTE_SignalStrength.cqi,
+            p_cur->TD_SCDMA_SignalStrength.rscp);
+    closeResponse;
+    return 0;
+}
+
+static int responseCallRing(Parcel &p, void *response, size_t responselen) {
+    if ((response == NULL) || (responselen == 0)) {
+        return responseVoid(p, response, responselen);
+    } else {
+        return responseCdmaSignalInfoRecord(p, response, responselen);
+    }
+}
+
+static int responseCdmaSignalInfoRecord(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL || responselen == 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof (RIL_CDMA_SignalInfoRecord)) {
+        RLOGE("invalid response length %d expected sizeof (RIL_CDMA_SignalInfoRecord) of %d\n",
+            (int)responselen, (int)sizeof (RIL_CDMA_SignalInfoRecord));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+
+    RIL_CDMA_SignalInfoRecord *p_cur = ((RIL_CDMA_SignalInfoRecord *) response);
+    marshallSignalInfoRecord(p, *p_cur);
+
+    appendPrintBuf("%s[isPresent=%d,signalType=%d,alertPitch=%d\
+              signal=%d]",
+              printBuf,
+              p_cur->isPresent,
+              p_cur->signalType,
+              p_cur->alertPitch,
+              p_cur->signal);
+
+    closeResponse;
+    return 0;
+}
+
+static int responseCdmaCallWaiting(Parcel &p, void *response,
+            size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen < sizeof(RIL_CDMA_CallWaiting_v6)) {
+        RLOGW("Upgrade to ril version %d\n", RIL_VERSION);
+    }
+
+    RIL_CDMA_CallWaiting_v6 *p_cur = ((RIL_CDMA_CallWaiting_v6 *) response);
+
+    writeStringToParcel(p, p_cur->number);
+    p.writeInt32(p_cur->numberPresentation);
+    writeStringToParcel(p, p_cur->name);
+    marshallSignalInfoRecord(p, p_cur->signalInfoRecord);
+
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (responselen >= sizeof(RIL_CDMA_CallWaiting_v6)) {
+            p.writeInt32(p_cur->number_type);
+            p.writeInt32(p_cur->number_plan);
+        } else {
+            p.writeInt32(0);
+            p.writeInt32(0);
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_CDMA_CallWaiting_v6) != 0) {
+            RLOGE("Data structure expected is RIL_CDMA_CallWaiting_v6");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        p.writeInt32(p_cur->number_type);
+        p.writeInt32(p_cur->number_plan);
+    }
+
+    startResponse;
+    appendPrintBuf("%snumber=%s,numberPresentation=%d, name=%s,\
+            signalInfoRecord[isPresent=%d,signalType=%d,alertPitch=%d\
+            signal=%d,number_type=%d,number_plan=%d]",
+            printBuf,
+            p_cur->number,
+            p_cur->numberPresentation,
+            p_cur->name,
+            p_cur->signalInfoRecord.isPresent,
+            p_cur->signalInfoRecord.signalType,
+            p_cur->signalInfoRecord.alertPitch,
+            p_cur->signalInfoRecord.signal,
+            p_cur->number_type,
+            p_cur->number_plan);
+    closeResponse;
+
+    return 0;
+}
+
+static void responseSimRefreshV7(Parcel &p, void *response) {
+      RIL_SimRefreshResponse_v7 *p_cur = ((RIL_SimRefreshResponse_v7 *) response);
+      p.writeInt32(p_cur->result);
+      p.writeInt32(p_cur->ef_id);
+      writeStringToParcel(p, p_cur->aid);
+
+      appendPrintBuf("%sresult=%d, ef_id=%d, aid=%s",
+            printBuf,
+            p_cur->result,
+            p_cur->ef_id,
+            p_cur->aid);
+
+}
+
+static int responseSimRefresh(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("responseSimRefresh: invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (s_callbacks.version >= 7) {
+            responseSimRefreshV7(p, response);
+        } else {
+            int *p_cur = ((int *) response);
+            p.writeInt32(p_cur[0]);
+            p.writeInt32(p_cur[1]);
+            writeStringToParcel(p, NULL);
+
+            appendPrintBuf("%sresult=%d, ef_id=%d",
+                    printBuf,
+                    p_cur[0],
+                    p_cur[1]);
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_SimRefreshResponse_v7) != 0) {
+            RLOGE("Data structure expected is RIL_SimRefreshResponse_v7");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        responseSimRefreshV7(p, response);
+
+    }
+    closeResponse;
+
+    return 0;
+}
+
+static int responseCellInfoListV6(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_CellInfo) != 0) {
+        RLOGE("responseCellInfoList: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_CellInfo));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    int num = responselen / sizeof(RIL_CellInfo);
+    p.writeInt32(num);
+
+    RIL_CellInfo *p_cur = (RIL_CellInfo *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32((int)p_cur->cellInfoType);
+        p.writeInt32(p_cur->registered);
+        p.writeInt32(p_cur->timeStampType);
+        p.writeInt64(p_cur->timeStamp);
+        switch(p_cur->cellInfoType) {
+            case RIL_CELL_INFO_TYPE_GSM: {
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mcc);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mnc);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.lac);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.cid);
+                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength);
+                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_WCDMA: {
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.lac);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.cid);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
+                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength);
+                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_CDMA: {
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.networkId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.systemId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.basestationId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.longitude);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
+
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.dbm);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.ecio);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.dbm);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.ecio);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_LTE: {
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mcc);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mnc);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.ci);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.pci);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.tac);
+
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.signalStrength);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrp);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrq);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rssnr);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.cqi);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_TD_SCDMA: {
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.lac);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cid);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cpid);
+                p.writeInt32(p_cur->CellInfo.tdscdma.signalStrengthTdscdma.rscp);
+                break;
+            }
+        }
+        p_cur += 1;
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static int responseCellInfoListV12(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen % sizeof(RIL_CellInfo_v12) != 0) {
+        RLOGE("responseCellInfoList: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_CellInfo_v12));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    int num = responselen / sizeof(RIL_CellInfo_v12);
+    p.writeInt32(num);
+
+    RIL_CellInfo_v12 *p_cur = (RIL_CellInfo_v12 *) response;
+    startResponse;
+    int i;
+    for (i = 0; i < num; i++) {
+        p.writeInt32((int)p_cur->cellInfoType);
+        p.writeInt32(p_cur->registered);
+        p.writeInt32(p_cur->timeStampType);
+        p.writeInt64(p_cur->timeStamp);
+        switch(p_cur->cellInfoType) {
+            case RIL_CELL_INFO_TYPE_GSM: {
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mcc);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mnc);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.lac);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.cid);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.arfcn);
+                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.bsic);
+                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength);
+                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
+                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.timingAdvance);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_WCDMA: {
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.lac);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.cid);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
+                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.uarfcn);
+                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength);
+                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_CDMA: {
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.networkId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.systemId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.basestationId);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.longitude);
+                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
+
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.dbm);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.ecio);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.dbm);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.ecio);
+                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_LTE: {
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mcc);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mnc);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.ci);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.pci);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.tac);
+                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.earfcn);
+
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.signalStrength);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrp);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrq);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rssnr);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.cqi);
+                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
+                break;
+            }
+            case RIL_CELL_INFO_TYPE_TD_SCDMA: {
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.lac);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cid);
+                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cpid);
+                p.writeInt32(p_cur->CellInfo.tdscdma.signalStrengthTdscdma.rscp);
+                break;
+            }
+        }
+        p_cur += 1;
+    }
+    removeLastChar;
+    closeResponse;
+    return 0;
+}
+
+static int responseCellInfoList(Parcel &p, void *response, size_t responselen)
+{
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (s_callbacks.version < 12) {
+            RLOGD("responseCellInfoList: v6");
+            return responseCellInfoListV6(p, response, responselen);
+        } else {
+            RLOGD("responseCellInfoList: v12");
+            return responseCellInfoListV12(p, response, responselen);
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_CellInfo_v12) != 0) {
+            RLOGE("Data structure expected is RIL_CellInfo_v12");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        return responseCellInfoListV12(p, response, responselen);
+    }
+
+    return 0;
+}
+
+static int responseHardwareConfig(Parcel &p, void *response, size_t responselen)
+{
+   if (response == NULL && responselen != 0) {
+       RLOGE("invalid response: NULL");
+       return RIL_ERRNO_INVALID_RESPONSE;
+   }
+
+   if (responselen % sizeof(RIL_HardwareConfig) != 0) {
+       RLOGE("responseHardwareConfig: invalid response length %d expected multiple of %d",
+          (int)responselen, (int)sizeof(RIL_HardwareConfig));
+       return RIL_ERRNO_INVALID_RESPONSE;
+   }
+
+   int num = responselen / sizeof(RIL_HardwareConfig);
+   int i;
+   RIL_HardwareConfig *p_cur = (RIL_HardwareConfig *) response;
+
+   p.writeInt32(num);
+
+   startResponse;
+   for (i = 0; i < num; i++) {
+      switch (p_cur[i].type) {
+         case RIL_HARDWARE_CONFIG_MODEM: {
+            writeStringToParcel(p, p_cur[i].uuid);
+            p.writeInt32((int)p_cur[i].state);
+            p.writeInt32(p_cur[i].cfg.modem.rat);
+            p.writeInt32(p_cur[i].cfg.modem.maxVoice);
+            p.writeInt32(p_cur[i].cfg.modem.maxData);
+            p.writeInt32(p_cur[i].cfg.modem.maxStandby);
+
+            appendPrintBuf("%s modem: uuid=%s,state=%d,rat=%08x,maxV=%d,maxD=%d,maxS=%d", printBuf,
+               p_cur[i].uuid, (int)p_cur[i].state, p_cur[i].cfg.modem.rat,
+               p_cur[i].cfg.modem.maxVoice, p_cur[i].cfg.modem.maxData, p_cur[i].cfg.modem.maxStandby);
+            break;
+         }
+         case RIL_HARDWARE_CONFIG_SIM: {
+            writeStringToParcel(p, p_cur[i].uuid);
+            p.writeInt32((int)p_cur[i].state);
+            writeStringToParcel(p, p_cur[i].cfg.sim.modemUuid);
+
+            appendPrintBuf("%s sim: uuid=%s,state=%d,modem-uuid=%s", printBuf,
+               p_cur[i].uuid, (int)p_cur[i].state, p_cur[i].cfg.sim.modemUuid);
+            break;
+         }
+      }
+   }
+   removeLastChar;
+   closeResponse;
+   return 0;
+}
+
+static int responseRadioCapability(Parcel &p, void *response, size_t responselen) {
+    if (response == NULL) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof (RIL_RadioCapability) ) {
+        RLOGE("invalid response length was %d expected %d",
+                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_RadioCapability *p_cur = (RIL_RadioCapability *) response;
+    p.writeInt32(p_cur->version);
+    p.writeInt32(p_cur->session);
+    p.writeInt32(p_cur->phase);
+    p.writeInt32(p_cur->rat);
+    writeStringToParcel(p, p_cur->logicalModemUuid);
+    p.writeInt32(p_cur->status);
+
+    startResponse;
+    appendPrintBuf("%s[version=%d,session=%d,phase=%d,\
+            rat=%s,logicalModemUuid=%s,status=%d]",
+            printBuf,
+            p_cur->version,
+            p_cur->session,
+            p_cur->phase,
+            p_cur->rat,
+            p_cur->logicalModemUuid,
+            p_cur->status);
+    closeResponse;
+    return 0;
+}
+
+static int responseSSData(Parcel &p, void *response, size_t responselen) {
+    RLOGD("In responseSSData");
+    int num;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response length was %d expected %d",
+                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof(RIL_StkCcUnsolSsResponse)) {
+        RLOGE("invalid response length %d, expected %d",
+               (int)responselen, (int)sizeof(RIL_StkCcUnsolSsResponse));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+    RIL_StkCcUnsolSsResponse *p_cur = (RIL_StkCcUnsolSsResponse *) response;
+    p.writeInt32(p_cur->serviceType);
+    p.writeInt32(p_cur->requestType);
+    p.writeInt32(p_cur->teleserviceType);
+    p.writeInt32(p_cur->serviceClass);
+    p.writeInt32(p_cur->result);
+
+    if (isServiceTypeCfQuery(p_cur->serviceType, p_cur->requestType)) {
+        RLOGD("responseSSData CF type, num of Cf elements %d", p_cur->cfData.numValidIndexes);
+        if (p_cur->cfData.numValidIndexes > NUM_SERVICE_CLASSES) {
+            RLOGE("numValidIndexes is greater than max value %d, "
+                  "truncating it to max value", NUM_SERVICE_CLASSES);
+            p_cur->cfData.numValidIndexes = NUM_SERVICE_CLASSES;
+        }
+        /* number of call info's */
+        p.writeInt32(p_cur->cfData.numValidIndexes);
+
+        for (int i = 0; i < p_cur->cfData.numValidIndexes; i++) {
+             RIL_CallForwardInfo cf = p_cur->cfData.cfInfo[i];
+
+             p.writeInt32(cf.status);
+             p.writeInt32(cf.reason);
+             p.writeInt32(cf.serviceClass);
+             p.writeInt32(cf.toa);
+             writeStringToParcel(p, cf.number);
+             p.writeInt32(cf.timeSeconds);
+             appendPrintBuf("%s[%s,reason=%d,cls=%d,toa=%d,%s,tout=%d],", printBuf,
+                 (cf.status==1)?"enable":"disable", cf.reason, cf.serviceClass, cf.toa,
+                  (char*)cf.number, cf.timeSeconds);
+             RLOGD("Data: %d,reason=%d,cls=%d,toa=%d,num=%s,tout=%d],", cf.status,
+                  cf.reason, cf.serviceClass, cf.toa, (char*)cf.number, cf.timeSeconds);
+        }
+    } else {
+        p.writeInt32 (SS_INFO_MAX);
+
+        /* each int*/
+        for (int i = 0; i < SS_INFO_MAX; i++) {
+             appendPrintBuf("%s%d,", printBuf, p_cur->ssInfo[i]);
+             RLOGD("Data: %d",p_cur->ssInfo[i]);
+             p.writeInt32(p_cur->ssInfo[i]);
+        }
+    }
+    removeLastChar;
+    closeResponse;
+
+    return 0;
+}
+
+static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType) {
+    if ((reqType == SS_INTERROGATION) &&
+        (serType == SS_CFU ||
+         serType == SS_CF_BUSY ||
+         serType == SS_CF_NO_REPLY ||
+         serType == SS_CF_NOT_REACHABLE ||
+         serType == SS_CF_ALL ||
+         serType == SS_CF_ALL_CONDITIONAL)) {
+        return true;
+    }
+    return false;
+}
+
+static void triggerEvLoop() {
+    int ret;
+    if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
+        /* trigger event loop to wakeup. No reason to do this,
+         * if we're in the event loop thread */
+         do {
+            ret = write (s_fdWakeupWrite, " ", 1);
+         } while (ret < 0 && errno == EINTR);
+    }
+}
+
+static void rilEventAddWakeup(struct ril_event *ev) {
+    ril_event_add(ev);
+    triggerEvLoop();
+}
+
+static void sendSimStatusAppInfo(Parcel &p, int num_apps, RIL_AppStatus appStatus[]) {
+        p.writeInt32(num_apps);
+        startResponse;
+        for (int i = 0; i < num_apps; i++) {
+            p.writeInt32(appStatus[i].app_type);
+            p.writeInt32(appStatus[i].app_state);
+            p.writeInt32(appStatus[i].perso_substate);
+            writeStringToParcel(p, (const char*)(appStatus[i].aid_ptr));
+            writeStringToParcel(p, (const char*)
+                                          (appStatus[i].app_label_ptr));
+            p.writeInt32(appStatus[i].pin1_replaced);
+            p.writeInt32(appStatus[i].pin1);
+            p.writeInt32(appStatus[i].pin2);
+            appendPrintBuf("%s[app_type=%d,app_state=%d,perso_substate=%d,\
+                    aid_ptr=%s,app_label_ptr=%s,pin1_replaced=%d,pin1=%d,pin2=%d],",
+                    printBuf,
+                    appStatus[i].app_type,
+                    appStatus[i].app_state,
+                    appStatus[i].perso_substate,
+                    appStatus[i].aid_ptr,
+                    appStatus[i].app_label_ptr,
+                    appStatus[i].pin1_replaced,
+                    appStatus[i].pin1,
+                    appStatus[i].pin2);
+        }
+        closeResponse;
+}
+
+static void responseSimStatusV5(Parcel &p, void *response) {
+    RIL_CardStatus_v5 *p_cur = ((RIL_CardStatus_v5 *) response);
+
+    p.writeInt32(p_cur->card_state);
+    p.writeInt32(p_cur->universal_pin_state);
+    p.writeInt32(p_cur->gsm_umts_subscription_app_index);
+    p.writeInt32(p_cur->cdma_subscription_app_index);
+
+    sendSimStatusAppInfo(p, p_cur->num_applications, p_cur->applications);
+}
+
+static void responseSimStatusV6(Parcel &p, void *response) {
+    RIL_CardStatus_v6 *p_cur = ((RIL_CardStatus_v6 *) response);
+
+    p.writeInt32(p_cur->card_state);
+    p.writeInt32(p_cur->universal_pin_state);
+    p.writeInt32(p_cur->gsm_umts_subscription_app_index);
+    p.writeInt32(p_cur->cdma_subscription_app_index);
+    p.writeInt32(p_cur->ims_subscription_app_index);
+
+    sendSimStatusAppInfo(p, p_cur->num_applications, p_cur->applications);
+}
+
+static int responseSimStatus(Parcel &p, void *response, size_t responselen) {
+    int i;
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
+        if (responselen == sizeof (RIL_CardStatus_v6)) {
+            responseSimStatusV6(p, response);
+        } else if (responselen == sizeof (RIL_CardStatus_v5)) {
+            responseSimStatusV5(p, response);
+        } else {
+            RLOGE("responseSimStatus: A RilCardStatus_v6 or _v5 expected\n");
+            return RIL_ERRNO_INVALID_RESPONSE;
+        }
+    } else { // RIL version >= 13
+        if (responselen % sizeof(RIL_CardStatus_v6) != 0) {
+            RLOGE("Data structure expected is RIL_CardStatus_v6");
+            if (!isDebuggable()) {
+                return RIL_ERRNO_INVALID_RESPONSE;
+            } else {
+                assert(0);
+            }
+        }
+        responseSimStatusV6(p, response);
+    }
+
+    return 0;
+}
+
+static int responseGsmBrSmsCnf(Parcel &p, void *response, size_t responselen) {
+    int num = responselen / sizeof(RIL_GSM_BroadcastSmsConfigInfo *);
+    p.writeInt32(num);
+
+    startResponse;
+    RIL_GSM_BroadcastSmsConfigInfo **p_cur =
+                (RIL_GSM_BroadcastSmsConfigInfo **) response;
+    for (int i = 0; i < num; i++) {
+        p.writeInt32(p_cur[i]->fromServiceId);
+        p.writeInt32(p_cur[i]->toServiceId);
+        p.writeInt32(p_cur[i]->fromCodeScheme);
+        p.writeInt32(p_cur[i]->toCodeScheme);
+        p.writeInt32(p_cur[i]->selected);
+
+        appendPrintBuf("%s [%d: fromServiceId=%d, toServiceId=%d, \
+                fromCodeScheme=%d, toCodeScheme=%d, selected =%d]",
+                printBuf, i, p_cur[i]->fromServiceId, p_cur[i]->toServiceId,
+                p_cur[i]->fromCodeScheme, p_cur[i]->toCodeScheme,
+                p_cur[i]->selected);
+    }
+    closeResponse;
+
+    return 0;
+}
+
+static int responseCdmaBrSmsCnf(Parcel &p, void *response, size_t responselen) {
+    RIL_CDMA_BroadcastSmsConfigInfo **p_cur =
+               (RIL_CDMA_BroadcastSmsConfigInfo **) response;
+
+    int num = responselen / sizeof (RIL_CDMA_BroadcastSmsConfigInfo *);
+    p.writeInt32(num);
+
+    startResponse;
+    for (int i = 0 ; i < num ; i++ ) {
+        p.writeInt32(p_cur[i]->service_category);
+        p.writeInt32(p_cur[i]->language);
+        p.writeInt32(p_cur[i]->selected);
+
+        appendPrintBuf("%s [%d: srvice_category=%d, language =%d, \
+              selected =%d], ",
+              printBuf, i, p_cur[i]->service_category, p_cur[i]->language,
+              p_cur[i]->selected);
+    }
+    closeResponse;
+
+    return 0;
+}
+
+static int responseCdmaSms(Parcel &p, void *response, size_t responselen) {
+    int num;
+    int digitCount;
+    int digitLimit;
+    uint8_t uct;
+    void* dest;
+
+    RLOGD("Inside responseCdmaSms");
+
+    if (response == NULL && responselen != 0) {
+        RLOGE("invalid response: NULL");
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    if (responselen != sizeof(RIL_CDMA_SMS_Message)) {
+        RLOGE("invalid response length was %d expected %d",
+                (int)responselen, (int)sizeof(RIL_CDMA_SMS_Message));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    RIL_CDMA_SMS_Message *p_cur = (RIL_CDMA_SMS_Message *) response;
+    p.writeInt32(p_cur->uTeleserviceID);
+    p.write(&(p_cur->bIsServicePresent),sizeof(uct));
+    p.writeInt32(p_cur->uServicecategory);
+    p.writeInt32(p_cur->sAddress.digit_mode);
+    p.writeInt32(p_cur->sAddress.number_mode);
+    p.writeInt32(p_cur->sAddress.number_type);
+    p.writeInt32(p_cur->sAddress.number_plan);
+    p.write(&(p_cur->sAddress.number_of_digits), sizeof(uct));
+    digitLimit= MIN((p_cur->sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+        p.write(&(p_cur->sAddress.digits[digitCount]),sizeof(uct));
+    }
+
+    p.writeInt32(p_cur->sSubAddress.subaddressType);
+    p.write(&(p_cur->sSubAddress.odd),sizeof(uct));
+    p.write(&(p_cur->sSubAddress.number_of_digits),sizeof(uct));
+    digitLimit= MIN((p_cur->sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+        p.write(&(p_cur->sSubAddress.digits[digitCount]),sizeof(uct));
+    }
+
+    digitLimit= MIN((p_cur->uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
+    p.writeInt32(p_cur->uBearerDataLen);
+    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
+       p.write(&(p_cur->aBearerData[digitCount]), sizeof(uct));
+    }
+
+    startResponse;
+    appendPrintBuf("%suTeleserviceID=%d, bIsServicePresent=%d, uServicecategory=%d, \
+            sAddress.digit_mode=%d, sAddress.number_mode=%d, sAddress.number_type=%d, ",
+            printBuf, p_cur->uTeleserviceID,p_cur->bIsServicePresent,p_cur->uServicecategory,
+            p_cur->sAddress.digit_mode, p_cur->sAddress.number_mode,p_cur->sAddress.number_type);
+    closeResponse;
+
+    return 0;
+}
+
+static int responseDcRtInfo(Parcel &p, void *response, size_t responselen)
+{
+    int num = responselen / sizeof(RIL_DcRtInfo);
+    if ((responselen % sizeof(RIL_DcRtInfo) != 0) || (num != 1)) {
+        RLOGE("responseDcRtInfo: invalid response length %d expected multiple of %d",
+                (int)responselen, (int)sizeof(RIL_DcRtInfo));
+        return RIL_ERRNO_INVALID_RESPONSE;
+    }
+
+    startResponse;
+    RIL_DcRtInfo *pDcRtInfo = (RIL_DcRtInfo *)response;
+    p.writeInt64(pDcRtInfo->time);
+    p.writeInt32(pDcRtInfo->powerState);
+    appendPrintBuf("%s[time=%d,powerState=%d]", printBuf,
+        pDcRtInfo->time,
+        pDcRtInfo->powerState);
+    closeResponse;
+
+    return 0;
+}
+
+static int responseLceStatus(Parcel &p, void *response, size_t responselen) {
+  if (response == NULL || responselen != sizeof(RIL_LceStatusInfo)) {
+    if (response == NULL) {
+      RLOGE("invalid response: NULL");
+    }
+    else {
+      RLOGE("responseLceStatus: invalid response length %u expecting len: %u",
+            (unsigned)sizeof(RIL_LceStatusInfo), (unsigned)responselen);
+    }
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+
+  RIL_LceStatusInfo *p_cur = (RIL_LceStatusInfo *)response;
+  p.write((void *)p_cur, 1);  // p_cur->lce_status takes one byte.
+  p.writeInt32(p_cur->actual_interval_ms);
+
+  startResponse;
+  appendPrintBuf("LCE Status: %d, actual_interval_ms: %d",
+                 p_cur->lce_status, p_cur->actual_interval_ms);
+  closeResponse;
+
+  return 0;
+}
+
+static int responseLceData(Parcel &p, void *response, size_t responselen) {
+  if (response == NULL || responselen != sizeof(RIL_LceDataInfo)) {
+    if (response == NULL) {
+      RLOGE("invalid response: NULL");
+    }
+    else {
+      RLOGE("responseLceData: invalid response length %u expecting len: %u",
+            (unsigned)sizeof(RIL_LceDataInfo), (unsigned)responselen);
+    }
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+
+  RIL_LceDataInfo *p_cur = (RIL_LceDataInfo *)response;
+  p.writeInt32(p_cur->last_hop_capacity_kbps);
+
+  /* p_cur->confidence_level and p_cur->lce_suspended take 1 byte each.*/
+  p.write((void *)&(p_cur->confidence_level), 1);
+  p.write((void *)&(p_cur->lce_suspended), 1);
+
+  startResponse;
+  appendPrintBuf("LCE info received: capacity %d confidence level %d \
+                  and suspended %d",
+                  p_cur->last_hop_capacity_kbps, p_cur->confidence_level,
+                  p_cur->lce_suspended);
+  closeResponse;
+
+  return 0;
+}
+
+static int responseActivityData(Parcel &p, void *response, size_t responselen) {
+  if (response == NULL || responselen != sizeof(RIL_ActivityStatsInfo)) {
+    if (response == NULL) {
+      RLOGE("invalid response: NULL");
+    }
+    else {
+      RLOGE("responseActivityData: invalid response length %u expecting len: %u",
+            (unsigned)sizeof(RIL_ActivityStatsInfo), (unsigned)responselen);
+    }
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+
+  RIL_ActivityStatsInfo *p_cur = (RIL_ActivityStatsInfo *)response;
+  p.writeInt32(p_cur->sleep_mode_time_ms);
+  p.writeInt32(p_cur->idle_mode_time_ms);
+  for(int i = 0; i < RIL_NUM_TX_POWER_LEVELS; i++) {
+    p.writeInt32(p_cur->tx_mode_time_ms[i]);
+  }
+  p.writeInt32(p_cur->rx_mode_time_ms);
+
+  startResponse;
+  appendPrintBuf("Modem activity info received: sleep_mode_time_ms %d idle_mode_time_ms %d \
+                  tx_mode_time_ms %d %d %d %d %d and rx_mode_time_ms %d",
+                  p_cur->sleep_mode_time_ms, p_cur->idle_mode_time_ms, p_cur->tx_mode_time_ms[0],
+                  p_cur->tx_mode_time_ms[1], p_cur->tx_mode_time_ms[2], p_cur->tx_mode_time_ms[3],
+                  p_cur->tx_mode_time_ms[4], p_cur->rx_mode_time_ms);
+   closeResponse;
+
+  return 0;
+}
+
+static int responseCarrierRestrictions(Parcel &p, void *response, size_t responselen) {
+  if (response == NULL) {
+    RLOGE("invalid response: NULL");
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+  if (responselen != sizeof(RIL_CarrierRestrictions)) {
+    RLOGE("responseCarrierRestrictions: invalid response length %u expecting len: %u",
+          (unsigned)responselen, (unsigned)sizeof(RIL_CarrierRestrictions));
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+
+  RIL_CarrierRestrictions *p_cr = (RIL_CarrierRestrictions *)response;
+  startResponse;
+
+  p.writeInt32(p_cr->len_allowed_carriers);
+  p.writeInt32(p_cr->len_excluded_carriers);
+  appendPrintBuf(" %s len_allowed_carriers: %d, len_excluded_carriers: %d,", printBuf,
+                 p_cr->len_allowed_carriers,p_cr->len_excluded_carriers);
+
+  appendPrintBuf(" %s allowed_carriers:", printBuf);
+  for(int32_t i = 0; i < p_cr->len_allowed_carriers; i++) {
+    RIL_Carrier *carrier = p_cr->allowed_carriers + i;
+    writeStringToParcel(p, carrier->mcc);
+    writeStringToParcel(p, carrier->mnc);
+    p.writeInt32(carrier->match_type);
+    writeStringToParcel(p, carrier->match_data);
+    appendPrintBuf(" %s [%d mcc: %s, mnc: %s, match_type: %d, match_data: %s],", printBuf,
+                   i, carrier->mcc, carrier->mnc, carrier->match_type, carrier->match_data);
+  }
+
+  appendPrintBuf(" %s excluded_carriers:", printBuf);
+  for(int32_t i = 0; i < p_cr->len_excluded_carriers; i++) {
+    RIL_Carrier *carrier = p_cr->excluded_carriers + i;
+    writeStringToParcel(p, carrier->mcc);
+    writeStringToParcel(p, carrier->mnc);
+    p.writeInt32(carrier->match_type);
+    writeStringToParcel(p, carrier->match_data);
+    appendPrintBuf(" %s [%d mcc: %s, mnc: %s, match_type: %d, match_data: %s],", printBuf,
+                   i, carrier->mcc, carrier->mnc, carrier->match_type, carrier->match_data);
+  }
+
+  closeResponse;
+
+  return 0;
+}
+
+static int responsePcoData(Parcel &p, void *response, size_t responselen) {
+  if (response == NULL) {
+    RLOGE("responsePcoData: invalid NULL response");
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+  if (responselen != sizeof(RIL_PCO_Data)) {
+    RLOGE("responsePcoData: invalid response length %u, expecting %u",
+          (unsigned)responselen, (unsigned)sizeof(RIL_PCO_Data));
+    return RIL_ERRNO_INVALID_RESPONSE;
+  }
+
+  RIL_PCO_Data *p_cur = (RIL_PCO_Data *)response;
+  p.writeInt32(p_cur->cid);
+  writeStringToParcel(p, p_cur->bearer_proto);
+  p.writeInt32(p_cur->pco_id);
+  p.writeInt32(p_cur->contents_length);
+  p.write(p_cur->contents, p_cur->contents_length);
+
+  startResponse;
+      appendPrintBuf("PCO data received: cid %d, id %d, length %d",
+                     p_cur->cid, p_cur->pco_id, p_cur->contents_length);
+  closeResponse;
+
+  return 0;
+}
+
+/**
+ * A write on the wakeup fd is done just to pop us out of select()
+ * We empty the buffer here and then ril_event will reset the timers on the
+ * way back down
+ */
+static void processWakeupCallback(int fd, short flags, void *param) {
+    char buff[16];
+    int ret;
+
+    RLOGV("processWakeupCallback");
+
+    /* empty our wakeup socket out */
+    do {
+        ret = read(s_fdWakeupRead, &buff, sizeof(buff));
+    } while (ret > 0 || (ret < 0 && errno == EINTR));
+}
+
+static void onCommandsSocketClosed(RIL_SOCKET_ID socket_id) {
+    int ret;
+    RequestInfo *p_cur;
+    /* Hook for current context
+       pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
+    pthread_mutex_t * pendingRequestsMutexHook = &s_pendingRequestsMutex;
+    /* pendingRequestsHook refer to &s_pendingRequests */
+    RequestInfo **    pendingRequestsHook = &s_pendingRequests;
+
+#if (SIM_COUNT >= 2)
+    if (socket_id == RIL_SOCKET_2) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
+        pendingRequestsHook = &s_pendingRequests_socket2;
+    }
+#if (SIM_COUNT >= 3)
+    else if (socket_id == RIL_SOCKET_3) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
+        pendingRequestsHook = &s_pendingRequests_socket3;
+    }
+#endif
+#if (SIM_COUNT >= 4)
+    else if (socket_id == RIL_SOCKET_4) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
+        pendingRequestsHook = &s_pendingRequests_socket4;
+    }
+#endif
+#endif
+    /* mark pending requests as "cancelled" so we dont report responses */
+    ret = pthread_mutex_lock(pendingRequestsMutexHook);
+    assert (ret == 0);
+
+    p_cur = *pendingRequestsHook;
+
+    for (p_cur = *pendingRequestsHook
+            ; p_cur != NULL
+            ; p_cur  = p_cur->p_next
+    ) {
+        p_cur->cancelled = 1;
+    }
+
+    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
+    assert (ret == 0);
+}
+
+static void processCommandsCallback(int fd, short flags, void *param) {
+    RecordStream *p_rs;
+    void *p_record;
+    size_t recordlen;
+    int ret;
+    SocketListenParam *p_info = (SocketListenParam *)param;
+
+    assert(fd == p_info->fdCommand);
+
+    p_rs = p_info->p_rs;
+
+    for (;;) {
+        /* loop until EAGAIN/EINTR, end of stream, or other error */
+        ret = record_stream_get_next(p_rs, &p_record, &recordlen);
+
+        if (ret == 0 && p_record == NULL) {
+            /* end-of-stream */
+            break;
+        } else if (ret < 0) {
+            break;
+        } else if (ret == 0) { /* && p_record != NULL */
+            processCommandBuffer(p_record, recordlen, p_info->socket_id);
+        }
+    }
+
+    if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
+        /* fatal error or end-of-stream */
+        if (ret != 0) {
+            RLOGE("error on reading command socket errno:%d\n", errno);
+        } else {
+            RLOGW("EOS.  Closing command socket.");
+        }
+
+        close(fd);
+        p_info->fdCommand = -1;
+
+        ril_event_del(p_info->commands_event);
+
+        record_stream_free(p_rs);
+
+        /* start listening for new connections again */
+        rilEventAddWakeup(&s_listen_event);
+
+        onCommandsSocketClosed(p_info->socket_id);
+    }
+}
+
+
+static void onNewCommandConnect(RIL_SOCKET_ID socket_id) {
+    // Inform we are connected and the ril version
+    int rilVer = s_callbacks.version;
+    RIL_UNSOL_RESPONSE(RIL_UNSOL_RIL_CONNECTED,
+                                    &rilVer, sizeof(rilVer), socket_id);
+
+    // implicit radio state changed
+    RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
+                                    NULL, 0, socket_id);
+
+    // Send last NITZ time data, in case it was missed
+    if (s_lastNITZTimeData != NULL) {
+        sendResponseRaw(s_lastNITZTimeData, s_lastNITZTimeDataSize, socket_id);
+
+        free(s_lastNITZTimeData);
+        s_lastNITZTimeData = NULL;
+    }
+
+    // Get version string
+    if (s_callbacks.getVersion != NULL) {
+        const char *version;
+        version = s_callbacks.getVersion();
+        RLOGI("RIL Daemon version: %s\n", version);
+
+        property_set(PROPERTY_RIL_IMPL, version);
+    } else {
+        RLOGI("RIL Daemon version: unavailable\n");
+        property_set(PROPERTY_RIL_IMPL, "unavailable");
+    }
+
+}
+
+static void listenCallback (int fd, short flags, void *param) {
+    int ret;
+    int err;
+    int is_phone_socket;
+    int fdCommand = -1;
+    const char* processName;
+    RecordStream *p_rs;
+    MySocketListenParam* listenParam;
+    RilSocket *sapSocket = NULL;
+    socketClient *sClient = NULL;
+
+    SocketListenParam *p_info = (SocketListenParam *)param;
+
+    if(RIL_SAP_SOCKET == p_info->type) {
+        listenParam = (MySocketListenParam *)param;
+        sapSocket = listenParam->socket;
+    }
+
+    struct sockaddr_un peeraddr;
+    socklen_t socklen = sizeof (peeraddr);
+
+    struct ucred creds;
+    socklen_t szCreds = sizeof(creds);
+
+    struct passwd *pwd = NULL;
+
+    if(NULL == sapSocket) {
+        assert (*p_info->fdCommand < 0);
+        assert (fd == *p_info->fdListen);
+        processName = PHONE_PROCESS;
+    } else {
+        assert (sapSocket->commandFd < 0);
+        assert (fd == sapSocket->listenFd);
+        processName = BLUETOOTH_PROCESS;
+    }
+
+
+    fdCommand = accept(fd, (sockaddr *) &peeraddr, &socklen);
+
+    if (fdCommand < 0 ) {
+        RLOGE("Error on accept() errno:%d", errno);
+        /* start listening for new connections again */
+        if(NULL == sapSocket) {
+            rilEventAddWakeup(p_info->listen_event);
+        } else {
+            rilEventAddWakeup(sapSocket->getListenEvent());
+        }
+        return;
+    }
+
+    /* check the credential of the other side and only accept socket from
+     * phone process
+     */
+    errno = 0;
+    is_phone_socket = 0;
+
+    err = getsockopt(fdCommand, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);
+
+    if (err == 0 && szCreds > 0) {
+        errno = 0;
+        pwd = getpwuid(creds.uid);
+        if (pwd != NULL) {
+            if (strcmp(pwd->pw_name, processName) == 0) {
+                is_phone_socket = 1;
+            } else {
+                RLOGE("RILD can't accept socket from process %s", pwd->pw_name);
+            }
+        } else {
+            RLOGE("Error on getpwuid() errno: %d", errno);
+        }
+    } else {
+        RLOGD("Error on getsockopt() errno: %d", errno);
+    }
+
+    if (!is_phone_socket) {
+        RLOGE("RILD must accept socket from %s", processName);
+
+        close(fdCommand);
+        fdCommand = -1;
+
+        if(NULL == sapSocket) {
+            onCommandsSocketClosed(p_info->socket_id);
+
+            /* start listening for new connections again */
+            rilEventAddWakeup(p_info->listen_event);
+        } else {
+            sapSocket->onCommandsSocketClosed();
+
+            /* start listening for new connections again */
+            rilEventAddWakeup(sapSocket->getListenEvent());
+        }
+
+        return;
+    }
+
+    ret = fcntl(fdCommand, F_SETFL, O_NONBLOCK);
+
+    if (ret < 0) {
+        RLOGE ("Error setting O_NONBLOCK errno:%d", errno);
+    }
+
+    if(NULL == sapSocket) {
+        RLOGI("libril: new connection to %s", rilSocketIdToString(p_info->socket_id));
+
+        p_info->fdCommand = fdCommand;
+        p_rs = record_stream_new(p_info->fdCommand, MAX_COMMAND_BYTES);
+        p_info->p_rs = p_rs;
+
+        ril_event_set (p_info->commands_event, p_info->fdCommand, 1,
+        p_info->processCommandsCallback, p_info);
+        rilEventAddWakeup (p_info->commands_event);
+
+        onNewCommandConnect(p_info->socket_id);
+    } else {
+        RLOGI("libril: new connection");
+
+        sapSocket->setCommandFd(fdCommand);
+        p_rs = record_stream_new(sapSocket->getCommandFd(), MAX_COMMAND_BYTES);
+        sClient = new socketClient(sapSocket,p_rs);
+        ril_event_set (sapSocket->getCallbackEvent(), sapSocket->getCommandFd(), 1,
+        sapSocket->getCommandCb(), sClient);
+
+        rilEventAddWakeup(sapSocket->getCallbackEvent());
+        sapSocket->onNewCommandConnect();
+    }
+}
+
+static void freeDebugCallbackArgs(int number, char **args) {
+    for (int i = 0; i < number; i++) {
+        if (args[i] != NULL) {
+            free(args[i]);
+        }
+    }
+    free(args);
+}
+
+static void debugCallback (int fd, short flags, void *param) {
+    int acceptFD, option;
+    struct sockaddr_un peeraddr;
+    socklen_t socklen = sizeof (peeraddr);
+    int data;
+    unsigned int qxdm_data[6];
+    const char *deactData[1] = {"1"};
+    char *actData[1];
+    RIL_Dial dialData;
+    int hangupData[1] = {1};
+    int number;
+    char **args;
+    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
+    int sim_id = 0;
+
+    RLOGI("debugCallback for socket %s", rilSocketIdToString(socket_id));
+
+    acceptFD = accept (fd,  (sockaddr *) &peeraddr, &socklen);
+
+    if (acceptFD < 0) {
+        RLOGE ("error accepting on debug port: %d\n", errno);
+        return;
+    }
+
+    if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
+        RLOGE ("error reading on socket: number of Args: \n");
+        close(acceptFD);
+        return;
+    }
+
+    if (number < 0) {
+        RLOGE ("Invalid number of arguments: \n");
+        close(acceptFD);
+        return;
+    }
+
+    args = (char **) calloc(number, sizeof(char*));
+    if (args == NULL) {
+        RLOGE("Memory allocation failed for debug args");
+        close(acceptFD);
+        return;
+    }
+
+    for (int i = 0; i < number; i++) {
+        int len;
+        if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
+            RLOGE ("error reading on socket: Len of Args: \n");
+            freeDebugCallbackArgs(i, args);
+            close(acceptFD);
+            return;
+        }
+        if (len == INT_MAX || len < 0) {
+            RLOGE("Invalid value of len: \n");
+            freeDebugCallbackArgs(i, args);
+            close(acceptFD);
+            return;
+        }
+
+        // +1 for null-term
+        args[i] = (char *) calloc(len + 1, sizeof(char));
+        if (args[i] == NULL) {
+            RLOGE("Memory allocation failed for debug args");
+            freeDebugCallbackArgs(i, args);
+            close(acceptFD);
+            return;
+        }
+        if (recv(acceptFD, args[i], sizeof(char) * len, 0)
+            != (int)sizeof(char) * len) {
+            RLOGE ("error reading on socket: Args[%d] \n", i);
+            freeDebugCallbackArgs(i, args);
+            close(acceptFD);
+            return;
+        }
+        char * buf = args[i];
+        buf[len] = 0;
+        if ((i+1) == number) {
+            /* The last argument should be sim id 0(SIM1)~3(SIM4) */
+            sim_id = atoi(args[i]);
+            switch (sim_id) {
+                case 0:
+                    socket_id = RIL_SOCKET_1;
+                    break;
+            #if (SIM_COUNT >= 2)
+                case 1:
+                    socket_id = RIL_SOCKET_2;
+                    break;
+            #endif
+            #if (SIM_COUNT >= 3)
+                case 2:
+                    socket_id = RIL_SOCKET_3;
+                    break;
+            #endif
+            #if (SIM_COUNT >= 4)
+                case 3:
+                    socket_id = RIL_SOCKET_4;
+                    break;
+            #endif
+                default:
+                    socket_id = RIL_SOCKET_1;
+                    break;
+            }
+        }
+    }
+
+    switch (atoi(args[0])) {
+        case 0:
+            RLOGI ("Connection on debug port: issuing reset.");
+            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
+            break;
+        case 1:
+            RLOGI ("Connection on debug port: issuing radio power off.");
+            data = 0;
+            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
+            // Close the socket
+            if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
+                close(s_ril_param_socket.fdCommand);
+                s_ril_param_socket.fdCommand = -1;
+            }
+        #if (SIM_COUNT == 2)
+            else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
+                close(s_ril_param_socket2.fdCommand);
+                s_ril_param_socket2.fdCommand = -1;
+            }
+        #endif
+            break;
+        case 2:
+            RLOGI ("Debug port: issuing unsolicited voice network change.");
+            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
+            break;
+        case 3:
+            RLOGI ("Debug port: QXDM log enable.");
+            qxdm_data[0] = 65536;     // head.func_tag
+            qxdm_data[1] = 16;        // head.len
+            qxdm_data[2] = 1;         // mode: 1 for 'start logging'
+            qxdm_data[3] = 32;        // log_file_size: 32megabytes
+            qxdm_data[4] = 0;         // log_mask
+            qxdm_data[5] = 8;         // log_max_fileindex
+            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
+                              6 * sizeof(int), socket_id);
+            break;
+        case 4:
+            RLOGI ("Debug port: QXDM log disable.");
+            qxdm_data[0] = 65536;
+            qxdm_data[1] = 16;
+            qxdm_data[2] = 0;          // mode: 0 for 'stop logging'
+            qxdm_data[3] = 32;
+            qxdm_data[4] = 0;
+            qxdm_data[5] = 8;
+            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
+                              6 * sizeof(int), socket_id);
+            break;
+        case 5:
+            RLOGI("Debug port: Radio On");
+            data = 1;
+            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
+            sleep(2);
+            // Set network selection automatic.
+            issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
+            break;
+        case 6:
+            RLOGI("Debug port: Setup Data Call, Apn :%s\n", args[1]);
+            actData[0] = args[1];
+            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
+                              sizeof(actData), socket_id);
+            break;
+        case 7:
+            RLOGI("Debug port: Deactivate Data Call");
+            issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
+                              sizeof(deactData), socket_id);
+            break;
+        case 8:
+            RLOGI("Debug port: Dial Call");
+            dialData.clir = 0;
+            dialData.address = args[1];
+            issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
+            break;
+        case 9:
+            RLOGI("Debug port: Answer Call");
+            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
+            break;
+        case 10:
+            RLOGI("Debug port: End Call");
+            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
+                              sizeof(hangupData), socket_id);
+            break;
+        default:
+            RLOGE ("Invalid request");
+            break;
+    }
+    freeDebugCallbackArgs(number, args);
+    close(acceptFD);
+}
+
+
+static void userTimerCallback (int fd, short flags, void *param) {
+    UserCallbackInfo *p_info;
+
+    p_info = (UserCallbackInfo *)param;
+
+    p_info->p_callback(p_info->userParam);
+
+
+    // FIXME generalize this...there should be a cancel mechanism
+    if (s_last_wake_timeout_info != NULL && s_last_wake_timeout_info == p_info) {
+        s_last_wake_timeout_info = NULL;
+    }
+
+    free(p_info);
+}
+
+
+static void *
+eventLoop(void *param) {
+    int ret;
+    int filedes[2];
+
+    ril_event_init();
+
+    pthread_mutex_lock(&s_startupMutex);
+
+    s_started = 1;
+    pthread_cond_broadcast(&s_startupCond);
+
+    pthread_mutex_unlock(&s_startupMutex);
+
+    ret = pipe(filedes);
+
+    if (ret < 0) {
+        RLOGE("Error in pipe() errno:%d", errno);
+        return NULL;
+    }
+
+    s_fdWakeupRead = filedes[0];
+    s_fdWakeupWrite = filedes[1];
+
+    fcntl(s_fdWakeupRead, F_SETFL, O_NONBLOCK);
+
+    ril_event_set (&s_wakeupfd_event, s_fdWakeupRead, true,
+                processWakeupCallback, NULL);
+
+    rilEventAddWakeup (&s_wakeupfd_event);
+
+    // Only returns on error
+    ril_event_loop();
+    RLOGE ("error in event_loop_base errno:%d", errno);
+    // kill self to restart on error
+    kill(0, SIGKILL);
+
+    return NULL;
+}
+
+extern "C" void
+RIL_startEventLoop(void) {
+    /* spin up eventLoop thread and wait for it to get started */
+    s_started = 0;
+    pthread_mutex_lock(&s_startupMutex);
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    int result = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);
+    if (result != 0) {
+        RLOGE("Failed to create dispatch thread: %s", strerror(result));
+        goto done;
+    }
+
+    while (s_started == 0) {
+        pthread_cond_wait(&s_startupCond, &s_startupMutex);
+    }
+
+done:
+    pthread_mutex_unlock(&s_startupMutex);
+}
+
+// Used for testing purpose only.
+extern "C" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
+    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
+}
+
+static void startListen(RIL_SOCKET_ID socket_id, SocketListenParam* socket_listen_p) {
+    int fdListen = -1;
+    int ret;
+    char socket_name[10];
+
+    memset(socket_name, 0, sizeof(char)*10);
+
+    switch(socket_id) {
+        case RIL_SOCKET_1:
+            strncpy(socket_name, RIL_getRilSocketName(), 9);
+            break;
+    #if (SIM_COUNT >= 2)
+        case RIL_SOCKET_2:
+            strncpy(socket_name, SOCKET2_NAME_RIL, 9);
+            break;
+    #endif
+    #if (SIM_COUNT >= 3)
+        case RIL_SOCKET_3:
+            strncpy(socket_name, SOCKET3_NAME_RIL, 9);
+            break;
+    #endif
+    #if (SIM_COUNT >= 4)
+        case RIL_SOCKET_4:
+            strncpy(socket_name, SOCKET4_NAME_RIL, 9);
+            break;
+    #endif
+        default:
+            RLOGE("Socket id is wrong!!");
+            return;
+    }
+
+    RLOGI("Start to listen %s", rilSocketIdToString(socket_id));
+
+    fdListen = android_get_control_socket(socket_name);
+    if (fdListen < 0) {
+        RLOGE("Failed to get socket %s", socket_name);
+        exit(-1);
+    }
+
+    ret = listen(fdListen, 4);
+
+    if (ret < 0) {
+        RLOGE("Failed to listen on control socket '%d': %s",
+             fdListen, strerror(errno));
+        exit(-1);
+    }
+    socket_listen_p->fdListen = fdListen;
+
+    /* note: non-persistent so we can accept only one connection at a time */
+    ril_event_set (socket_listen_p->listen_event, fdListen, false,
+                listenCallback, socket_listen_p);
+
+    rilEventAddWakeup (socket_listen_p->listen_event);
+}
+
+extern "C" void
+RIL_register (const RIL_RadioFunctions *callbacks) {
+    int ret;
+    int flags;
+
+    RLOGI("SIM_COUNT: %d", SIM_COUNT);
+
+    if (callbacks == NULL) {
+        RLOGE("RIL_register: RIL_RadioFunctions * null");
+        return;
+    }
+    if (callbacks->version < RIL_VERSION_MIN) {
+        RLOGE("RIL_register: version %d is to old, min version is %d",
+             callbacks->version, RIL_VERSION_MIN);
+        return;
+    }
+
+    RLOGE("RIL_register: RIL version %d", callbacks->version);
+
+    if (s_registerCalled > 0) {
+        RLOGE("RIL_register has been called more than once. "
+                "Subsequent call ignored");
+        return;
+    }
+
+    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
+
+    /* Initialize socket1 parameters */
+    s_ril_param_socket = {
+                        RIL_SOCKET_1,             /* socket_id */
+                        -1,                       /* fdListen */
+                        -1,                       /* fdCommand */
+                        PHONE_PROCESS,            /* processName */
+                        &s_commands_event,        /* commands_event */
+                        &s_listen_event,          /* listen_event */
+                        processCommandsCallback,  /* processCommandsCallback */
+                        NULL,                     /* p_rs */
+                        RIL_TELEPHONY_SOCKET      /* type */
+                        };
+
+#if (SIM_COUNT >= 2)
+    s_ril_param_socket2 = {
+                        RIL_SOCKET_2,               /* socket_id */
+                        -1,                         /* fdListen */
+                        -1,                         /* fdCommand */
+                        PHONE_PROCESS,              /* processName */
+                        &s_commands_event_socket2,  /* commands_event */
+                        &s_listen_event_socket2,    /* listen_event */
+                        processCommandsCallback,    /* processCommandsCallback */
+                        NULL,                       /* p_rs */
+                        RIL_TELEPHONY_SOCKET        /* type */
+                        };
+#endif
+
+#if (SIM_COUNT >= 3)
+    s_ril_param_socket3 = {
+                        RIL_SOCKET_3,               /* socket_id */
+                        -1,                         /* fdListen */
+                        -1,                         /* fdCommand */
+                        PHONE_PROCESS,              /* processName */
+                        &s_commands_event_socket3,  /* commands_event */
+                        &s_listen_event_socket3,    /* listen_event */
+                        processCommandsCallback,    /* processCommandsCallback */
+                        NULL,                       /* p_rs */
+                        RIL_TELEPHONY_SOCKET        /* type */
+                        };
+#endif
+
+#if (SIM_COUNT >= 4)
+    s_ril_param_socket4 = {
+                        RIL_SOCKET_4,               /* socket_id */
+                        -1,                         /* fdListen */
+                        -1,                         /* fdCommand */
+                        PHONE_PROCESS,              /* processName */
+                        &s_commands_event_socket4,  /* commands_event */
+                        &s_listen_event_socket4,    /* listen_event */
+                        processCommandsCallback,    /* processCommandsCallback */
+                        NULL,                       /* p_rs */
+                        RIL_TELEPHONY_SOCKET        /* type */
+                        };
+#endif
+
+
+    s_registerCalled = 1;
+
+    RLOGI("s_registerCalled flag set, %d", s_started);
+    // Little self-check
+
+    for (int i = 0; i < (int)NUM_ELEMS(s_commands); i++) {
+        assert(i == s_commands[i].requestNumber);
+    }
+
+    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses); i++) {
+        assert(i + RIL_UNSOL_RESPONSE_BASE
+                == s_unsolResponses[i].requestNumber);
+    }
+
+    // New rild impl calls RIL_startEventLoop() first
+    // old standalone impl wants it here.
+
+    if (s_started == 0) {
+        RIL_startEventLoop();
+    }
+
+    // start listen socket1
+    startListen(RIL_SOCKET_1, &s_ril_param_socket);
+
+#if (SIM_COUNT >= 2)
+    // start listen socket2
+    startListen(RIL_SOCKET_2, &s_ril_param_socket2);
+#endif /* (SIM_COUNT == 2) */
+
+#if (SIM_COUNT >= 3)
+    // start listen socket3
+    startListen(RIL_SOCKET_3, &s_ril_param_socket3);
+#endif /* (SIM_COUNT == 3) */
+
+#if (SIM_COUNT >= 4)
+    // start listen socket4
+    startListen(RIL_SOCKET_4, &s_ril_param_socket4);
+#endif /* (SIM_COUNT == 4) */
+
+
+#if 1
+    // start debug interface socket
+
+    char *inst = NULL;
+    if (strlen(RIL_getRilSocketName()) >= strlen(SOCKET_NAME_RIL)) {
+        inst = RIL_getRilSocketName() + strlen(SOCKET_NAME_RIL);
+    }
+
+    char rildebug[MAX_DEBUG_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL_DEBUG;
+    if (inst != NULL) {
+        strlcat(rildebug, inst, MAX_DEBUG_SOCKET_NAME_LENGTH);
+    }
+
+    s_fdDebug = android_get_control_socket(rildebug);
+    if (s_fdDebug < 0) {
+        RLOGE("Failed to get socket : %s errno:%d", rildebug, errno);
+        exit(-1);
+    }
+
+    ret = listen(s_fdDebug, 4);
+
+    if (ret < 0) {
+        RLOGE("Failed to listen on ril debug socket '%d': %s",
+             s_fdDebug, strerror(errno));
+        exit(-1);
+    }
+
+    ril_event_set (&s_debug_event, s_fdDebug, true,
+                debugCallback, NULL);
+
+    rilEventAddWakeup (&s_debug_event);
+#endif
+
+}
+
+extern "C" void
+RIL_register_socket (RIL_RadioFunctions *(*Init)(const struct RIL_Env *, int, char **),RIL_SOCKET_TYPE socketType, int argc, char **argv) {
+
+    RIL_RadioFunctions* UimFuncs = NULL;
+
+    if(Init) {
+        UimFuncs = Init(&RilSapSocket::uimRilEnv, argc, argv);
+
+        switch(socketType) {
+            case RIL_SAP_SOCKET:
+                RilSapSocket::initSapSocket("sap_uim_socket1", UimFuncs);
+
+#if (SIM_COUNT >= 2)
+                RilSapSocket::initSapSocket("sap_uim_socket2", UimFuncs);
+#endif
+
+#if (SIM_COUNT >= 3)
+                RilSapSocket::initSapSocket("sap_uim_socket3", UimFuncs);
+#endif
+
+#if (SIM_COUNT >= 4)
+                RilSapSocket::initSapSocket("sap_uim_socket4", UimFuncs);
+#endif
+                break;
+            default:;
+        }
+    }
+}
+
+// Check and remove RequestInfo if its a response and not just ack sent back
+static int
+checkAndDequeueRequestInfoIfAck(struct RequestInfo *pRI, bool isAck) {
+    int ret = 0;
+    /* Hook for current context
+       pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
+    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
+    /* pendingRequestsHook refer to &s_pendingRequests */
+    RequestInfo ** pendingRequestsHook = &s_pendingRequests;
+
+    if (pRI == NULL) {
+        return 0;
+    }
+
+#if (SIM_COUNT >= 2)
+    if (pRI->socket_id == RIL_SOCKET_2) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
+        pendingRequestsHook = &s_pendingRequests_socket2;
+    }
+#if (SIM_COUNT >= 3)
+        if (pRI->socket_id == RIL_SOCKET_3) {
+            pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
+            pendingRequestsHook = &s_pendingRequests_socket3;
+        }
+#endif
+#if (SIM_COUNT >= 4)
+    if (pRI->socket_id == RIL_SOCKET_4) {
+        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
+        pendingRequestsHook = &s_pendingRequests_socket4;
+    }
+#endif
+#endif
+    pthread_mutex_lock(pendingRequestsMutexHook);
+
+    for(RequestInfo **ppCur = pendingRequestsHook
+        ; *ppCur != NULL
+        ; ppCur = &((*ppCur)->p_next)
+    ) {
+        if (pRI == *ppCur) {
+            ret = 1;
+            if (isAck) { // Async ack
+                if (pRI->wasAckSent == 1) {
+                    RLOGD("Ack was already sent for %s", requestToString(pRI->pCI->requestNumber));
+                } else {
+                    pRI->wasAckSent = 1;
+                }
+            } else {
+                *ppCur = (*ppCur)->p_next;
+            }
+            break;
+        }
+    }
+
+    pthread_mutex_unlock(pendingRequestsMutexHook);
+
+    return ret;
+}
+
+static int findFd(int socket_id) {
+    int fd = s_ril_param_socket.fdCommand;
+#if (SIM_COUNT >= 2)
+    if (socket_id == RIL_SOCKET_2) {
+        fd = s_ril_param_socket2.fdCommand;
+    }
+#if (SIM_COUNT >= 3)
+    if (socket_id == RIL_SOCKET_3) {
+        fd = s_ril_param_socket3.fdCommand;
+    }
+#endif
+#if (SIM_COUNT >= 4)
+    if (socket_id == RIL_SOCKET_4) {
+        fd = s_ril_param_socket4.fdCommand;
+    }
+#endif
+#endif
+    return fd;
+}
+
+extern "C" void
+RIL_onRequestAck(RIL_Token t) {
+    RequestInfo *pRI;
+    int ret, fd;
+
+    size_t errorOffset;
+    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
+
+    pRI = (RequestInfo *)t;
+
+    if (!checkAndDequeueRequestInfoIfAck(pRI, true)) {
+        RLOGE ("RIL_onRequestAck: invalid RIL_Token");
+        return;
+    }
+
+    socket_id = pRI->socket_id;
+    fd = findFd(socket_id);
+
+#if VDBG
+    RLOGD("Request Ack, %s", rilSocketIdToString(socket_id));
+#endif
+
+    appendPrintBuf("Ack [%04d]< %s", pRI->token, requestToString(pRI->pCI->requestNumber));
+
+    if (pRI->cancelled == 0) {
+        Parcel p;
+
+        p.writeInt32 (RESPONSE_SOLICITED_ACK);
+        p.writeInt32 (pRI->token);
+
+        if (fd < 0) {
+            RLOGD ("RIL onRequestComplete: Command channel closed");
+        }
+
+        sendResponse(p, socket_id);
+    }
+}
+
+extern "C" void
+RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen) {
+    RequestInfo *pRI;
+    int ret;
+    int fd;
+    size_t errorOffset;
+    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
+
+    pRI = (RequestInfo *)t;
+
+    if (!checkAndDequeueRequestInfoIfAck(pRI, false)) {
+        RLOGE ("RIL_onRequestComplete: invalid RIL_Token");
+        return;
+    }
+
+    socket_id = pRI->socket_id;
+    fd = findFd(socket_id);
+
+#if VDBG
+    RLOGD("RequestComplete, %s", rilSocketIdToString(socket_id));
+#endif
+
+    if (pRI->local > 0) {
+        // Locally issued command...void only!
+        // response does not go back up the command socket
+        RLOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));
+
+        goto done;
+    }
+
+    appendPrintBuf("[%04d]< %s",
+        pRI->token, requestToString(pRI->pCI->requestNumber));
+
+    if (pRI->cancelled == 0) {
+        Parcel p;
+
+        if (s_callbacks.version >= 13 && pRI->wasAckSent == 1) {
+            // If ack was already sent, then this call is an asynchronous response. So we need to
+            // send id indicating that we expect an ack from RIL.java as we acquire wakelock here.
+            p.writeInt32 (RESPONSE_SOLICITED_ACK_EXP);
+            grabPartialWakeLock();
+        } else {
+            p.writeInt32 (RESPONSE_SOLICITED);
+        }
+        p.writeInt32 (pRI->token);
+        errorOffset = p.dataPosition();
+
+        p.writeInt32 (e);
+
+        if (response != NULL) {
+            // there is a response payload, no matter success or not.
+            ret = pRI->pCI->responseFunction(p, response, responselen);
+
+            /* if an error occurred, rewind and mark it */
+            if (ret != 0) {
+                RLOGE ("responseFunction error, ret %d", ret);
+                p.setDataPosition(errorOffset);
+                p.writeInt32 (ret);
+            }
+        }
+
+        if (e != RIL_E_SUCCESS) {
+            appendPrintBuf("%s fails by %s", printBuf, failCauseToString(e));
+        }
+
+        if (fd < 0) {
+            RLOGD ("RIL onRequestComplete: Command channel closed");
+        }
+        sendResponse(p, socket_id);
+    }
+
+done:
+    free(pRI);
+}
+
+static void
+grabPartialWakeLock() {
+    if (s_callbacks.version >= 13) {
+        int ret;
+        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
+        assert(ret == 0);
+        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
+
+        UserCallbackInfo *p_info =
+                internalRequestTimedCallback(wakeTimeoutCallback, NULL, &TIMEVAL_WAKE_TIMEOUT);
+        if (p_info == NULL) {
+            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
+        } else {
+            s_wakelock_count++;
+            if (s_last_wake_timeout_info != NULL) {
+                s_last_wake_timeout_info->userParam = (void *)1;
+            }
+            s_last_wake_timeout_info = p_info;
+        }
+        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
+        assert(ret == 0);
+    } else {
+        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
+    }
+}
+
+static void
+releaseWakeLock() {
+    if (s_callbacks.version >= 13) {
+        int ret;
+        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
+        assert(ret == 0);
+
+        if (s_wakelock_count > 1) {
+            s_wakelock_count--;
+        } else {
+            s_wakelock_count = 0;
+            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
+            if (s_last_wake_timeout_info != NULL) {
+                s_last_wake_timeout_info->userParam = (void *)1;
+            }
+        }
+
+        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
+        assert(ret == 0);
+    } else {
+        release_wake_lock(ANDROID_WAKE_LOCK_NAME);
+    }
+}
+
+/**
+ * Timer callback to put us back to sleep before the default timeout
+ */
+static void
+wakeTimeoutCallback (void *param) {
+    // We're using "param != NULL" as a cancellation mechanism
+    if (s_callbacks.version >= 13) {
+        if (param == NULL) {
+            int ret;
+            ret = pthread_mutex_lock(&s_wakeLockCountMutex);
+            assert(ret == 0);
+            s_wakelock_count = 0;
+            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
+            ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
+            assert(ret == 0);
+        }
+    } else {
+        if (param == NULL) {
+            releaseWakeLock();
+        }
+    }
+}
+
+static int
+decodeVoiceRadioTechnology (RIL_RadioState radioState) {
+    switch (radioState) {
+        case RADIO_STATE_SIM_NOT_READY:
+        case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
+        case RADIO_STATE_SIM_READY:
+            return RADIO_TECH_UMTS;
+
+        case RADIO_STATE_RUIM_NOT_READY:
+        case RADIO_STATE_RUIM_READY:
+        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
+        case RADIO_STATE_NV_NOT_READY:
+        case RADIO_STATE_NV_READY:
+            return RADIO_TECH_1xRTT;
+
+        default:
+            RLOGD("decodeVoiceRadioTechnology: Invoked with incorrect RadioState");
+            return -1;
+    }
+}
+
+static int
+decodeCdmaSubscriptionSource (RIL_RadioState radioState) {
+    switch (radioState) {
+        case RADIO_STATE_SIM_NOT_READY:
+        case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
+        case RADIO_STATE_SIM_READY:
+        case RADIO_STATE_RUIM_NOT_READY:
+        case RADIO_STATE_RUIM_READY:
+        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
+            return CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
+
+        case RADIO_STATE_NV_NOT_READY:
+        case RADIO_STATE_NV_READY:
+            return CDMA_SUBSCRIPTION_SOURCE_NV;
+
+        default:
+            RLOGD("decodeCdmaSubscriptionSource: Invoked with incorrect RadioState");
+            return -1;
+    }
+}
+
+static int
+decodeSimStatus (RIL_RadioState radioState) {
+   switch (radioState) {
+       case RADIO_STATE_SIM_NOT_READY:
+       case RADIO_STATE_RUIM_NOT_READY:
+       case RADIO_STATE_NV_NOT_READY:
+       case RADIO_STATE_NV_READY:
+           return -1;
+       case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
+       case RADIO_STATE_SIM_READY:
+       case RADIO_STATE_RUIM_READY:
+       case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
+           return radioState;
+       default:
+           RLOGD("decodeSimStatus: Invoked with incorrect RadioState");
+           return -1;
+   }
+}
+
+static bool is3gpp2(int radioTech) {
+    switch (radioTech) {
+        case RADIO_TECH_IS95A:
+        case RADIO_TECH_IS95B:
+        case RADIO_TECH_1xRTT:
+        case RADIO_TECH_EVDO_0:
+        case RADIO_TECH_EVDO_A:
+        case RADIO_TECH_EVDO_B:
+        case RADIO_TECH_EHRPD:
+            return true;
+        default:
+            return false;
+    }
+}
+
+/* If RIL sends SIM states or RUIM states, store the voice radio
+ * technology and subscription source information so that they can be
+ * returned when telephony framework requests them
+ */
+static RIL_RadioState
+processRadioState(RIL_RadioState newRadioState, RIL_SOCKET_ID socket_id) {
+
+    if((newRadioState > RADIO_STATE_UNAVAILABLE) && (newRadioState < RADIO_STATE_ON)) {
+        int newVoiceRadioTech;
+        int newCdmaSubscriptionSource;
+        int newSimStatus;
+
+        /* This is old RIL. Decode Subscription source and Voice Radio Technology
+           from Radio State and send change notifications if there has been a change */
+        newVoiceRadioTech = decodeVoiceRadioTechnology(newRadioState);
+        if(newVoiceRadioTech != voiceRadioTech) {
+            voiceRadioTech = newVoiceRadioTech;
+            RIL_UNSOL_RESPONSE(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED,
+                        &voiceRadioTech, sizeof(voiceRadioTech), socket_id);
+        }
+        if(is3gpp2(newVoiceRadioTech)) {
+            newCdmaSubscriptionSource = decodeCdmaSubscriptionSource(newRadioState);
+            if(newCdmaSubscriptionSource != cdmaSubscriptionSource) {
+                cdmaSubscriptionSource = newCdmaSubscriptionSource;
+                RIL_UNSOL_RESPONSE(RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED,
+                        &cdmaSubscriptionSource, sizeof(cdmaSubscriptionSource), socket_id);
+            }
+        }
+        newSimStatus = decodeSimStatus(newRadioState);
+        if(newSimStatus != simRuimStatus) {
+            simRuimStatus = newSimStatus;
+            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0, socket_id);
+        }
+
+        /* Send RADIO_ON to telephony */
+        newRadioState = RADIO_STATE_ON;
+    }
+
+    return newRadioState;
+}
+
+
+#if defined(ANDROID_MULTI_SIM)
+extern "C"
+void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen, RIL_SOCKET_ID socket_id)
+#else
+extern "C"
+void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
+                                size_t datalen)
+#endif
+{
+    int unsolResponseIndex;
+    int ret;
+    int64_t timeReceived = 0;
+    bool shouldScheduleTimeout = false;
+    RIL_RadioState newState;
+    RIL_SOCKET_ID soc_id = RIL_SOCKET_1;
+
+#if defined(ANDROID_MULTI_SIM)
+    soc_id = socket_id;
+#endif
+
+
+    if (s_registerCalled == 0) {
+        // Ignore RIL_onUnsolicitedResponse before RIL_register
+        RLOGW("RIL_onUnsolicitedResponse called before RIL_register");
+        return;
+    }
+
+    unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
+
+    if ((unsolResponseIndex < 0)
+        || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
+        RLOGE("unsupported unsolicited response code %d", unsolResponse);
+        return;
+    }
+
+    // Grab a wake lock if needed for this reponse,
+    // as we exit we'll either release it immediately
+    // or set a timer to release it later.
+    switch (s_unsolResponses[unsolResponseIndex].wakeType) {
+        case WAKE_PARTIAL:
+            grabPartialWakeLock();
+            shouldScheduleTimeout = true;
+        break;
+
+        case DONT_WAKE:
+        default:
+            // No wake lock is grabed so don't set timeout
+            shouldScheduleTimeout = false;
+            break;
+    }
+
+    // Mark the time this was received, doing this
+    // after grabing the wakelock incase getting
+    // the elapsedRealTime might cause us to goto
+    // sleep.
+    if (unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
+        timeReceived = elapsedRealtime();
+    }
+
+    appendPrintBuf("[UNSL]< %s", requestToString(unsolResponse));
+
+    Parcel p;
+    if (s_callbacks.version >= 13
+                && s_unsolResponses[unsolResponseIndex].wakeType == WAKE_PARTIAL) {
+        p.writeInt32 (RESPONSE_UNSOLICITED_ACK_EXP);
+    } else {
+        p.writeInt32 (RESPONSE_UNSOLICITED);
+    }
+    p.writeInt32 (unsolResponse);
+
+    ret = s_unsolResponses[unsolResponseIndex]
+                .responseFunction(p, const_cast<void*>(data), datalen);
+    if (ret != 0) {
+        // Problem with the response. Don't continue;
+        goto error_exit;
+    }
+
+    // some things get more payload
+    switch(unsolResponse) {
+        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+            newState = processRadioState(CALL_ONSTATEREQUEST(soc_id), soc_id);
+            p.writeInt32(newState);
+            appendPrintBuf("%s {%s}", printBuf,
+                radioStateToString(CALL_ONSTATEREQUEST(soc_id)));
+        break;
+
+
+        case RIL_UNSOL_NITZ_TIME_RECEIVED:
+            // Store the time that this was received so the
+            // handler of this message can account for
+            // the time it takes to arrive and process. In
+            // particular the system has been known to sleep
+            // before this message can be processed.
+            p.writeInt64(timeReceived);
+        break;
+    }
+
+    if (s_callbacks.version < 13) {
+        if (shouldScheduleTimeout) {
+            UserCallbackInfo *p_info = internalRequestTimedCallback(wakeTimeoutCallback, NULL,
+                    &TIMEVAL_WAKE_TIMEOUT);
+
+            if (p_info == NULL) {
+                goto error_exit;
+            } else {
+                // Cancel the previous request
+                if (s_last_wake_timeout_info != NULL) {
+                    s_last_wake_timeout_info->userParam = (void *)1;
+                }
+                s_last_wake_timeout_info = p_info;
+            }
+        }
+    }
+
+#if VDBG
+    RLOGI("%s UNSOLICITED: %s length:%d", rilSocketIdToString(soc_id), requestToString(unsolResponse), p.dataSize());
+#endif
+    ret = sendResponse(p, soc_id);
+    if (ret != 0 && unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
+
+        // Unfortunately, NITZ time is not poll/update like everything
+        // else in the system. So, if the upstream client isn't connected,
+        // keep a copy of the last NITZ response (with receive time noted
+        // above) around so we can deliver it when it is connected
+
+        if (s_lastNITZTimeData != NULL) {
+            free (s_lastNITZTimeData);
+            s_lastNITZTimeData = NULL;
+        }
+
+        s_lastNITZTimeData = calloc(p.dataSize(), 1);
+        if (s_lastNITZTimeData == NULL) {
+             RLOGE("Memory allocation failed in RIL_onUnsolicitedResponse");
+             goto error_exit;
+        }
+        s_lastNITZTimeDataSize = p.dataSize();
+        memcpy(s_lastNITZTimeData, p.data(), p.dataSize());
+    }
+
+    // Normal exit
+    return;
+
+error_exit:
+    if (shouldScheduleTimeout) {
+        releaseWakeLock();
+    }
+}
+
+/** FIXME generalize this if you track UserCAllbackInfo, clear it
+    when the callback occurs
+*/
+static UserCallbackInfo *
+internalRequestTimedCallback (RIL_TimedCallback callback, void *param,
+                                const struct timeval *relativeTime)
+{
+    struct timeval myRelativeTime;
+    UserCallbackInfo *p_info;
+
+    p_info = (UserCallbackInfo *) calloc(1, sizeof(UserCallbackInfo));
+    if (p_info == NULL) {
+        RLOGE("Memory allocation failed in internalRequestTimedCallback");
+        return p_info;
+
+    }
+
+    p_info->p_callback = callback;
+    p_info->userParam = param;
+
+    if (relativeTime == NULL) {
+        /* treat null parameter as a 0 relative time */
+        memset (&myRelativeTime, 0, sizeof(myRelativeTime));
+    } else {
+        /* FIXME I think event_add's tv param is really const anyway */
+        memcpy (&myRelativeTime, relativeTime, sizeof(myRelativeTime));
+    }
+
+    ril_event_set(&(p_info->event), -1, false, userTimerCallback, p_info);
+
+    ril_timer_add(&(p_info->event), &myRelativeTime);
+
+    triggerEvLoop();
+    return p_info;
+}
+
+
+extern "C" void
+RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
+                                const struct timeval *relativeTime) {
+    internalRequestTimedCallback (callback, param, relativeTime);
+}
+
+const char *
+failCauseToString(RIL_Errno e) {
+    switch(e) {
+        case RIL_E_SUCCESS: return "E_SUCCESS";
+        case RIL_E_RADIO_NOT_AVAILABLE: return "E_RADIO_NOT_AVAILABLE";
+        case RIL_E_GENERIC_FAILURE: return "E_GENERIC_FAILURE";
+        case RIL_E_PASSWORD_INCORRECT: return "E_PASSWORD_INCORRECT";
+        case RIL_E_SIM_PIN2: return "E_SIM_PIN2";
+        case RIL_E_SIM_PUK2: return "E_SIM_PUK2";
+        case RIL_E_REQUEST_NOT_SUPPORTED: return "E_REQUEST_NOT_SUPPORTED";
+        case RIL_E_CANCELLED: return "E_CANCELLED";
+        case RIL_E_OP_NOT_ALLOWED_DURING_VOICE_CALL: return "E_OP_NOT_ALLOWED_DURING_VOICE_CALL";
+        case RIL_E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW: return "E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW";
+        case RIL_E_SMS_SEND_FAIL_RETRY: return "E_SMS_SEND_FAIL_RETRY";
+        case RIL_E_SIM_ABSENT:return "E_SIM_ABSENT";
+        case RIL_E_ILLEGAL_SIM_OR_ME:return "E_ILLEGAL_SIM_OR_ME";
+#ifdef FEATURE_MULTIMODE_ANDROID
+        case RIL_E_SUBSCRIPTION_NOT_AVAILABLE:return "E_SUBSCRIPTION_NOT_AVAILABLE";
+        case RIL_E_MODE_NOT_SUPPORTED:return "E_MODE_NOT_SUPPORTED";
+#endif
+        case RIL_E_FDN_CHECK_FAILURE: return "E_FDN_CHECK_FAILURE";
+        case RIL_E_MISSING_RESOURCE: return "E_MISSING_RESOURCE";
+        case RIL_E_NO_SUCH_ELEMENT: return "E_NO_SUCH_ELEMENT";
+        case RIL_E_DIAL_MODIFIED_TO_USSD: return "E_DIAL_MODIFIED_TO_USSD";
+        case RIL_E_DIAL_MODIFIED_TO_SS: return "E_DIAL_MODIFIED_TO_SS";
+        case RIL_E_DIAL_MODIFIED_TO_DIAL: return "E_DIAL_MODIFIED_TO_DIAL";
+        case RIL_E_USSD_MODIFIED_TO_DIAL: return "E_USSD_MODIFIED_TO_DIAL";
+        case RIL_E_USSD_MODIFIED_TO_SS: return "E_USSD_MODIFIED_TO_SS";
+        case RIL_E_USSD_MODIFIED_TO_USSD: return "E_USSD_MODIFIED_TO_USSD";
+        case RIL_E_SS_MODIFIED_TO_DIAL: return "E_SS_MODIFIED_TO_DIAL";
+        case RIL_E_SS_MODIFIED_TO_USSD: return "E_SS_MODIFIED_TO_USSD";
+        case RIL_E_SUBSCRIPTION_NOT_SUPPORTED: return "E_SUBSCRIPTION_NOT_SUPPORTED";
+        case RIL_E_SS_MODIFIED_TO_SS: return "E_SS_MODIFIED_TO_SS";
+        case RIL_E_LCE_NOT_SUPPORTED: return "E_LCE_NOT_SUPPORTED";
+        case RIL_E_NO_MEMORY: return "E_NO_MEMORY";
+        case RIL_E_INTERNAL_ERR: return "E_INTERNAL_ERR";
+        case RIL_E_SYSTEM_ERR: return "E_SYSTEM_ERR";
+        case RIL_E_MODEM_ERR: return "E_MODEM_ERR";
+        case RIL_E_INVALID_STATE: return "E_INVALID_STATE";
+        case RIL_E_NO_RESOURCES: return "E_NO_RESOURCES";
+        case RIL_E_SIM_ERR: return "E_SIM_ERR";
+        case RIL_E_INVALID_ARGUMENTS: return "E_INVALID_ARGUMENTS";
+        case RIL_E_INVALID_SIM_STATE: return "E_INVALID_SIM_STATE";
+        case RIL_E_INVALID_MODEM_STATE: return "E_INVALID_MODEM_STATE";
+        case RIL_E_INVALID_CALL_ID: return "E_INVALID_CALL_ID";
+        case RIL_E_NO_SMS_TO_ACK: return "E_NO_SMS_TO_ACK";
+        case RIL_E_NETWORK_ERR: return "E_NETWORK_ERR";
+        case RIL_E_REQUEST_RATE_LIMITED: return "E_REQUEST_RATE_LIMITED";
+        case RIL_E_SIM_BUSY: return "E_SIM_BUSY";
+        case RIL_E_SIM_FULL: return "E_SIM_FULL";
+        case RIL_E_NETWORK_REJECT: return "E_NETWORK_REJECT";
+        case RIL_E_OPERATION_NOT_ALLOWED: return "E_OPERATION_NOT_ALLOWED";
+        case RIL_E_EMPTY_RECORD: "E_EMPTY_RECORD";
+        case RIL_E_INVALID_SMS_FORMAT: return "E_INVALID_SMS_FORMAT";
+        case RIL_E_ENCODING_ERR: return "E_ENCODING_ERR";
+        case RIL_E_INVALID_SMSC_ADDRESS: return "E_INVALID_SMSC_ADDRESS";
+        case RIL_E_NO_SUCH_ENTRY: return "E_NO_SUCH_ENTRY";
+        case RIL_E_NETWORK_NOT_READY: return "E_NETWORK_NOT_READY";
+        case RIL_E_NOT_PROVISIONED: return "E_NOT_PROVISIONED";
+        case RIL_E_NO_SUBSCRIPTION: return "E_NO_SUBSCRIPTION";
+        case RIL_E_NO_NETWORK_FOUND: return "E_NO_NETWORK_FOUND";
+        case RIL_E_DEVICE_IN_USE: return "E_DEVICE_IN_USE";
+        case RIL_E_ABORTED: return "E_ABORTED";
+        case RIL_E_OEM_ERROR_1: return "E_OEM_ERROR_1";
+        case RIL_E_OEM_ERROR_2: return "E_OEM_ERROR_2";
+        case RIL_E_OEM_ERROR_3: return "E_OEM_ERROR_3";
+        case RIL_E_OEM_ERROR_4: return "E_OEM_ERROR_4";
+        case RIL_E_OEM_ERROR_5: return "E_OEM_ERROR_5";
+        case RIL_E_OEM_ERROR_6: return "E_OEM_ERROR_6";
+        case RIL_E_OEM_ERROR_7: return "E_OEM_ERROR_7";
+        case RIL_E_OEM_ERROR_8: return "E_OEM_ERROR_8";
+        case RIL_E_OEM_ERROR_9: return "E_OEM_ERROR_9";
+        case RIL_E_OEM_ERROR_10: return "E_OEM_ERROR_10";
+        case RIL_E_OEM_ERROR_11: return "E_OEM_ERROR_11";
+        case RIL_E_OEM_ERROR_12: return "E_OEM_ERROR_12";
+        case RIL_E_OEM_ERROR_13: return "E_OEM_ERROR_13";
+        case RIL_E_OEM_ERROR_14: return "E_OEM_ERROR_14";
+        case RIL_E_OEM_ERROR_15: return "E_OEM_ERROR_15";
+        case RIL_E_OEM_ERROR_16: return "E_OEM_ERROR_16";
+        case RIL_E_OEM_ERROR_17: return "E_OEM_ERROR_17";
+        case RIL_E_OEM_ERROR_18: return "E_OEM_ERROR_18";
+        case RIL_E_OEM_ERROR_19: return "E_OEM_ERROR_19";
+        case RIL_E_OEM_ERROR_20: return "E_OEM_ERROR_20";
+        case RIL_E_OEM_ERROR_21: return "E_OEM_ERROR_21";
+        case RIL_E_OEM_ERROR_22: return "E_OEM_ERROR_22";
+        case RIL_E_OEM_ERROR_23: return "E_OEM_ERROR_23";
+        case RIL_E_OEM_ERROR_24: return "E_OEM_ERROR_24";
+        case RIL_E_OEM_ERROR_25: return "E_OEM_ERROR_25";
+        default: return "<unknown error>";
+    }
+}
+
+const char *
+radioStateToString(RIL_RadioState s) {
+    switch(s) {
+        case RADIO_STATE_OFF: return "RADIO_OFF";
+        case RADIO_STATE_UNAVAILABLE: return "RADIO_UNAVAILABLE";
+        case RADIO_STATE_SIM_NOT_READY: return "RADIO_SIM_NOT_READY";
+        case RADIO_STATE_SIM_LOCKED_OR_ABSENT: return "RADIO_SIM_LOCKED_OR_ABSENT";
+        case RADIO_STATE_SIM_READY: return "RADIO_SIM_READY";
+        case RADIO_STATE_RUIM_NOT_READY:return"RADIO_RUIM_NOT_READY";
+        case RADIO_STATE_RUIM_READY:return"RADIO_RUIM_READY";
+        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:return"RADIO_RUIM_LOCKED_OR_ABSENT";
+        case RADIO_STATE_NV_NOT_READY:return"RADIO_NV_NOT_READY";
+        case RADIO_STATE_NV_READY:return"RADIO_NV_READY";
+        case RADIO_STATE_ON:return"RADIO_ON";
+        default: return "<unknown state>";
+    }
+}
+
+const char *
+callStateToString(RIL_CallState s) {
+    switch(s) {
+        case RIL_CALL_ACTIVE : return "ACTIVE";
+        case RIL_CALL_HOLDING: return "HOLDING";
+        case RIL_CALL_DIALING: return "DIALING";
+        case RIL_CALL_ALERTING: return "ALERTING";
+        case RIL_CALL_INCOMING: return "INCOMING";
+        case RIL_CALL_WAITING: return "WAITING";
+        default: return "<unknown state>";
+    }
+}
+
+const char *
+requestToString(int request) {
+/*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
+
+
+ cat libs/telephony/ril_unsol_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{RIL_([^,]+),([^}]+).+/case RIL_\1: return "\1";/'
+
+*/
+    switch(request) {
+        case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+        case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+        case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+        case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+        case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+        case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+        case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: return "ENTER_NETWORK_DEPERSONALIZATION";
+        case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+        case RIL_REQUEST_DIAL: return "DIAL";
+        case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+        case RIL_REQUEST_HANGUP: return "HANGUP";
+        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+        case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+        case RIL_REQUEST_UDUB: return "UDUB";
+        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+        case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+        case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
+        case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
+        case RIL_REQUEST_OPERATOR: return "OPERATOR";
+        case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+        case RIL_REQUEST_DTMF: return "DTMF";
+        case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+        case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+        case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+        case RIL_REQUEST_SIM_IO: return "SIM_IO";
+        case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+        case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+        case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+        case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+        case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+        case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+        case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+        case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+        case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+        case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+        case RIL_REQUEST_ANSWER: return "ANSWER";
+        case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+        case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+        case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+        case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
+        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+        case RIL_REQUEST_DTMF_START: return "DTMF_START";
+        case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+        case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+        case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "SET_PREFERRED_NETWORK_TYPE";
+        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "GET_PREFERRED_NETWORK_TYPE";
+        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "GET_NEIGHBORING_CELL_IDS";
+        case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+        case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+        case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+        case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+        case RIL_REQUEST_NV_RESET_CONFIG: return "NV_RESET_CONFIG";
+        case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+        case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+        case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+        case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+        case RIL_REQUEST_STK_GET_PROFILE: return "STK_GET_PROFILE";
+        case RIL_REQUEST_STK_SET_PROFILE: return "STK_SET_PROFILE";
+        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "STK_SEND_ENVELOPE_COMMAND";
+        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "STK_SEND_TERMINAL_RESPONSE";
+        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+        case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "EXPLICIT_CALL_TRANSFER";
+        case RIL_REQUEST_SET_LOCATION_UPDATES: return "SET_LOCATION_UPDATES";
+        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:return"CDMA_SET_SUBSCRIPTION_SOURCE";
+        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:return"CDMA_SET_ROAMING_PREFERENCE";
+        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:return"CDMA_QUERY_ROAMING_PREFERENCE";
+        case RIL_REQUEST_SET_TTY_MODE:return"SET_TTY_MODE";
+        case RIL_REQUEST_QUERY_TTY_MODE:return"QUERY_TTY_MODE";
+        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:return"CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:return"CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+        case RIL_REQUEST_CDMA_FLASH:return"CDMA_FLASH";
+        case RIL_REQUEST_CDMA_BURST_DTMF:return"CDMA_BURST_DTMF";
+        case RIL_REQUEST_CDMA_SEND_SMS:return"CDMA_SEND_SMS";
+        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:return"CDMA_SMS_ACKNOWLEDGE";
+        case RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG:return"GSM_GET_BROADCAST_SMS_CONFIG";
+        case RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG:return"GSM_SET_BROADCAST_SMS_CONFIG";
+        case RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG:return "CDMA_GET_BROADCAST_SMS_CONFIG";
+        case RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG:return "CDMA_SET_BROADCAST_SMS_CONFIG";
+        case RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION:return "CDMA_SMS_BROADCAST_ACTIVATION";
+        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return"CDMA_VALIDATE_AND_WRITE_AKEY";
+        case RIL_REQUEST_CDMA_SUBSCRIPTION: return"CDMA_SUBSCRIPTION";
+        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "CDMA_WRITE_SMS_TO_RUIM";
+        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "CDMA_DELETE_SMS_ON_RUIM";
+        case RIL_REQUEST_DEVICE_IDENTITY: return "DEVICE_IDENTITY";
+        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "EXIT_EMERGENCY_CALLBACK_MODE";
+        case RIL_REQUEST_GET_SMSC_ADDRESS: return "GET_SMSC_ADDRESS";
+        case RIL_REQUEST_SET_SMSC_ADDRESS: return "SET_SMSC_ADDRESS";
+        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "REPORT_SMS_MEMORY_STATUS";
+        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "REPORT_STK_SERVICE_IS_RUNNING";
+        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: return "CDMA_GET_SUBSCRIPTION_SOURCE";
+        case RIL_REQUEST_ISIM_AUTHENTICATION: return "ISIM_AUTHENTICATION";
+        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
+        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
+        case RIL_REQUEST_VOICE_RADIO_TECH: return "VOICE_RADIO_TECH";
+        case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+        case RIL_REQUEST_GET_CELL_INFO_LIST: return"GET_CELL_INFO_LIST";
+        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: return"SET_UNSOL_CELL_INFO_LIST_RATE";
+        case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
+        case RIL_REQUEST_IMS_REGISTRATION_STATE: return "IMS_REGISTRATION_STATE";
+        case RIL_REQUEST_IMS_SEND_SMS: return "IMS_SEND_SMS";
+        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "SIM_TRANSMIT_APDU_BASIC";
+        case RIL_REQUEST_SIM_OPEN_CHANNEL: return "SIM_OPEN_CHANNEL";
+        case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "SIM_CLOSE_CHANNEL";
+        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: return "SIM_TRANSMIT_APDU_CHANNEL";
+        case RIL_REQUEST_GET_RADIO_CAPABILITY: return "RIL_REQUEST_GET_RADIO_CAPABILITY";
+        case RIL_REQUEST_SET_RADIO_CAPABILITY: return "RIL_REQUEST_SET_RADIO_CAPABILITY";
+        case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "SET_UICC_SUBSCRIPTION";
+        case RIL_REQUEST_ALLOW_DATA: return "ALLOW_DATA";
+        case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
+        case RIL_REQUEST_SIM_AUTHENTICATION: return "SIM_AUTHENTICATION";
+        case RIL_REQUEST_GET_DC_RT_INFO: return "GET_DC_RT_INFO";
+        case RIL_REQUEST_SET_DC_RT_INFO_RATE: return "SET_DC_RT_INFO_RATE";
+        case RIL_REQUEST_SET_DATA_PROFILE: return "SET_DATA_PROFILE";
+        case RIL_REQUEST_SET_CARRIER_RESTRICTIONS: return "SET_CARRIER_RESTRICTIONS";
+        case RIL_REQUEST_GET_CARRIER_RESTRICTIONS: return "GET_CARRIER_RESTRICTIONS";
+        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
+        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
+        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
+        case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
+        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
+        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
+        case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
+        case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST(obsolete)";
+        case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
+        case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
+        case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
+        case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
+        case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
+        case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
+        case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
+        case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FUL";
+        case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
+        case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
+        case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
+        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
+        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_NEW_CDMA_SMS";
+        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_NEW_BROADCAST_SMS";
+        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
+        case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
+        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
+        case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
+        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
+        case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
+        case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
+        case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
+        case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
+        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED";
+        case RIL_UNSOL_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
+        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
+        case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
+        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
+        case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
+        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED: return "RESPONSE_IMS_NETWORK_STATE_CHANGED";
+        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: return "UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
+        case RIL_UNSOL_SRVCC_STATE_NOTIFY: return "UNSOL_SRVCC_STATE_NOTIFY";
+        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "HARDWARE_CONFIG_CHANGED";
+        case RIL_UNSOL_DC_RT_INFO_CHANGED: return "UNSOL_DC_RT_INFO_CHANGED";
+        case RIL_REQUEST_SHUTDOWN: return "SHUTDOWN";
+        case RIL_UNSOL_RADIO_CAPABILITY: return "RIL_UNSOL_RADIO_CAPABILITY";
+        case RIL_RESPONSE_ACKNOWLEDGEMENT: return "RIL_RESPONSE_ACKNOWLEDGEMENT";
+        case RIL_UNSOL_PCO_DATA: return "RIL_UNSOL_PCO_DATA";
+        default: return "<unknown request>";
+    }
+}
+
+const char *
+rilSocketIdToString(RIL_SOCKET_ID socket_id)
+{
+    switch(socket_id) {
+        case RIL_SOCKET_1:
+            return "RIL_SOCKET_1";
+#if (SIM_COUNT >= 2)
+        case RIL_SOCKET_2:
+            return "RIL_SOCKET_2";
+#endif
+#if (SIM_COUNT >= 3)
+        case RIL_SOCKET_3:
+            return "RIL_SOCKET_3";
+#endif
+#if (SIM_COUNT >= 4)
+        case RIL_SOCKET_4:
+            return "RIL_SOCKET_4";
+#endif
+        default:
+            return "not a valid RIL";
+    }
+}
+
+/*
+ * Returns true for a debuggable build.
+ */
+static bool isDebuggable() {
+    char debuggable[PROP_VALUE_MAX];
+    property_get("ro.debuggable", debuggable, "0");
+    if (strcmp(debuggable, "1") == 0) {
+        return true;
+    }
+    return false;
+}
+
+} /* namespace android */
+
+void rilEventAddWakeup_helper(struct ril_event *ev) {
+    android::rilEventAddWakeup(ev);
+}
+
+void listenCallback_helper(int fd, short flags, void *param) {
+    android::listenCallback(fd, flags, param);
+}
+
+int blockingWrite_helper(int fd, void *buffer, size_t len) {
+    return android::blockingWrite(fd, buffer, len);
+}
diff --git a/rilsrc/libril/rilSocketQueue.h b/rilsrc/libril/rilSocketQueue.h
new file mode 100644
index 0000000..eaa5155
--- /dev/null
+++ b/rilsrc/libril/rilSocketQueue.h
@@ -0,0 +1,167 @@
+/*
+* Copyright (C) 2014 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#include "pb_decode.h"
+#include <pthread.h>
+#include <hardware/ril/librilutils/proto/sap-api.pb.h>
+#include <utils/Log.h>
+
+using namespace std;
+
+/**
+ * Template queue class to handling requests for a rild socket.
+ * <p>
+ * This class performs the following functions :
+ * <ul>
+ *     <li>Enqueue.
+ *     <li>Dequeue.
+ *     <li>Check and dequeue.
+ * </ul>
+ */
+
+template <typename T>
+class Ril_queue {
+
+   /**
+     * Mutex attribute used in queue mutex initialization.
+     */
+    pthread_mutexattr_t attr;
+
+   /**
+     * Queue mutex variable for synchronized queue access.
+     */
+    pthread_mutex_t mutex_instance;
+
+   /**
+     * Condition to be waited on for dequeuing.
+     */
+    pthread_cond_t cond;
+
+   /**
+     * Front of the queue.
+     */
+    T *front;
+
+    public:
+
+       /**
+         * Remove the first element of the queue.
+         *
+         * @return first element of the queue.
+         */
+        T* dequeue(void);
+
+       /**
+         * Add a request to the front of the queue.
+         *
+         * @param Request to be added.
+         */
+        void enqueue(T* request);
+
+       /**
+         * Check if the queue is empty.
+         */
+        int empty(void);
+
+       /**
+         * Check and remove an element with a particular message id and token.
+         *
+         * @param Request message id.
+         * @param Request token.
+         */
+        int checkAndDequeue( MsgId id, int token);
+
+       /**
+         * Queue constructor.
+         */
+        Ril_queue(void);
+};
+
+template <typename T>
+Ril_queue<T>::Ril_queue(void) {
+    pthread_mutexattr_init(&attr);
+    pthread_mutex_init(&mutex_instance, &attr);
+    cond = PTHREAD_COND_INITIALIZER;
+    front = NULL;
+}
+
+template <typename T>
+T* Ril_queue<T>::dequeue(void) {
+    T* temp = NULL;
+
+    pthread_mutex_lock(&mutex_instance);
+    while(empty()) {
+        pthread_cond_wait(&cond, &mutex_instance);
+    }
+    temp = this->front;
+    if(NULL != this->front->p_next) {
+        this->front = this->front->p_next;
+    } else {
+        this->front = NULL;
+    }
+    pthread_mutex_unlock(&mutex_instance);
+
+    return temp;
+}
+
+template <typename T>
+void Ril_queue<T>::enqueue(T* request) {
+
+    pthread_mutex_lock(&mutex_instance);
+
+    if(NULL == this->front) {
+        this->front = request;
+        request->p_next = NULL;
+    } else {
+        request->p_next = this->front;
+        this->front = request;
+    }
+    pthread_cond_broadcast(&cond);
+    pthread_mutex_unlock(&mutex_instance);
+}
+
+template <typename T>
+int Ril_queue<T>::checkAndDequeue(MsgId id, int token) {
+    int ret = 0;
+    T* temp;
+
+    pthread_mutex_lock(&mutex_instance);
+
+    for(T **ppCur = &(this->front); *ppCur != NULL; ppCur = &((*ppCur)->p_next)) {
+        if (token == (*ppCur)->token && id == (*ppCur)->curr->id) {
+            ret = 1;
+            temp = *ppCur;
+            *ppCur = (*ppCur)->p_next;
+            free(temp);
+            break;
+        }
+    }
+
+    pthread_mutex_unlock(&mutex_instance);
+
+    return ret;
+}
+
+
+template <typename T>
+int Ril_queue<T>::empty(void) {
+
+    if(this->front == NULL) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
diff --git a/rilsrc/libril/ril_commands.h b/rilsrc/libril/ril_commands.h
new file mode 100644
index 0000000..8d02c39
--- /dev/null
+++ b/rilsrc/libril/ril_commands.h
@@ -0,0 +1,154 @@
+/* //device/libs/telephony/ril_commands.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+    {0, NULL, NULL},                   //none
+    {RIL_REQUEST_GET_SIM_STATUS, dispatchVoid, responseSimStatus},
+    {RIL_REQUEST_ENTER_SIM_PIN, dispatchStrings, responseInts},
+    {RIL_REQUEST_ENTER_SIM_PUK, dispatchStrings, responseInts},
+    {RIL_REQUEST_ENTER_SIM_PIN2, dispatchStrings, responseInts},
+    {RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts},
+    {RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts},
+    {RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts},
+    {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, dispatchStrings, responseInts},
+    {RIL_REQUEST_GET_CURRENT_CALLS, dispatchVoid, responseCallList},
+    {RIL_REQUEST_DIAL, dispatchDial, responseVoid},
+    {RIL_REQUEST_GET_IMSI, dispatchStrings, responseString},
+    {RIL_REQUEST_HANGUP, dispatchInts, responseVoid},
+    {RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, dispatchVoid, responseVoid},
+    {RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CONFERENCE, dispatchVoid, responseVoid},
+    {RIL_REQUEST_UDUB, dispatchVoid, responseVoid},
+    {RIL_REQUEST_LAST_CALL_FAIL_CAUSE, dispatchVoid, responseFailCause},
+    {RIL_REQUEST_SIGNAL_STRENGTH, dispatchVoid, responseRilSignalStrength},
+    {RIL_REQUEST_VOICE_REGISTRATION_STATE, dispatchVoid, responseStrings},
+    {RIL_REQUEST_DATA_REGISTRATION_STATE, dispatchVoid, responseStrings},
+    {RIL_REQUEST_OPERATOR, dispatchVoid, responseStrings},
+    {RIL_REQUEST_RADIO_POWER, dispatchInts, responseVoid},
+    {RIL_REQUEST_DTMF, dispatchString, responseVoid},
+    {RIL_REQUEST_SEND_SMS, dispatchStrings, responseSMS},
+    {RIL_REQUEST_SEND_SMS_EXPECT_MORE, dispatchStrings, responseSMS},
+    {RIL_REQUEST_SETUP_DATA_CALL, dispatchDataCall, responseSetupDataCall},
+    {RIL_REQUEST_SIM_IO, dispatchSIM_IO, responseSIM_IO},
+    {RIL_REQUEST_SEND_USSD, dispatchString, responseVoid},
+    {RIL_REQUEST_CANCEL_USSD, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_CLIR, dispatchVoid, responseInts},
+    {RIL_REQUEST_SET_CLIR, dispatchInts, responseVoid},
+    {RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, dispatchCallForward, responseCallForwards},
+    {RIL_REQUEST_SET_CALL_FORWARD, dispatchCallForward, responseVoid},
+    {RIL_REQUEST_QUERY_CALL_WAITING, dispatchInts, responseInts},
+    {RIL_REQUEST_SET_CALL_WAITING, dispatchInts, responseVoid},
+    {RIL_REQUEST_SMS_ACKNOWLEDGE, dispatchInts, responseVoid},
+    {RIL_REQUEST_GET_IMEI, dispatchVoid, responseString},
+    {RIL_REQUEST_GET_IMEISV, dispatchVoid, responseString},
+    {RIL_REQUEST_ANSWER,dispatchVoid, responseVoid},
+    {RIL_REQUEST_DEACTIVATE_DATA_CALL, dispatchStrings, responseVoid},
+    {RIL_REQUEST_QUERY_FACILITY_LOCK, dispatchStrings, responseInts},
+    {RIL_REQUEST_SET_FACILITY_LOCK, dispatchStrings, responseInts},
+    {RIL_REQUEST_CHANGE_BARRING_PASSWORD, dispatchStrings, responseVoid},
+    {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, dispatchVoid, responseInts},
+    {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, dispatchString, responseVoid},
+    {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , dispatchVoid, responseStrings},
+    {RIL_REQUEST_DTMF_START, dispatchString, responseVoid},
+    {RIL_REQUEST_DTMF_STOP, dispatchVoid, responseVoid},
+    {RIL_REQUEST_BASEBAND_VERSION, dispatchVoid, responseString},
+    {RIL_REQUEST_SEPARATE_CONNECTION, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_MUTE, dispatchInts, responseVoid},
+    {RIL_REQUEST_GET_MUTE, dispatchVoid, responseInts},
+    {RIL_REQUEST_QUERY_CLIP, dispatchVoid, responseInts},
+    {RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE, dispatchVoid, responseInts},
+    {RIL_REQUEST_DATA_CALL_LIST, dispatchVoid, responseDataCallList},
+    {RIL_REQUEST_RESET_RADIO, dispatchVoid, responseVoid},
+    {RIL_REQUEST_OEM_HOOK_RAW, dispatchRaw, responseRaw},
+    {RIL_REQUEST_OEM_HOOK_STRINGS, dispatchStrings, responseStrings},
+    {RIL_REQUEST_SCREEN_STATE, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, dispatchInts, responseVoid},
+    {RIL_REQUEST_WRITE_SMS_TO_SIM, dispatchSmsWrite, responseInts},
+    {RIL_REQUEST_DELETE_SMS_ON_SIM, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_BAND_MODE, dispatchInts, responseVoid},
+    {RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, dispatchVoid, responseInts},
+    {RIL_REQUEST_STK_GET_PROFILE, dispatchVoid, responseString},
+    {RIL_REQUEST_STK_SET_PROFILE, dispatchString, responseVoid},
+    {RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, dispatchString, responseString},
+    {RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, dispatchString, responseVoid},
+    {RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, dispatchInts, responseVoid},
+    {RIL_REQUEST_EXPLICIT_CALL_TRANSFER, dispatchVoid, responseVoid},
+    {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, dispatchInts, responseVoid},
+    {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, dispatchVoid, responseInts},
+    {RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, dispatchVoid, responseCellList},
+    {RIL_REQUEST_SET_LOCATION_UPDATES, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, dispatchVoid, responseInts},
+    {RIL_REQUEST_SET_TTY_MODE, dispatchInts, responseVoid},
+    {RIL_REQUEST_QUERY_TTY_MODE, dispatchVoid, responseInts},
+    {RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, dispatchVoid, responseInts},
+    {RIL_REQUEST_CDMA_FLASH, dispatchString, responseVoid},
+    {RIL_REQUEST_CDMA_BURST_DTMF, dispatchStrings, responseVoid},
+    {RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY, dispatchString, responseVoid},
+    {RIL_REQUEST_CDMA_SEND_SMS, dispatchCdmaSms, responseSMS},
+    {RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, dispatchCdmaSmsAck, responseVoid},
+    {RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG, dispatchVoid, responseGsmBrSmsCnf},
+    {RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG, dispatchGsmBrSmsCnf, responseVoid},
+    {RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG, dispatchVoid, responseCdmaBrSmsCnf},
+    {RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG, dispatchCdmaBrSmsCnf, responseVoid},
+    {RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION, dispatchInts, responseVoid},
+    {RIL_REQUEST_CDMA_SUBSCRIPTION, dispatchVoid, responseStrings},
+    {RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, dispatchRilCdmaSmsWriteArgs, responseInts},
+    {RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, dispatchInts, responseVoid},
+    {RIL_REQUEST_DEVICE_IDENTITY, dispatchVoid, responseStrings},
+    {RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_SMSC_ADDRESS, dispatchVoid, responseString},
+    {RIL_REQUEST_SET_SMSC_ADDRESS, dispatchString, responseVoid},
+    {RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, dispatchInts, responseVoid},
+    {RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, dispatchVoid, responseVoid},
+    {RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, dispatchCdmaSubscriptionSource, responseInts},
+    {RIL_REQUEST_ISIM_AUTHENTICATION, dispatchString, responseString},
+    {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, dispatchStrings, responseVoid},
+    {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, dispatchString, responseSIM_IO},
+    {RIL_REQUEST_VOICE_RADIO_TECH, dispatchVoiceRadioTech, responseInts},
+    {RIL_REQUEST_GET_CELL_INFO_LIST, dispatchVoid, responseCellInfoList},
+    {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_INITIAL_ATTACH_APN, dispatchSetInitialAttachApn, responseVoid},
+    {RIL_REQUEST_IMS_REGISTRATION_STATE, dispatchVoid, responseInts},
+    {RIL_REQUEST_IMS_SEND_SMS, dispatchImsSms, responseSMS},
+    {RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, dispatchSIM_APDU, responseSIM_IO},
+    {RIL_REQUEST_SIM_OPEN_CHANNEL, dispatchString, responseInts},
+    {RIL_REQUEST_SIM_CLOSE_CHANNEL, dispatchInts, responseVoid},
+    {RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, dispatchSIM_APDU, responseSIM_IO},
+    {RIL_REQUEST_NV_READ_ITEM, dispatchNVReadItem, responseString},
+    {RIL_REQUEST_NV_WRITE_ITEM, dispatchNVWriteItem, responseVoid},
+    {RIL_REQUEST_NV_WRITE_CDMA_PRL, dispatchRaw, responseVoid},
+    {RIL_REQUEST_NV_RESET_CONFIG, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_UICC_SUBSCRIPTION, dispatchUiccSubscripton, responseVoid},
+    {RIL_REQUEST_ALLOW_DATA, dispatchInts, responseVoid},
+    {RIL_REQUEST_GET_HARDWARE_CONFIG, dispatchVoid, responseHardwareConfig},
+    {RIL_REQUEST_SIM_AUTHENTICATION, dispatchSimAuthentication, responseSIM_IO},
+    {RIL_REQUEST_GET_DC_RT_INFO, dispatchVoid, responseDcRtInfo},
+    {RIL_REQUEST_SET_DC_RT_INFO_RATE, dispatchInts, responseVoid},
+    {RIL_REQUEST_SET_DATA_PROFILE, dispatchDataProfile, responseVoid},
+    {RIL_REQUEST_SHUTDOWN, dispatchVoid, responseVoid},
+    {RIL_REQUEST_GET_RADIO_CAPABILITY, dispatchVoid, responseRadioCapability},
+    {RIL_REQUEST_SET_RADIO_CAPABILITY, dispatchRadioCapability, responseRadioCapability},
+    {RIL_REQUEST_START_LCE, dispatchInts, responseLceStatus},
+    {RIL_REQUEST_STOP_LCE, dispatchVoid, responseLceStatus},
+    {RIL_REQUEST_PULL_LCEDATA, dispatchVoid, responseLceData},
+    {RIL_REQUEST_GET_ACTIVITY_INFO, dispatchVoid, responseActivityData},
+    {RIL_REQUEST_SET_CARRIER_RESTRICTIONS, dispatchCarrierRestrictions, responseInts},
+    {RIL_REQUEST_GET_CARRIER_RESTRICTIONS, dispatchVoid, responseCarrierRestrictions},
diff --git a/rilsrc/libril/ril_event.cpp b/rilsrc/libril/ril_event.cpp
new file mode 100644
index 0000000..84b8b72
--- /dev/null
+++ b/rilsrc/libril/ril_event.cpp
@@ -0,0 +1,384 @@
+/* //device/libs/telephony/ril_event.cpp
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "RILC"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <utils/Log.h>
+#include <ril_event.h>
+#include <string.h>
+#include <sys/time.h>
+#include <time.h>
+
+#include <pthread.h>
+static pthread_mutex_t listMutex;
+#define MUTEX_ACQUIRE() pthread_mutex_lock(&listMutex)
+#define MUTEX_RELEASE() pthread_mutex_unlock(&listMutex)
+#define MUTEX_INIT() pthread_mutex_init(&listMutex, NULL)
+#define MUTEX_DESTROY() pthread_mutex_destroy(&listMutex)
+
+#ifndef timeradd
+#define timeradd(tvp, uvp, vvp)						\
+	do {								\
+		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
+		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;       \
+		if ((vvp)->tv_usec >= 1000000) {			\
+			(vvp)->tv_sec++;				\
+			(vvp)->tv_usec -= 1000000;			\
+		}							\
+	} while (0)
+#endif
+
+#ifndef timercmp
+#define timercmp(a, b, op)               \
+        ((a)->tv_sec == (b)->tv_sec      \
+        ? (a)->tv_usec op (b)->tv_usec   \
+        : (a)->tv_sec op (b)->tv_sec)
+#endif
+
+#ifndef timersub
+#define timersub(a, b, res)                           \
+    do {                                              \
+        (res)->tv_sec = (a)->tv_sec - (b)->tv_sec;    \
+        (res)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
+        if ((res)->tv_usec < 0) {                     \
+            (res)->tv_usec += 1000000;                \
+            (res)->tv_sec -= 1;                       \
+        }                                             \
+    } while(0);
+#endif
+
+static fd_set readFds;
+static int nfds = 0;
+
+static struct ril_event * watch_table[MAX_FD_EVENTS];
+static struct ril_event timer_list;
+static struct ril_event pending_list;
+
+#define DEBUG 0
+
+#if DEBUG
+#define dlog(x...) RLOGD( x )
+static void dump_event(struct ril_event * ev)
+{
+    dlog("~~~~ Event %x ~~~~", (unsigned int)ev);
+    dlog("     next    = %x", (unsigned int)ev->next);
+    dlog("     prev    = %x", (unsigned int)ev->prev);
+    dlog("     fd      = %d", ev->fd);
+    dlog("     pers    = %d", ev->persist);
+    dlog("     timeout = %ds + %dus", (int)ev->timeout.tv_sec, (int)ev->timeout.tv_usec);
+    dlog("     func    = %x", (unsigned int)ev->func);
+    dlog("     param   = %x", (unsigned int)ev->param);
+    dlog("~~~~~~~~~~~~~~~~~~");
+}
+#else
+#define dlog(x...) do {} while(0)
+#define dump_event(x) do {} while(0)
+#endif
+
+static void getNow(struct timeval * tv)
+{
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    tv->tv_sec = ts.tv_sec;
+    tv->tv_usec = ts.tv_nsec/1000;
+}
+
+static void init_list(struct ril_event * list)
+{
+    memset(list, 0, sizeof(struct ril_event));
+    list->next = list;
+    list->prev = list;
+    list->fd = -1;
+}
+
+static void addToList(struct ril_event * ev, struct ril_event * list)
+{
+    ev->next = list;
+    ev->prev = list->prev;
+    ev->prev->next = ev;
+    list->prev = ev;
+    dump_event(ev);
+}
+
+static void removeFromList(struct ril_event * ev)
+{
+    dlog("~~~~ +removeFromList ~~~~");
+    dump_event(ev);
+
+    ev->next->prev = ev->prev;
+    ev->prev->next = ev->next;
+    ev->next = NULL;
+    ev->prev = NULL;
+    dlog("~~~~ -removeFromList ~~~~");
+}
+
+
+static void removeWatch(struct ril_event * ev, int index)
+{
+    dlog("~~~~ +removeWatch ~~~~");
+    watch_table[index] = NULL;
+    ev->index = -1;
+
+    FD_CLR(ev->fd, &readFds);
+
+    if (ev->fd+1 == nfds) {
+        int n = 0;
+
+        for (int i = 0; i < MAX_FD_EVENTS; i++) {
+            struct ril_event * rev = watch_table[i];
+
+            if ((rev != NULL) && (rev->fd > n)) {
+                n = rev->fd;
+            }
+        }
+        nfds = n + 1;
+        dlog("~~~~ nfds = %d ~~~~", nfds);
+    }
+    dlog("~~~~ -removeWatch ~~~~");
+}
+
+static void processTimeouts()
+{
+    dlog("~~~~ +processTimeouts ~~~~");
+    MUTEX_ACQUIRE();
+    struct timeval now;
+    struct ril_event * tev = timer_list.next;
+    struct ril_event * next;
+
+    getNow(&now);
+    // walk list, see if now >= ev->timeout for any events
+
+    dlog("~~~~ Looking for timers <= %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
+    while ((tev != &timer_list) && (timercmp(&now, &tev->timeout, >))) {
+        // Timer expired
+        dlog("~~~~ firing timer ~~~~");
+        next = tev->next;
+        removeFromList(tev);
+        addToList(tev, &pending_list);
+        tev = next;
+    }
+    MUTEX_RELEASE();
+    dlog("~~~~ -processTimeouts ~~~~");
+}
+
+static void processReadReadies(fd_set * rfds, int n)
+{
+    dlog("~~~~ +processReadReadies (%d) ~~~~", n);
+    MUTEX_ACQUIRE();
+
+    for (int i = 0; (i < MAX_FD_EVENTS) && (n > 0); i++) {
+        struct ril_event * rev = watch_table[i];
+        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
+            addToList(rev, &pending_list);
+            if (rev->persist == false) {
+                removeWatch(rev, i);
+            }
+            n--;
+        }
+    }
+
+    MUTEX_RELEASE();
+    dlog("~~~~ -processReadReadies (%d) ~~~~", n);
+}
+
+static void firePending()
+{
+    dlog("~~~~ +firePending ~~~~");
+    struct ril_event * ev = pending_list.next;
+    while (ev != &pending_list) {
+        struct ril_event * next = ev->next;
+        removeFromList(ev);
+        ev->func(ev->fd, 0, ev->param);
+        ev = next;
+    }
+    dlog("~~~~ -firePending ~~~~");
+}
+
+static int calcNextTimeout(struct timeval * tv)
+{
+    struct ril_event * tev = timer_list.next;
+    struct timeval now;
+
+    getNow(&now);
+
+    // Sorted list, so calc based on first node
+    if (tev == &timer_list) {
+        // no pending timers
+        return -1;
+    }
+
+    dlog("~~~~ now = %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
+    dlog("~~~~ next = %ds + %dus ~~~~",
+            (int)tev->timeout.tv_sec, (int)tev->timeout.tv_usec);
+    if (timercmp(&tev->timeout, &now, >)) {
+        timersub(&tev->timeout, &now, tv);
+    } else {
+        // timer already expired.
+        tv->tv_sec = tv->tv_usec = 0;
+    }
+    return 0;
+}
+
+// Initialize internal data structs
+void ril_event_init()
+{
+    MUTEX_INIT();
+
+    FD_ZERO(&readFds);
+    init_list(&timer_list);
+    init_list(&pending_list);
+    memset(watch_table, 0, sizeof(watch_table));
+}
+
+// Initialize an event
+void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param)
+{
+    dlog("~~~~ ril_event_set %x ~~~~", (unsigned int)ev);
+    memset(ev, 0, sizeof(struct ril_event));
+    ev->fd = fd;
+    ev->index = -1;
+    ev->persist = persist;
+    ev->func = func;
+    ev->param = param;
+    fcntl(fd, F_SETFL, O_NONBLOCK);
+}
+
+// Add event to watch list
+void ril_event_add(struct ril_event * ev)
+{
+    dlog("~~~~ +ril_event_add ~~~~");
+    MUTEX_ACQUIRE();
+    for (int i = 0; i < MAX_FD_EVENTS; i++) {
+        if (watch_table[i] == NULL) {
+            watch_table[i] = ev;
+            ev->index = i;
+            dlog("~~~~ added at %d ~~~~", i);
+            dump_event(ev);
+            FD_SET(ev->fd, &readFds);
+            if (ev->fd >= nfds) nfds = ev->fd+1;
+            dlog("~~~~ nfds = %d ~~~~", nfds);
+            break;
+        }
+    }
+    MUTEX_RELEASE();
+    dlog("~~~~ -ril_event_add ~~~~");
+}
+
+// Add timer event
+void ril_timer_add(struct ril_event * ev, struct timeval * tv)
+{
+    dlog("~~~~ +ril_timer_add ~~~~");
+    MUTEX_ACQUIRE();
+
+    struct ril_event * list;
+    if (tv != NULL) {
+        // add to timer list
+        list = timer_list.next;
+        ev->fd = -1; // make sure fd is invalid
+
+        struct timeval now;
+        getNow(&now);
+        timeradd(&now, tv, &ev->timeout);
+
+        // keep list sorted
+        while (timercmp(&list->timeout, &ev->timeout, < )
+                && (list != &timer_list)) {
+            list = list->next;
+        }
+        // list now points to the first event older than ev
+        addToList(ev, list);
+    }
+
+    MUTEX_RELEASE();
+    dlog("~~~~ -ril_timer_add ~~~~");
+}
+
+// Remove event from watch or timer list
+void ril_event_del(struct ril_event * ev)
+{
+    dlog("~~~~ +ril_event_del ~~~~");
+    MUTEX_ACQUIRE();
+
+    if (ev->index < 0 || ev->index >= MAX_FD_EVENTS) {
+        MUTEX_RELEASE();
+        return;
+    }
+
+    removeWatch(ev, ev->index);
+
+    MUTEX_RELEASE();
+    dlog("~~~~ -ril_event_del ~~~~");
+}
+
+#if DEBUG
+static void printReadies(fd_set * rfds)
+{
+    for (int i = 0; (i < MAX_FD_EVENTS); i++) {
+        struct ril_event * rev = watch_table[i];
+        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
+          dlog("DON: fd=%d is ready", rev->fd);
+        }
+    }
+}
+#else
+#define printReadies(rfds) do {} while(0)
+#endif
+
+void ril_event_loop()
+{
+    int n;
+    fd_set rfds;
+    struct timeval tv;
+    struct timeval * ptv;
+
+
+    for (;;) {
+
+        // make local copy of read fd_set
+        memcpy(&rfds, &readFds, sizeof(fd_set));
+        if (-1 == calcNextTimeout(&tv)) {
+            // no pending timers; block indefinitely
+            dlog("~~~~ no timers; blocking indefinitely ~~~~");
+            ptv = NULL;
+        } else {
+            dlog("~~~~ blocking for %ds + %dus ~~~~", (int)tv.tv_sec, (int)tv.tv_usec);
+            ptv = &tv;
+        }
+        printReadies(&rfds);
+        n = select(nfds, &rfds, NULL, NULL, ptv);
+        printReadies(&rfds);
+        dlog("~~~~ %d events fired ~~~~", n);
+        if (n < 0) {
+            if (errno == EINTR) continue;
+
+            RLOGE("ril_event: select error (%d)", errno);
+            // bail?
+            return;
+        }
+
+        // Check for timeouts
+        processTimeouts();
+        // Check for read-ready
+        processReadReadies(&rfds, n);
+        // Fire away
+        firePending();
+    }
+}
diff --git a/rilsrc/libril/ril_event.h b/rilsrc/libril/ril_event.h
new file mode 100644
index 0000000..7ba231b
--- /dev/null
+++ b/rilsrc/libril/ril_event.h
@@ -0,0 +1,52 @@
+/* //device/libs/telephony/ril_event.h
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+// Max number of fd's we watch at any one time.  Increase if necessary.
+#define MAX_FD_EVENTS 8
+
+typedef void (*ril_event_cb)(int fd, short events, void *userdata);
+
+struct ril_event {
+    struct ril_event *next;
+    struct ril_event *prev;
+
+    int fd;
+    int index;
+    bool persist;
+    struct timeval timeout;
+    ril_event_cb func;
+    void *param;
+};
+
+// Initialize internal data structs
+void ril_event_init();
+
+// Initialize an event
+void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param);
+
+// Add event to watch list
+void ril_event_add(struct ril_event * ev);
+
+// Add timer event
+void ril_timer_add(struct ril_event * ev, struct timeval * tv);
+
+// Remove event from watch list
+void ril_event_del(struct ril_event * ev);
+
+// Event loop
+void ril_event_loop();
+
diff --git a/rilsrc/libril/ril_unsol_commands.h b/rilsrc/libril/ril_unsol_commands.h
new file mode 100755
index 0000000..11ae050
--- /dev/null
+++ b/rilsrc/libril/ril_unsol_commands.h
@@ -0,0 +1,63 @@
+/* //device/libs/telephony/ril_unsol_commands.h
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+    {RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_NEW_SMS, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_ON_USSD, responseStrings, WAKE_PARTIAL},
+    {RIL_UNSOL_ON_USSD_REQUEST, responseVoid, DONT_WAKE},
+    {RIL_UNSOL_NITZ_TIME_RECEIVED, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_SIGNAL_STRENGTH, responseRilSignalStrength, DONT_WAKE},
+    {RIL_UNSOL_DATA_CALL_LIST_CHANGED, responseDataCallList, WAKE_PARTIAL},
+    {RIL_UNSOL_SUPP_SVC_NOTIFICATION, responseSsn, WAKE_PARTIAL},
+    {RIL_UNSOL_STK_SESSION_END, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_STK_PROACTIVE_COMMAND, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_STK_EVENT_NOTIFY, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_STK_CALL_SETUP, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_SIM_SMS_STORAGE_FULL, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_SIM_REFRESH, responseSimRefresh, WAKE_PARTIAL},
+    {RIL_UNSOL_CALL_RING, responseCallRing, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_CDMA_NEW_SMS, responseCdmaSms, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS, responseRaw, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RESTRICTED_STATE_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_CALL_WAITING, responseCdmaCallWaiting, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_INFO_REC, responseCdmaInformationRecords, WAKE_PARTIAL},
+    {RIL_UNSOL_OEM_HOOK_RAW, responseRaw, WAKE_PARTIAL},
+    {RIL_UNSOL_RINGBACK_TONE, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_RESEND_INCALL_MUTE, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_CDMA_PRL_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_RIL_CONNECTED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_CELL_INFO_LIST, responseCellInfoList, WAKE_PARTIAL},
+    {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
+    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_SRVCC_STATE_NOTIFY, responseInts, WAKE_PARTIAL},
+    {RIL_UNSOL_HARDWARE_CONFIG_CHANGED, responseHardwareConfig, WAKE_PARTIAL},
+    {RIL_UNSOL_DC_RT_INFO_CHANGED, responseDcRtInfo, WAKE_PARTIAL},
+    {RIL_UNSOL_RADIO_CAPABILITY, responseRadioCapability, WAKE_PARTIAL},
+    {RIL_UNSOL_ON_SS, responseSSData, WAKE_PARTIAL},
+    {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, responseString, WAKE_PARTIAL},
+    {RIL_UNSOL_LCEDATA_RECV, responseLceData, WAKE_PARTIAL},
+    {RIL_UNSOL_PCO_DATA, responsePcoData, WAKE_PARTIAL},
-- 
2.7.4

